*** Add File: components/AffectDiagnostic.tsx
+// SpiñO — Affect Diagnostic (Affect Cube v1)
+// Drop-in React component with scoring logic, UI, and 3D cube viz.
+// Usage: import and render <AffectDiagnostic /> (SSR disabled) in a Next.js page.
+
+"use client";
+
+import React, { useMemo, useRef, useState } from "react";
+import { Canvas } from "@react-three/fiber";
+import { OrbitControls } from "@react-three/drei";
+
+type MESAnswer = 0 | 1;
+
+type Inputs = {
+  narrative: string;
+  mes: {
+    M1: MESAnswer; M2: MESAnswer; M3: MESAnswer; M4: MESAnswer; M5: MESAnswer; M6: MESAnswer;
+    M7: MESAnswer; M8: MESAnswer; M9: MESAnswer; M10: MESAnswer; M11: MESAnswer; M12: MESAnswer;
+  };
+  sliders: { clarity: number; agency: number; tension: number; valence: number };
+  conatus: { C1: MESAnswer; C2: MESAnswer; C3: MESAnswer; C4: MESAnswer };
+};
+
+type Vector = { label: string; x: number; y: number; z: number; w: number };
+type Snapshot = {
+  vectors: Vector[];
+  mixture: { x: number; y: number; z: number };
+  confidence: number;
+  notes?: string;
+  traces: Array<{ axis: "X" | "Y" | "Z"; formula: string; inputs: Record<string, number>; value: number }>;
+};
+
+function clamp(v: number, minV: number, maxV: number) { return Math.max(minV, Math.min(maxV, v)); }
+function zToNegPos(value: number, minVal: number, maxVal: number) {
+  const span = maxVal - minVal || 1; const norm = (value - minVal) / span; return clamp(norm * 2 - 1, -1, 1);
+}
+function zToZeroOne(value: number, minVal: number, maxVal: number) {
+  const span = maxVal - minVal || 1; const norm = (value - minVal) / span; return clamp(norm, 0, 1);
+}
+
+function ecpuGuess(narrative: string) {
+  const text = narrative.toLowerCase();
+  const scores: Record<string, number> = { Fear:0, Anger:0, Guilt:0, Shame:0, Grief:0, Hope:0, Gratitude:0 };
+  const inc = (k: keyof typeof scores, v=1)=> (scores[k]+=v);
+  text.includes("fear")&&inc("Fear",2); (text.includes("worry")||text.includes("anxiety"))&&inc("Fear",1);
+  text.includes("angry")&&inc("Anger",2); text.includes("rage")&&inc("Anger",2);
+  text.includes("guilt")&&inc("Guilt",2); text.includes("sorry")&&inc("Guilt",1);
+  text.includes("shame")&&inc("Shame",2); text.includes("embarrass")&&inc("Shame",1);
+  text.includes("loss")&&inc("Grief",2); text.includes("sad")&&inc("Grief",1);
+  text.includes("hope")&&inc("Hope",2); text.includes("grateful")&&inc("Gratitude",2);
+  const entries = Object.entries(scores).sort((a,b)=>b[1]-a[1]);
+  const top = entries.slice(0,3).filter(([,s])=>s>0); return top.length? top : [["Unclear",1]] as any;
+}
+
+function computeSnapshot(inputs: Inputs): Snapshot {
+  const { mes, sliders, conatus, narrative } = inputs;
+  const clar = sliders.clarity/100; const tension = sliders.tension/100;
+  const X_raw = mes.M3 + mes.M7 + clar - mes.M4 - mes.M8;
+  const Y_raw = clar + mes.M9 - mes.M11 - mes.M10;
+  const tensionPenalty = Math.max(0, tension - clar);
+  const Z_raw = conatus.C1 + conatus.C2 + conatus.C3 + conatus.C4 - tensionPenalty;
+  const X = zToNegPos(X_raw, -3, 3); const Y = zToNegPos(Y_raw, -2, 2); const Z = zToZeroOne(Z_raw, -1, 4);
+  const echo = 0.6 + 0.4*(1 - Math.abs(mes.M10 - mes.M11)); const redesc = 0.5 + 0.5*clar;
+  const guessed = ecpuGuess(narrative); const guessLabels = guessed.map(([k])=>String(k));
+  function expectedXY(label: string){
+    switch(label){
+      case "Fear": return {x:-1,y:-1}; case "Guilt": return {x:-1,y:-0.5}; case "Shame": return {x:-0.8,y:-0.6};
+      case "Anger": return {x:0.3,y:-0.6}; case "Grief": return {x:-0.4,y:-0.7}; case "Hope": return {x:0.2,y:0.2};
+      case "Gratitude": return {x:0.7,y:0.7}; default: return {x:0,y:0}; }
+  }
+  const xy = expectedXY(guessLabels[0]||"Unclear");
+  const xyAlign = 1 - (Math.abs(xy.x - X) + Math.abs(xy.y - Y))/4; const ecpu_agree = clamp(xyAlign,0,1);
+  const confidence = clamp((echo + redesc + ecpu_agree)/3, 0, 1);
+  const vecs = guessed.map(([label,score]: any)=>{ const base = expectedXY(String(label)); return { label: String(label), x:(X+base.x)/2, y:(Y+base.y)/2, z: Z, w: Number(score) }; });
+  const sumW = vecs.reduce((s,v)=>s+v.w,0)||1; vecs.forEach(v=>v.w = v.w/sumW);
+  const mixture = vecs.reduce((a,v)=>({x:a.x+v.x*v.w,y:a.y+v.y*v.w,z:a.z+v.z*v.w}),{x:0,y:0,z:0});
+  const traces = [
+    { axis:"X" as const, formula:"z(M3 + M7 + clarity − M4 − M8)", inputs:{M3:mes.M3,M7:mes.M7,clarity:clar,M4:mes.M4,M8:mes.M8}, value:X },
+    { axis:"Y" as const, formula:"z(clarity + M9 − M11 − M10)", inputs:{clarity:clar,M9:mes.M9,M11:mes.M11,M10:mes.M10}, value:Y },
+    { axis:"Z" as const, formula:"z(C1 + C2 + C3 + C4 − tensionPenalty)", inputs:{C1:conatus.C1,C2:conatus.C2,C3:conatus.C3,C4:conatus.C4,tensionPenalty}, value:Z },
+  ];
+  const extVsInt = Math.abs(Number(mes.M4) - Number(mes.M5));
+  return { vectors: vecs, mixture, confidence, notes: extVsInt<0.2?"Clear locus":"Mixed internal/external locus; may split states.", traces };
+}
+
+function Axes(){ return (<axesHelper args={[1.2]} />); }
+function CubeBox(){ return (<mesh position={[0,0,0]}><boxGeometry args={[2,2,2]} /><meshBasicMaterial wireframe /></mesh>); }
+
+function YesNo({ value, onChange }:{ value:MESAnswer; onChange:(v:MESAnswer)=>void }){
+  return (
+    <div className="flex gap-2">
+      <button className={`px-2 py-1 rounded-2xl border ${value===1?"bg-black text-white":"bg-white"}`} onClick={()=>onChange(1)}>Yes</button>
+      <button className={`px-2 py-1 rounded-2xl border ${value===0?"bg-black text-white":"bg-white"}`} onClick={()=>onChange(0)}>No</button>
+    </div>
+  );
+}
+
+function Slider({ label, value, onChange }:{ label:string; value:number; onChange:(v:number)=>void }){
+  return (
+    <label className="flex items-center gap-3 w-full">
+      <span className="w-24 text-sm text-gray-600">{label}</span>
+      <input className="w-full" type="range" min={0} max={100} value={value} onChange={(e)=>onChange(Number(e.target.value))} />
+      <span className="w-10 text-right text-sm">{value}</span>
+    </label>
+  );
+}
+
+export default function AffectDiagnostic(){
+  const [narrative,setNarrative] = useState("");
+  const [mes,setMES] = useState<Inputs["mes"]>({ M1:0,M2:0,M3:0,M4:0,M5:0,M6:0,M7:0,M8:0,M9:0,M10:0,M11:0,M12:0 });
+  const [sliders,setSliders] = useState<Inputs["sliders"]>({ clarity:50, agency:50, tension:50, valence:50 });
+  const [conatus,setConatus] = useState<Inputs["conatus"]>({ C1:0, C2:0, C3:0, C4:0 });
+  const [snapshot,setSnapshot] = useState<Snapshot|null>(null);
+  const [abstain,setAbstain] = useState<string|null>(null);
+
+  const run=()=>{
+    const s = computeSnapshot({ narrative, mes, sliders, conatus });
+    if(s.confidence < 0.55){ setAbstain("Ambiguous: please rephrase once and set clarity slider to your best honest value."); setSnapshot(s);} else { setAbstain(null); setSnapshot(s);} };
+
+  return (
+    <div className="w-full grid grid-cols-1 lg:grid-cols-2 gap-6 p-6">
+      <div className="space-y-4">
+        <h1 className="text-2xl font-bold">SpiñO — Affect Diagnostic (v1)</h1>
+        <p className="text-sm text-gray-600">Answer minimally and honestly. Numbers shown are derived only from your inputs.</p>
+
+        <div className="space-y-2">
+          <label className="text-sm font-medium">Narrative-60</label>
+          <textarea className="w-full h-28 p-3 border rounded-xl" placeholder="Describe what you feel now and why…" value={narrative} onChange={(e)=>setNarrative(e.target.value)} />
+        </div>
+
+        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
+          {["M1","M2","M3","M4","M5","M6","M7","M8","M9","M10","M11","M12"].map((k)=> (
+            <div key={k} className="p-3 border rounded-xl flex items-center justify-between">
+              <span className="text-xs text-gray-700">{labelFor(k as keyof Inputs["mes"])}</span>
+              <YesNo value={mes[k as keyof Inputs["mes"]]} onChange={(v)=>setMES((s)=>({ ...s, [k]: v }))} />
+            </div>
+          ))}
+        </div>
+
+        <div className="space-y-2 p-3 border rounded-xl">
+          <Slider label="Clarity" value={sliders.clarity} onChange={(v)=>setSliders((s)=>({ ...s, clarity:v }))} />
+          <Slider label="Agency" value={sliders.agency} onChange={(v)=>setSliders((s)=>({ ...s, agency:v }))} />
+          <Slider label="Tension" value={sliders.tension} onChange={(v)=>setSliders((s)=>({ ...s, tension:v }))} />
+          <Slider label="Valence" value={sliders.valence} onChange={(v)=>setSliders((s)=>({ ...s, valence:v }))} />
+        </div>
+
+        <div className="grid grid-cols-2 gap-3">
+          {(["C1","C2","C3","C4"] as const).map((c)=> (
+            <div key={c} className="p-3 border rounded-xl flex items-center justify-between">
+              <span className="text-xs text-gray-700">{conatusLabel(c)}</span>
+              <YesNo value={conatus[c]} onChange={(v)=>setConatus((s)=>({ ...s, [c]: v }))} />
+            </div>
+          ))}
+        </div>
+
+        <div className="flex gap-3">
+          <button className="px-4 py-2 rounded-2xl bg-black text-white" onClick={run}>Diagnose</button>
+          {abstain && <span className="text-sm text-amber-700">{abstain}</span>}
+        </div>
+
+        {snapshot && (
+          <div className="p-3 border rounded-xl space-y-2">
+            <div className="text-sm font-medium">Mixture (X,Y,Z): <span className="font-mono">{snapshot.mixture.x.toFixed(2)}, {snapshot.mixture.y.toFixed(2)}, {snapshot.mixture.z.toFixed(2)}</span> · Confidence {Math.round(snapshot.confidence*100)}%</div>
+            <div className="text-xs text-gray-600">{snapshot.notes}</div>
+            <div className="text-sm">Vectors:</div>
+            <ul className="text-sm pl-4 list-disc">
+              {snapshot.vectors.map((v)=> (
+                <li key={v.label} className="font-mono">{v.label}: x={v.x.toFixed(2)} y={v.y.toFixed(2)} z={v.z.toFixed(2)} w={v.w.toFixed(2)}</li>
+              ))}
+            </ul>
+            <div className="text-sm">Proof Trace:</div>
+            <ul className="text-xs pl-4 list-disc">
+              {snapshot.traces.map((t,i)=> (
+                <li key={i}><b>{t.axis}</b> = {t.formula} · inputs {JSON.stringify(t.inputs)} → {t.value.toFixed(2)}</li>
+              ))}
+            </ul>
+          </div>
+        )}
+      </div>
+
+      <div className="h-[560px] border rounded-xl overflow-hidden">
+        <Canvas camera={{ position: [2.8, 2.2, 2.8], fov: 50 }}>
+          <ambientLight intensity={0.6} />
+          <pointLight position={[5,5,5]} />
+          <OrbitControls enablePan enableRotate enableZoom />
+          <Axes />
+          <CubeBox />
+          {snapshot && snapshot.vectors.map((v)=> (
+            <mesh key={v.label} position={[v.x/2, v.y/2, v.z/2]}>
+              <cylinderGeometry args={[0.01,0.01, Math.max(0.0001, Math.sqrt(v.x**2+v.y**2+v.z**2)), 8]} />
+              <meshBasicMaterial />
+            </mesh>
+          ))}
+          {snapshot && (
+            <mesh position={[snapshot.mixture.x/2, snapshot.mixture.y/2, snapshot.mixture.z/2]}>
+              <cylinderGeometry args={[0.03,0.03, Math.max(0.0001, Math.sqrt(snapshot.mixture.x**2 + snapshot.mixture.y**2 + snapshot.mixture.z**2)), 12]} />
+              <meshBasicMaterial />
+            </mesh>
+          )}
+        </Canvas>
+      </div>
+    </div>
+  );
+}
+
+function labelFor(k: keyof Inputs["mes"]) { const map: Record<keyof Inputs["mes"],string> = {
+  M1:"Cause is clear to me", M2:"I can name the cause", M3:"I can influence the cause", M4:"Object is external",
+  M5:"Object is internal (belief/habit)", M6:"10m action would improve state", M7:"I feel drawn to act", M8:"I feel pushed/compelled",
+  M9:"I can explain to a child", M10:"Multiple emotions at once", M11:"Uncertain which dominates", M12:"I can trade this feeling by perspective",
+}; return map[k]; }
+
+function conatusLabel(k: keyof Inputs["conatus"]) { const map: Record<keyof Inputs["conatus"],string> = {
+  C1:"Will actually try a 10m step now", C2:"Prefer hard step now (vs. ruminate)", C3:"Will act despite a small obstacle", C4:"Will act even if unseen by others",
+}; return map[k]; }
+
*** End Patch
*** Add File: app/diagnose/page.tsx
+import dynamic from "next/dynamic";
+
+const AffectDiagnostic = dynamic(() => import("@/components/AffectDiagnostic"), { ssr: false });
+
+export default function Page() {
+  return (
+    <main className="min-h-screen p-6">
+      <AffectDiagnostic />
+    </main>
+  );
+}
+
*** End Patch
***
