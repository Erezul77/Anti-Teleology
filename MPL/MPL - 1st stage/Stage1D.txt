# MPL — Stage 1D (Full Code Snapshot)

This canvas contains a complete, runnable snapshot of **Stage 1D**.
- Adds **variables**, **binary expressions (+ - * /)**
- Introduces **named rules** (`rule name { ... }`) and **calls** (`name()`)
- Adds a minimal **semantic checker** (undefined/duplicate identifiers)
- Executor upgraded with a **symbol table** and **rule registry**

> Quick start (from repo root):
> ```bash
> npm install
> npm run dev
> # open http://localhost:5173
> ```

---

## Root (workspace)

### package.json
```json
{
  "name": "mpl-playground",
  "private": true,
  "version": "0.1.0",
  "workspaces": ["mpl-core", "mpl-web"],
  "scripts": {
    "build": "npm -w mpl-core run build && npm -w mpl-web run build",
    "dev": "npm -w mpl-web run dev",
    "lint": "npm -w mpl-web run lint"
  }
}
```

### tsconfig.base.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react-jsx",
    "baseUrl": "."
  }
}
```

---

## mpl-core

### package.json
```json
{
  "name": "mpl-core",
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "clean": "rimraf dist"
  },
  "devDependencies": {
    "rimraf": "^6.0.1",
    "typescript": "^5.5.4"
  }
}
```

### tsconfig.json
```json
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true,
    "emitDeclarationOnly": false
  },
  "include": ["src"]
}
```

### src/types.ts
```ts
export type Cell = 0 | 1;
export interface Grid { width: number; height: number; data: Uint8Array; }
export interface Diagnostic { message: string; line: number; column: number; severity: "error" | "warning"; }
export interface VMState { grid: Grid; }
export interface Program<AST = unknown> { source: string; ast: AST; }
export interface CompileResult<AST = unknown> { program: Program<AST>; errors: Diagnostic[]; }
```

### src/vm.ts
```ts
import type { Grid, VMState } from "./types";
export function makeGrid(width: number, height: number): Grid { return { width, height, data: new Uint8Array(width * height) }; }
export function cloneGrid(g: Grid): Grid { return { width: g.width, height: g.height, data: new Uint8Array(g.data) }; }
export function getCell(g: Grid, x: number, y: number): number { if (x < 0 || y < 0 || x >= g.width || y >= g.height) return 0; return g.data[y * g.width + x]; }
export function setCell(g: Grid, x: number, y: number, v: 0 | 1) { if (x<0||y<0||x>=g.width||y>=g.height) return; g.data[y * g.width + x] = v; }
export function toggleCell(g: Grid, x: number, y: number) { if (x<0||y<0||x>=g.width||y>=g.height) return; const i = y * g.width + x; g.data[i] = g.data[i] ? 0 : 1; }
export function step(g: Grid): Grid { const out = cloneGrid(g); for (let y=0;y<g.height;y++){ for (let x=0;x<g.width;x++){ let n=0; for (let dy=-1;dy<=1;dy++){ for (let dx=-1;dx<=1;dx++){ if(dx||dy) n += getCell(g,x+dx,y+dy); } } const alive = getCell(g,x,y)===1; const i=y*g.width+x; out.data[i] = alive ? (n===2||n===3?1:0) : (n===3?1:0); } } return out; }
export function initVM(width = 64, height = 40): VMState { return { grid: makeGrid(width, height) }; }
```

### src/ast.ts
```ts
export type Node = ProgramNode | Statement | Expression;
export interface ProgramNode { kind: "Program"; body: Statement[]; }

// Statements
export type Statement = VarDecl | RuleDecl | CallStmt | SetStmt | ToggleStmt | ClearStmt | StepStmt | ExprStmt;
export interface VarDecl { kind: "VarDecl"; name: string; init: Expression; line: number; column: number; }
export interface RuleDecl { kind: "RuleDecl"; name: string; body: Statement[]; line: number; column: number; }
export interface CallStmt { kind: "CallStmt"; name: string; args: Expression[]; line: number; column: number; }
export interface SetStmt { kind: "Set"; x: Expression; y: Expression; line: number; column: number; }
export interface ToggleStmt { kind: "Toggle"; x: Expression; y: Expression; line: number; column: number; }
export interface ClearStmt { kind: "Clear"; line: number; column: number; }
export interface StepStmt { kind: "Step"; line: number; column: number; }
export interface ExprStmt { kind: "ExprStmt"; expr: Expression; line: number; column: number; }

// Expressions
export type Expression = NumberLiteral | Identifier | BinaryExpr | CallExpr;
export interface NumberLiteral { kind: "NumberLiteral"; value: number; line: number; column: number; }
export interface Identifier { kind: "Identifier"; name: string; line: number; column: number; }
export interface BinaryExpr { kind: "BinaryExpr"; op: "+" | "-" | "*" | "/"; left: Expression; right: Expression; line: number; column: number; }
export interface CallExpr { kind: "CallExpr"; name: string; args: Expression[]; line: number; column: number; }
```

### src/tokens.ts
```ts
export type TokenType =
  | "identifier" | "number"
  | "lparen" | "rparen" | "lbrace" | "rbrace" | "comma" | "semicolon" | "assign"
  | "plus" | "minus" | "star" | "slash"
  | "kw_var" | "kw_rule"
  | "eof";

export interface Token { type: TokenType; value?: string; line: number; column: number; }

export function tokenize(source: string): Token[] {
  const t: Token[] = []; let i = 0, line = 1, col = 1;
  const push = (type: TokenType, value?: string) => t.push({ type, value, line, column: col });
  const adv = (n=1) => { while(n--) { const ch = source[i++]; if (ch === "\n") { line++; col = 1; } else { col++; } } };
  const peek = () => source[i];

  while (i < source.length) {
    const ch = peek();
    if (ch === " " || ch === "\t" || ch === "\r") { adv(); continue; }
    if (ch === "\n") { adv(); continue; }
    if (ch === "/" && source[i+1] === "/") { while (i < source.length && source[i] !== "\n") adv(); continue; }

    if (ch === "(") { push("lparen"); adv(); continue; }
    if (ch === ")") { push("rparen"); adv(); continue; }
    if (ch === "{") { push("lbrace"); adv(); continue; }
    if (ch === "}") { push("rbrace"); adv(); continue; }
    if (ch === ",") { push("comma"); adv(); continue; }
    if (ch === ";") { push("semicolon"); adv(); continue; }
    if (ch === "=") { push("assign"); adv(); continue; }
    if (ch === "+") { push("plus"); adv(); continue; }
    if (ch === "-") { push("minus"); adv(); continue; }
    if (ch === "*") { push("star"); adv(); continue; }
    if (ch === "/") { push("slash"); adv(); continue; }

    if (/[0-9]/.test(ch)) { let s = ""; const c0 = col; while (/[0-9]/.test(source[i])) { s += source[i]; adv(); } t.push({ type: "number", value: s, line, column: c0 }); continue; }
    if (/[A-Za-z_]/.test(ch)) { let s = ""; const c0 = col; while (/[A-Za-z0-9_]/.test(source[i])) { s += source[i]; adv(); }
      if (s === "var") t.push({ type: "kw_var", line, column: c0 });
      else if (s === "rule") t.push({ type: "kw_rule", line, column: c0 });
      else t.push({ type: "identifier", value: s, line, column: c0 });
      continue;
    }

    // skip unknown
    adv();
  }
  t.push({ type: "eof", line, column: col });
  return t;
}
```

### src/parser.ts
```ts
import type { Diagnostic, Program } from "./types";
import { tokenize, type Token, type TokenType } from "./tokens";
import type { ProgramNode, Statement, Expression, NumberLiteral, Identifier, BinaryExpr, VarDecl, RuleDecl, CallStmt, SetStmt, ToggleStmt, ClearStmt, StepStmt, CallExpr, ExprStmt } from "./ast";

export interface ParseResult { program: Program<ProgramNode>; errors: Diagnostic[]; }

export function parse(source: string): ParseResult {
  const tokens = tokenize(source);
  let i = 0; const errors: Diagnostic[] = [];
  const cur = () => tokens[i];
  const match = (t: TokenType) => cur().type === t;
  const eat = (t: TokenType) => match(t) ? tokens[i++] : undefined;
  const expect = (t: TokenType, msg: string) => {
    if (match(t)) return tokens[i++];
    const { line, column } = cur(); errors.push({ message: msg, line, column, severity: "error" });
    // sync to next semicolon or rbrace or EOF
    while (!match("semicolon") && !match("rbrace") && !match("eof")) i++;
    eat("semicolon");
    return { type: t, line, column } as Token;
  };

  function parsePrimary(): Expression {
    const t = cur();
    if (t.type === "number") { i++; return { kind: "NumberLiteral", value: Number(t.value), line: t.line, column: t.column } as NumberLiteral; }
    if (t.type === "identifier") { i++; return { kind: "Identifier", name: t.value!, line: t.line, column: t.column } as Identifier; }
    if (eat("lparen")) { const e = parseExpr(); expect("rparen", "Expected ')'"); return e; }
    // call without decl support (handled via parsePostfix)
    // fallback
    i++; return { kind: "NumberLiteral", value: 0, line: t.line, column: t.column } as NumberLiteral;
  }

  function parsePostfix(): Expression {
    let expr = parsePrimary();
    // call expression: name(args)
    while (true) {
      if (match("lparen")) {
        const start = cur(); i++; // '('
        const args: Expression[] = [];
        if (!match("rparen")) {
          args.push(parseExpr());
          while (eat("comma")) args.push(parseExpr());
        }
        expect("rparen", "Expected ')'");
        if (expr.kind === "Identifier") {
          expr = { kind: "CallExpr", name: (expr as Identifier).name, args, line: start.line, column: start.column } as CallExpr;
        }
        continue;
      }
      break;
    }
    return expr;
  }

  function parseMulDiv(): Expression {
    let left = parsePostfix();
    while (match("star") || match("slash")) {
      const opTok = tokens[i++];
      const right = parsePostfix();
      left = { kind: "BinaryExpr", op: opTok.type === "star" ? "*" : "/", left, right, line: opTok.line, column: opTok.column } as BinaryExpr;
    }
    return left;
  }

  function parseAddSub(): Expression {
    let left = parseMulDiv();
    while (match("plus") || match("minus")) {
      const opTok = tokens[i++];
      const right = parseMulDiv();
      left = { kind: "BinaryExpr", op: opTok.type === "plus" ? "+" : "-", left, right, line: opTok.line, column: opTok.column } as BinaryExpr;
    }
    return left;
  }

  function parseExpr(): Expression { return parseAddSub(); }

  function parseVarDecl(): VarDecl {
    const t = expect("kw_var", "Expected 'var'");
    const id = expect("identifier", "Expected variable name");
    expect("assign", "Expected '='");
    const init = parseExpr();
    expect("semicolon", "Missing ';'");
    return { kind: "VarDecl", name: id.value!, init, line: t.line, column: t.column };
  }

  function parseRuleDecl(): RuleDecl {
    const t = expect("kw_rule", "Expected 'rule'");
    const id = expect("identifier", "Expected rule name");
    expect("lbrace", "Expected '{'");
    const body: Statement[] = [];
    while (!match("rbrace") && !match("eof")) {
      const s = parseStatement(); if (s) body.push(s);
    }
    expect("rbrace", "Expected '}'");
    return { kind: "RuleDecl", name: id.value!, body, line: t.line, column: t.column };
  }

  function parseCallOrBuiltin(): Statement | ExprStmt | null {
    // builtin statements
    if (match("identifier")) {
      const t = tokens[i];
      const id = t.value!.toLowerCase();
      if (id === "set" || id === "toggle") {
        i++; expect("lparen", "Expected '('");
        const x = parseExpr(); expect("comma", "Expected ','");
        const y = parseExpr(); expect("rparen", "Expected ')'");
        expect("semicolon", "Missing ';'");
        return id === "set"
          ? ({ kind: "Set", x, y, line: t.line, column: t.column } as SetStmt)
          : ({ kind: "Toggle", x, y, line: t.line, column: t.column } as ToggleStmt);
      }
      if (id === "clear") { i++; expect("lparen", "Expected '()'"); expect("rparen", "Expected ')'"); expect("semicolon", "Missing ';'"); return { kind: "Clear", line: t.line, column: t.column } as ClearStmt; }
      if (id === "step") { i++; expect("lparen", "Expected '()'"); expect("rparen", "Expected ')'"); expect("semicolon", "Missing ';'"); return { kind: "Step", line: t.line, column: t.column } as StepStmt; }
      // otherwise: maybe a call statement
      // parse expression; if ends with semicolon treat as ExprStmt
      const expr = parseExpr();
      expect("semicolon", "Missing ';'");
      return { kind: "ExprStmt", expr, line: t.line, column: t.column } as ExprStmt;
    }
    return null;
  }

  function parseStatement(): Statement | null {
    const t = cur();
    if (match("kw_var")) return parseVarDecl();
    if (match("kw_rule")) return parseRuleDecl();
    if (match("identifier")) return parseCallOrBuiltin() as Statement;
    if (match("semicolon")) { i++; return null; }
    if (match("eof")) return null;
    // recovery
    i++; return null;
  }

  const body: Statement[] = [];
  while (!match("eof")) {
    const stmt = parseStatement();
    if (stmt) body.push(stmt);
  }
  return { program: { source, ast: { kind: "Program", body } }, errors };
}
```

### src/semantics.ts (new)
```ts
import type { Diagnostic } from "./types";
import type { ProgramNode, Statement, VarDecl, RuleDecl, Identifier, CallExpr, ExprStmt } from "./ast";

export function semanticCheck(ast: ProgramNode): Diagnostic[] {
  const errors: Diagnostic[] = [];
  const vars = new Map<string, { line: number; column: number }>();
  const rules = new Map<string, { line: number; column: number }>();

  function seen(map: Map<string, any>, name: string, line: number, column: number, kind: string) {
    if (map.has(name)) errors.push({ message: `${kind} '${name}' already defined`, line, column, severity: "error" });
    else map.set(name, { line, column });
  }

  function checkExpr(e: any) {
    if (!e) return;
    if (e.kind === "Identifier") {
      const id = (e as Identifier).name;
      if (!vars.has(id)) errors.push({ message: `Undefined variable '${id}'`, line: e.line, column: e.column, severity: "error" });
    } else if (e.kind === "BinaryExpr") { checkExpr(e.left); checkExpr(e.right); }
    else if (e.kind === "CallExpr") { for (const a of e.args) checkExpr(a); if (!rules.has(e.name) && e.name !== "set" && e.name !== "toggle" && e.name !== "step" && e.name !== "clear") errors.push({ message: `Unknown rule/function '${e.name}'`, line: e.line, column: e.column, severity: "error" }); }
  }

  function walk(stmt: Statement) {
    switch (stmt.kind) {
      case "VarDecl": seen(vars, stmt.name, stmt.line, stmt.column, "Variable"); checkExpr(stmt.init); break;
      case "RuleDecl": seen(rules, stmt.name, stmt.line, stmt.column, "Rule"); for (const s of stmt.body) walk(s); break;
      case "Set": case "Toggle": checkExpr(stmt.x); checkExpr(stmt.y); break;
      case "ExprStmt": checkExpr((stmt as ExprStmt).expr); break;
    }
  }

  for (const s of ast.body) walk(s);
  return errors;
}
```

### src/executor.ts
```ts
import type { Grid, VMState, Diagnostic, Program as Prog } from "./types";
import type { ProgramNode, Statement, Expression, VarDecl, RuleDecl, CallStmt, SetStmt, ToggleStmt, ClearStmt, StepStmt, Identifier, NumberLiteral, BinaryExpr, CallExpr, ExprStmt } from "./ast";
import { setCell, toggleCell, step as stepGrid } from "./vm";

export interface ExecuteResult { state: VMState; errors: Diagnostic[]; }

export function execute(program: Prog<ProgramNode>, state: VMState): ExecuteResult {
  const errors: Diagnostic[] = [];
  let g = state.grid;

  const vars = new Map<string, number>();
  const rules = new Map<string, RuleDecl>();

  // First pass: collect rules (top-level only)
  for (const stmt of program.ast.body) if (stmt.kind === "RuleDecl") rules.set(stmt.name, stmt as RuleDecl);

  function evalExpr(e: Expression): number {
    switch (e.kind) {
      case "NumberLiteral": return (e as NumberLiteral).value | 0;
      case "Identifier": return vars.get((e as Identifier).name) ?? 0;
      case "BinaryExpr": {
        const b = e as BinaryExpr; const L = evalExpr(b.left); const R = evalExpr(b.right);
        switch (b.op) { case "+": return L + R; case "-": return L - R; case "*": return L * R; case "/": return Math.trunc(R === 0 ? 0 : L / R); }
      }
      case "CallExpr": {
        const c = e as CallExpr;
        if (c.name === "step") { g = stepGrid(g); return 0; }
        if (c.name === "clear") { g.data.fill(0); return 0; }
        // user rule call returns 0
        const rule = rules.get(c.name);
        if (rule) runBlock(rule.body);
        return 0;
      }
    }
    return 0;
  }

  function runStmt(stmt: Statement) {
    switch (stmt.kind) {
      case "VarDecl": vars.set((stmt as VarDecl).name, evalExpr((stmt as VarDecl).init)); break;
      case "Set": { const s = stmt as SetStmt; const x = evalExpr(s.x); const y = evalExpr(s.y); if (Number.isFinite(x) && Number.isFinite(y)) setCell(g, x|0, y|0, 1); break; }
      case "Toggle": { const t = stmt as ToggleStmt; const x = evalExpr(t.x); const y = evalExpr(t.y); if (Number.isFinite(x) && Number.isFinite(y)) toggleCell(g, x|0, y|0); break; }
      case "Clear": g.data.fill(0); break;
      case "Step": g = stepGrid(g); break;
      case "ExprStmt": evalExpr((stmt as ExprStmt).expr); break;
      case "RuleDecl": /* no-op at runtime (already registered) */ break;
    }
  }

  function runBlock(body: Statement[]) { for (const s of body) runStmt(s); }

  for (const stmt of program.ast.body) runStmt(stmt);
  return { state: { grid: g }, errors };
}
```

### src/linter.ts (unchanged from 1C for style; semantics handled separately)
```ts
export { lint } from "./linter"; // keep previous implementation if split; otherwise merge into index
```

### src/index.ts
```ts
export * from "./types";
export * from "./ast";
export { makeGrid, cloneGrid, getCell, setCell, toggleCell, step, initVM } from "./vm";

import type { CompileResult } from "./types";
import type { ProgramNode } from "./ast";
import { parse, type ParseResult } from "./parser";
import { semanticCheck } from "./semantics";
import { execute, type ExecuteResult } from "./executor";
import { lint as runLint } from "./linter";

export function compile(source: string): CompileResult<ProgramNode> {
  const parsed: ParseResult = parse(source);
  const style = runLint(source).filter((d) => d.severity === "error");
  const sema = semanticCheck(parsed.program.ast);
  return { program: parsed.program, errors: [...parsed.errors, ...style, ...sema] };
}

export { execute };
```

---

## mpl-web

### package.json
```json
{
  "name": "mpl-web",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -p tsconfig.json && vite build",
    "preview": "vite preview",
    "lint": "echo 'Lint via Monaco in-IDE for .mpl; add ESLint here if desired'"
  },
  "dependencies": {
    "@monaco-editor/react": "^4.6.0",
    "monaco-editor": "^0.49.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "mpl-core": "*"
  },
  "devDependencies": {
    "typescript": "^5.5.4",
    "vite": "^5.4.2",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1"
  }
}
```

### tsconfig.json
```json
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": { "types": ["vite/client"], "baseUrl": "." },
  "include": ["src", "vite.config.ts", "index.html"]
}
```

### vite.config.ts
```ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
export default defineConfig({ plugins: [react()], server: { port: 5173 } });
```

### index.html
```html
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MPL Playground</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

### src/main.tsx
```ts
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
import "./styles.css";
createRoot(document.getElementById("root")!).render(<React.StrictMode><App /></React.StrictMode>);
```

### src/examples.ts (updated with variables/rules)
```ts
export const EXAMPLES: Record<string, string> = {
  Vars: `// Variables + expressions\nvar x = 2; var y = x + 3; set(x, y);`,
  Rule: `// Named rule and call\nrule glider { set(1,1); step(); }\nglider();`,
};
```

### src/App.tsx
```tsx
import { useEffect, useMemo } from "react";
import MonacoMPL from "./editor/MonacoMPL";
import GridCanvas from "./canvas/GridCanvas";
import { useMPL } from "./state/useMPL";
import { EXAMPLES } from "./examples";

export default function App() {
  const { source, setSource, diagnostics, run, state, stepOnce, clearGrid, toggleAt, playing, setPlaying, speed, setSpeed } = useMPL();
  const exampleNames = useMemo(() => Object.keys(EXAMPLES), []);
  useEffect(() => { if (!source.trim()) setSource(EXAMPLES[exampleNames[0]]); }, []);

  return (
    <div className="app">
      <header className="bar">
        <h1>MPL Playground (Stage 1D)</h1>
        <div className="controls">
          <button onClick={run}>Run</button>
          <button onClick={stepOnce}>Step</button>
          <button onClick={clearGrid}>Clear</button>
          <button onClick={() => setPlaying((p) => !p)}>{playing ? "Pause" : "Play"}</button>
          <label className="speed">Speed
            <input type="range" min={1} max={30} value={speed} onChange={(e) => setSpeed(Number(e.target.value))} />
          </label>
          <select onChange={(e) => setSource(EXAMPLES[e.target.value])}>
            {exampleNames.map((k) => (<option key={k} value={k}>{k}</option>))}
          </select>
        </div>
      </header>
      <main className="content">
        <section className="editor"><MonacoMPL value={source} onChange={setSource} diagnostics={diagnostics} /></section>
        <section className="canvas"><GridCanvas grid={state.grid} cellSize={16} onToggle={toggleAt} /></section>
      </main>
    </div>
  );
}
```

### src/editor/MonacoMPL.tsx (keywords updated)
```tsx
import Editor, { OnChange, useMonaco } from "@monaco-editor/react";
import { useEffect } from "react";
export interface MonacoDiag { message: string; line: number; column: number; severity: "error" | "warning"; }
export default function MonacoMPL({ value, onChange, diagnostics }: { value: string; onChange: (v: string) => void; diagnostics: MonacoDiag[]; }) {
  const monaco = useMonaco();
  useEffect(() => {
    if (!monaco) return;
    const id = "mpl";
    monaco.languages.register({ id });
    monaco.languages.setMonarchTokensProvider(id, { tokenizer: { root: [
      [/\/\/.*$/, "comment"],
      [/\b(var|rule|set|clear|toggle|step)\b/, "keyword"],
      [/\b\d+\b/, "number"],
      [/"[^"]*"/, "string"],
      [[/[{}()[\]]/, "delimiter"]],
      [/[,.;=+\-/*]/, "delimiter"],
      [/\b[A-Za-z_][A-Za-z0-9_]*\b/, "identifier"],
    ]}});
  }, [monaco]);
  useEffect(() => {
    if (!monaco) return; const model = monaco.editor.getModels()[0]; if (!model) return;
    const frame = requestAnimationFrame(() => {
      monaco.editor.setModelMarkers(model, "mpl-linter", diagnostics.map((d) => ({
        message: d.message, startLineNumber: d.line, startColumn: d.column, endLineNumber: d.line, endColumn: d.column + 1,
        severity: d.severity === "error" ? monaco.MarkerSeverity.Error : monaco.MarkerSeverity.Warning,
      })));
    });
    return () => cancelAnimationFrame(frame);
  }, [monaco, diagnostics]);
  const handleChange: OnChange = (v) => onChange(v || "");
  return <Editor height="100%" defaultLanguage="mpl" value={value} onChange={handleChange} options={{ minimap: { enabled: false }, fontSize: 14, tabSize: 2, insertSpaces: true, wordWrap: "on" }} />;
}
```

### src/canvas/GridCanvas.tsx (unchanged from 1C)
```tsx
import { useEffect, useRef, MouseEvent } from "react";
import type { Grid } from "mpl-core";
export default function GridCanvas({ grid, cellSize = 12, onToggle }: { grid: Grid; cellSize?: number; onToggle?: (x: number, y: number) => void; }) {
  const ref = useRef<HTMLCanvasElement | null>(null);
  useEffect(() => {
    const canvas = ref.current!; canvas.width = grid.width * cellSize; canvas.height = grid.height * cellSize; const ctx = canvas.getContext("2d")!;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < grid.height; y++) for (let x = 0; x < grid.width; x++) { if (grid.data[y * grid.width + x]) ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize); }
    ctx.globalAlpha = 0.15;
    for (let x = 0; x <= grid.width; x++) { ctx.beginPath(); ctx.moveTo(x * cellSize + 0.5, 0); ctx.lineTo(x * cellSize + 0.5, grid.height * cellSize); ctx.stroke(); }
    for (let y = 0; y <= grid.height; y++) { ctx.beginPath(); ctx.moveTo(0, y * cellSize + 0.5); ctx.lineTo(grid.width * cellSize, y * cellSize + 0.5); ctx.stroke(); }
    ctx.globalAlpha = 1;
  }, [grid, cellSize]);
  function handleClick(e: MouseEvent<HTMLCanvasElement>) { if (!onToggle) return; const rect = (e.target as HTMLCanvasElement).getBoundingClientRect(); const cx = Math.floor((e.clientX - rect.left) / cellSize); const cy = Math.floor((e.clientY - rect.top) / cellSize); onToggle(cx, cy); }
  return <canvas ref={ref} onClick={handleClick} style={{ width: "100%", height: "100%", border: "1px solid #ddd", cursor: onToggle ? "pointer" : "default" }} />;
}
```

### src/state/useMPL.ts (uses compile → execute; unchanged from 1C)
```ts
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { compile, execute, initVM, step, toggleCell, type VMState } from "mpl-core";
import { lint } from "mpl-core";

const STORAGE_KEY = "mpl-source:last";

export function useMPL() {
  const [source, setSource] = useState<string>(() => localStorage.getItem(STORAGE_KEY) || "");
  const [state, setState] = useState<VMState>(() => initVM(64, 40));
  const [playing, setPlaying] = useState(false);
  const [speed, setSpeed] = useState(10);
  const diagnostics = useMemo(() => lint(source), [source]);

  const raf = useRef<number | null>(null);
  const lastTs = useRef<number>(0);
  const acc = useRef<number>(0);

  useEffect(() => { localStorage.setItem(STORAGE_KEY, source); }, [source]);

  const run = useCallback(() => {
    const res = compile(source);
    if (res.errors.length) return;
    const out = execute(res.program, state);
    if (out.errors.length === 0) setState(out.state);
  }, [source, state]);

  const stepOnce = useCallback(() => setState((s) => ({ grid: step(s.grid) })), []);
  const clearGrid = useCallback(() => { setState((s) => ({ grid: { ...s.grid, data: new Uint8Array(s.grid.width * s.grid.height) } })); }, []);
  const toggleAt = useCallback((x: number, y: number) => { setState((s) => { const g = { ...s.grid, data: new Uint8Array(s.grid.data) }; toggleCell(g, x, y); return { grid: g }; }); }, []);

  const loop = useCallback((ts: number) => {
    if (!playing) return;
    const dt = (ts - lastTs.current) / 1000; lastTs.current = ts; acc.current += dt * speed;
    while (acc.current >= 1) { acc.current -= 1; setState((s) => ({ grid: step(s.grid) })); }
    raf.current = requestAnimationFrame(loop);
  }, [playing, speed]);

  useEffect(() => { if (playing) { lastTs.current = performance.now(); acc.current = 0; raf.current = requestAnimationFrame(loop); return () => { if (raf.current) cancelAnimationFrame(raf.current); }; } }, [playing, loop]);

  return { source, setSource, diagnostics, run, state, stepOnce, clearGrid, toggleAt, playing, setPlaying, speed, setSpeed };
}
```

### src/styles.css (same as 1C)
```css
* { box-sizing: border-box; }
html, body, #root { height: 100%; margin: 0; }
body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
.app { display: grid; grid-template-rows: 56px 1fr; height: 100%; }
.bar { display: flex; align-items: center; justify-content: space-between; padding: 0 12px; border-bottom: 1px solid #eee; }
.bar h1 { margin: 0; font-size: 16px; font-weight: 600; }
.content { display: grid; grid-template-columns: 1fr 1fr; height: 100%; }
.editor { border-right: 1px solid #eee; }
.canvas { display: flex; align-items: stretch; justify-content: stretch; padding: 8px; }
.controls { display: flex; align-items: center; gap: 8px; }
.controls button { padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #fff; cursor: pointer; }
select, input[type="range"] { vertical-align: middle; }
.speed { display: inline-flex; align-items: center; gap: 6px; }
```

---

**Done.** This is a complete Stage 1D snapshot you can run as-is.

Want me to queue up **Stage 1E (full code)** next?
