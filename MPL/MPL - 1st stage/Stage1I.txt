# MPL — Stage 1I (Full Code Snapshot)

This canvas contains a complete, runnable snapshot of **Stage 1I**.
- Adds **strings** (double‑quoted)
- Adds built‑ins: **`print(x)`** and **`len(x)`**
- `+` now **concatenates** if either operand is a string
- Executor returns a **log buffer** of printed lines so the IDE can show output

> Quick start (from repo root):
> ```bash
> npm install
> npm run dev
> # open http://localhost:5173
> ```

---

## Root (workspace)

### package.json
```json
{
  "name": "mpl-playground",
  "private": true,
  "version": "0.1.0",
  "workspaces": ["mpl-core", "mpl-web"],
  "scripts": {
    "build": "npm -w mpl-core run build && npm -w mpl-web run build",
    "dev": "npm -w mpl-web run dev",
    "lint": "npm -w mpl-web run lint"
  }
}
```

### tsconfig.base.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react-jsx",
    "baseUrl": "."
  }
}
```

---

## mpl-core

### package.json
```json
{
  "name": "mpl-core",
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "clean": "rimraf dist"
  },
  "devDependencies": {
    "rimraf": "^6.0.1",
    "typescript": "^5.5.4"
  }
}
```

### tsconfig.json
```json
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true,
    "emitDeclarationOnly": false
  },
  "include": ["src"]
}
```

### src/types.ts
```ts
export type Cell = 0 | 1;
export interface Grid { width: number; height: number; data: Uint8Array; }
export interface Diagnostic { message: string; line: number; column: number; severity: "error" | "warning"; }
export interface VMState { grid: Grid; }
export interface Program<AST = unknown> { source: string; ast: AST; }
export interface CompileResult<AST = unknown> { program: Program<AST>; errors: Diagnostic[]; }

// Stage 1I value type used by executor
export type Value = number | string | Value[] | Map<string, Value>;
```

### src/vm.ts
```ts
import type { Grid, VMState } from "./types";
export function makeGrid(width: number, height: number): Grid { return { width, height, data: new Uint8Array(width * height) }; }
export function cloneGrid(g: Grid): Grid { return { width: g.width, height: g.height, data: new Uint8Array(g.data) }; }
export function getCell(g: Grid, x: number, y: number): number { if (x < 0 || y < 0 || x >= g.width || y >= g.height) return 0; return g.data[y * g.width + x]; }
export function setCell(g: Grid, x: number, y: number, v: 0 | 1) { if (x<0||y<0||x>=g.width||y>=g.height) return; g.data[y * g.width + x] = v; }
export function toggleCell(g: Grid, x: number, y: number) { if (x<0||y<0||x>=g.width||y>=g.height) return; const i = y * g.width + x; g.data[i] = g.data[i] ? 0 : 1; }
export function step(g: Grid): Grid { const out = cloneGrid(g); for (let y=0;y<g.height;y++){ for (let x=0;x<g.width;x++){ let n=0; for (let dy=-1;dy<=1;dy++){ for (let dx=-1;dx<=1;dx++){ if(dx||dy) n += getCell(g,x+dx,y+dy); } } const alive = getCell(g,x,y)===1; const i=y*g.width+x; out.data[i] = alive ? (n===2||n===3?1:0) : (n===3?1:0); } } return out; }
export function initVM(width = 64, height = 40): VMState { return { grid: makeGrid(width, height) }; }
```

### src/ast.ts
```ts
export type Node = ProgramNode | Statement | Expression;
export interface ProgramNode { kind: "Program"; body: Statement[]; }

// Statements
export type Statement =
  VarDecl | RuleDecl | FunctionDecl | ReturnStmt | CallStmt | SetStmt | ToggleStmt | ClearStmt | StepStmt | ExprStmt |
  IfStmt | WhileStmt | ForStmt | ForOfStmt | ForInStmt | BlockStmt;

export interface VarDecl { kind: "VarDecl"; name: string; init: Expression; line: number; column: number; }
export interface RuleDecl { kind: "RuleDecl"; name: string; body: Statement[]; line: number; column: number; }
export interface FunctionDecl { kind: "FunctionDecl"; name: string; params: string[]; body: Statement[]; line: number; column: number; }
export interface ReturnStmt { kind: "Return"; value?: Expression | null; line: number; column: number; }
export interface CallStmt { kind: "CallStmt"; name: string; args: Expression[]; line: number; column: number; }
export interface SetStmt { kind: "Set"; x: Expression; y: Expression; line: number; column: number; }
export interface ToggleStmt { kind: "Toggle"; x: Expression; y: Expression; line: number; column: number; }
export interface ClearStmt { kind: "Clear"; line: number; column: number; }
export interface StepStmt { kind: "Step"; line: number; column: number; }
export interface ExprStmt { kind: "ExprStmt"; expr: Expression; line: number; column: number; }

export interface IfStmt { kind: "If"; test: Expression; then: BlockStmt; otherwise?: BlockStmt; line: number; column: number; }
export interface WhileStmt { kind: "While"; test: Expression; body: BlockStmt; line: number; column: number; }
export interface ForStmt { kind: "For"; init?: Statement | null; test?: Expression | null; post?: Statement | null; body: BlockStmt; line: number; column: number; }
export interface ForOfStmt { kind: "ForOf"; varName: string; iterable: Expression; body: BlockStmt; line: number; column: number; }
export interface ForInStmt { kind: "ForIn"; varName: string; object: Expression; body: BlockStmt; line: number; column: number; }
export interface BlockStmt { kind: "Block"; body: Statement[]; line: number; column: number; }

// Expressions
export type Expression = NumberLiteral | StringLiteral | Identifier | BinaryExpr | CallExpr | ParenExpr | ArrayLiteral | IndexExpr | ObjectLiteral;
export interface NumberLiteral { kind: "NumberLiteral"; value: number; line: number; column: number; }
export interface StringLiteral { kind: "StringLiteral"; value: string; line: number; column: number; }
export interface Identifier { kind: "Identifier"; name: string; line: number; column: number; }
export interface BinaryExpr { kind: "BinaryExpr"; op: "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "<" | ">" | "<=" | ">="; left: Expression; right: Expression; line: number; column: number; }
export interface CallExpr { kind: "CallExpr"; name: string; args: Expression[]; line: number; column: number; }
export interface ParenExpr { kind: "ParenExpr"; expr: Expression; line: number; column: number; }
export interface ArrayLiteral { kind: "ArrayLiteral"; elements: Expression[]; line: number; column: number; }
export interface IndexExpr { kind: "IndexExpr"; target: Expression; index: Expression; line: number; column: number; }
export interface ObjectLiteral { kind: "ObjectLiteral"; entries: { key: string; value: Expression }[]; line: number; column: number; }
```

### src/tokens.ts
```ts
export type TokenType =
  | "identifier" | "number" | "string"
  | "lparen" | "rparen" | "lbrace" | "rbrace" | "lbracket" | "rbracket" | "comma" | "semicolon" | "assign" | "colon"
  | "plus" | "minus" | "star" | "slash" | "percent"
  | "eq" | "neq" | "lt" | "gt" | "lte" | "gte"
  | "kw_var" | "kw_rule" | "kw_if" | "kw_else" | "kw_while" | "kw_for" | "kw_function" | "kw_return" | "kw_of" | "kw_in"
  | "eof";

export interface Token { type: TokenType; value?: string; line: number; column: number; }

export function tokenize(source: string): Token[] {
  const t: Token[] = []; let i = 0, line = 1, col = 1;
  const push = (type: TokenType, value?: string) => t.push({ type, value, line, column: col });
  const adv = (n=1) => { while(n--) { const ch = source[i++]; if (ch === "\n") { line++; col = 1; } else { col++; } } };
  const peek = () => source[i];
  const peek2 = () => source[i+1];

  while (i < source.length) {
    const ch = peek();
    if (ch === " " || ch === "\t" || ch === "\r") { adv(); continue; }
    if (ch === "\n") { adv(); continue; }
    if (ch === "/" && peek2() === "/") { while (i < source.length && peek() !== "\n") adv(); continue; }

    if (ch === '"') { // simple double-quoted strings without escapes
      const c0 = col; adv(); let s = "";
      while (i < source.length && peek() !== '"') { s += peek(); adv(); }
      if (peek() === '"') adv();
      t.push({ type: "string", value: s, line, column: c0 });
      continue;
    }

    if (ch === "(") { push("lparen"); adv(); continue; }
    if (ch === ")") { push("rparen"); adv(); continue; }
    if (ch === "{") { push("lbrace"); adv(); continue; }
    if (ch === "}") { push("rbrace"); adv(); continue; }
    if (ch === "[") { push("lbracket"); adv(); continue; }
    if (ch === "]") { push("rbracket"); adv(); continue; }
    if (ch === ",") { push("comma"); adv(); continue; }
    if (ch === ";") { push("semicolon"); adv(); continue; }
    if (ch === ":") { push("colon"); adv(); continue; }
    if (ch === "=") { if (peek2() === "=") { adv(2); push("eq"); } else { adv(); push("assign"); } continue; }
    if (ch === "!") { if (peek2() === "=") { adv(2); push("neq"); } else { adv(); } continue; }
    if (ch === "+") { push("plus"); adv(); continue; }
    if (ch === "-") { push("minus"); adv(); continue; }
    if (ch === "*") { push("star"); adv(); continue; }
    if (ch === "/") { push("slash"); adv(); continue; }
    if (ch === "%") { push("percent"); adv(); continue; }
    if (ch === "<") { if (peek2() === "=") { adv(2); push("lte"); } else { adv(); push("lt"); } continue; }
    if (ch === ">") { if (peek2() === "=") { adv(2); push("gte"); } else { adv(); push("gt"); } continue; }

    if (/[0-9]/.test(ch)) { let s = ""; const c0 = col; while (/[0-9]/.test(peek())) { s += peek(); adv(); } t.push({ type: "number", value: s, line, column: c0 }); continue; }
    if (/[A-Za-z_]/.test(ch)) { let s = ""; const c0 = col; while (/[A-Za-z0-9_]/.test(peek())) { s += peek(); adv(); }
      if (s === "var") t.push({ type: "kw_var", line, column: c0 });
      else if (s === "rule") t.push({ type: "kw_rule", line, column: c0 });
      else if (s === "if") t.push({ type: "kw_if", line, column: c0 });
      else if (s === "else") t.push({ type: "kw_else", line, column: c0 });
      else if (s === "while") t.push({ type: "kw_while", line, column: c0 });
      else if (s === "for") t.push({ type: "kw_for", line, column: c0 });
      else if (s === "function") t.push({ type: "kw_function", line, column: c0 });
      else if (s === "return") t.push({ type: "kw_return", line, column: c0 });
      else if (s === "of") t.push({ type: "kw_of", line, column: c0 });
      else if (s === "in") t.push({ type: "kw_in", line, column: c0 });
      else t.push({ type: "identifier", value: s, line, column: c0 });
      continue;
    }

    adv();
  }
  t.push({ type: "eof", line, column: col });
  return t;
}
```

### src/parser.ts
```ts
import type { Diagnostic, Program } from "./types";
import { tokenize, type Token, type TokenType } from "./tokens";
import type { ProgramNode, Statement, Expression, NumberLiteral, StringLiteral, Identifier, BinaryExpr, VarDecl, RuleDecl, FunctionDecl, ReturnStmt, CallStmt, SetStmt, ToggleStmt, ClearStmt, StepStmt, CallExpr, ExprStmt, IfStmt, WhileStmt, ForStmt, ForOfStmt, ForInStmt, BlockStmt, ParenExpr, ArrayLiteral, IndexExpr, ObjectLiteral } from "./ast";

export interface ParseResult { program: Program<ProgramNode>; errors: Diagnostic[]; }

export function parse(source: string): ParseResult {
  const tokens = tokenize(source);
  let i = 0; const errors: Diagnostic[] = [];
  const cur = () => tokens[i];
  const match = (t: TokenType) => cur().type === t;
  const eat = (t: TokenType) => match(t) ? tokens[i++] : undefined;
  const expect = (t: TokenType, msg: string) => {
    if (match(t)) return tokens[i++];
    const { line, column } = cur(); errors.push({ message: msg, line, column, severity: "error" });
    while (!match("semicolon") && !match("rbrace") && !match("eof") && !match("rparen")) i++;
    eat("semicolon");
    return { type: t, line, column } as Token;
  };

  function parsePrimary(): Expression {
    const t = cur();
    if (t.type === "number") { i++; return { kind: "NumberLiteral", value: Number(t.value), line: t.line, column: t.column } as NumberLiteral; }
    if (t.type === "string") { i++; return { kind: "StringLiteral", value: String(t.value ?? ""), line: t.line, column: t.column } as StringLiteral; }
    if (t.type === "identifier") { i++; return { kind: "Identifier", name: t.value!, line: t.line, column: t.column } as Identifier; }
    if (eat("lparen")) { const start = tokens[i-1]; const e = parseExpr(); expect("rparen", "Expected ')'"); return { kind: "ParenExpr", expr: e, line: start.line, column: start.column } as ParenExpr; }
    if (eat("lbracket")) { const start = tokens[i-1]; const elements: Expression[] = []; if (!match("rbracket")) { elements.push(parseExpr()); while (eat("comma")) elements.push(parseExpr()); } expect("rbracket", "Expected ']' "); return { kind: "ArrayLiteral", elements, line: start.line, column: start.column } as ArrayLiteral; }
    if (eat("lbrace")) {
      const start = tokens[i-1];
      const entries: { key: string; value: Expression }[] = [];
      if (!match("rbrace")) {
        do {
          const k = expect("identifier", "Expected key identifier in object literal");
          expect("colon", "Expected ':' after key");
          const v = parseExpr();
          entries.push({ key: k.value!, value: v });
        } while (eat("comma"));
      }
      expect("rbrace", "Expected '}'");
      return { kind: "ObjectLiteral", entries, line: start.line, column: start.column } as ObjectLiteral;
    }
    i++; return { kind: "NumberLiteral", value: 0, line: t.line, column: t.column } as NumberLiteral;
  }

  function parsePostfix(): Expression {
    let expr = parsePrimary();
    while (true) {
      if (match("lparen")) {
        const start = cur(); i++;
        const args: Expression[] = [];
        if (!match("rparen")) { args.push(parseExpr()); while (eat("comma")) args.push(parseExpr()); }
        expect("rparen", "Expected ')'");
        if (expr.kind === "Identifier") expr = { kind: "CallExpr", name: (expr as Identifier).name, args, line: start.line, column: start.column } as CallExpr;
        continue;
      }
      if (match("lbracket")) {
        const lb = cur(); i++; const index = parseExpr(); expect("rbracket", "Expected ']' ");
        expr = { kind: "IndexExpr", target: expr, index, line: lb.line, column: lb.column } as IndexExpr; continue;
      }
      break;
    }
    return expr;
  }

  function parseMulDivMod(): Expression {
    let left = parsePostfix();
    while (match("star") || match("slash") || match("percent")) {
      const opTok = tokens[i++];
      const right = parsePostfix();
      const op = opTok.type === "star" ? "*" : opTok.type === "slash" ? "/" : "%";
      left = { kind: "BinaryExpr", op, left, right, line: opTok.line, column: opTok.column } as BinaryExpr;
    }
    return left;
  }

  function parseAddSub(): Expression {
    let left = parseMulDivMod();
    while (match("plus") || match("minus")) {
      const opTok = tokens[i++];
      const right = parseMulDivMod();
      left = { kind: "BinaryExpr", op: opTok.type === "plus" ? "+" : "-", left, right, line: opTok.line, column: opTok.column } as BinaryExpr;
    }
    return left;
  }

  function parseCompare(): Expression {
    let left = parseAddSub();
    while (match("eq") || match("neq") || match("lt") || match("gt") || match("lte") || match("gte")) {
      const opTok = tokens[i++];
      const right = parseAddSub();
      const map: Record<string, any> = { eq: "==", neq: "!=", lt: "<", gt: ">", lte: "<=", gte: ">=" };
      left = { kind: "BinaryExpr", op: map[opTok.type], left, right, line: opTok.line, column: opTok.column } as BinaryExpr;
    }
    return left;
  }

  function parseExpr(): Expression { return parseCompare(); }

  function parseVarDecl(): VarDecl { const t = expect("kw_var", "Expected 'var'"); const id = expect("identifier", "Expected variable name"); expect("assign", "Expected '='"); const init = parseExpr(); expect("semicolon", "Missing ';'"); return { kind: "VarDecl", name: id.value!, init, line: t.line, column: t.column }; }

  function parseBlock(): BlockStmt { const l = expect("lbrace", "Expected '{'"); const body: Statement[] = []; while (!match("rbrace") && !match("eof")) { const st = parseStatement(); if (st) body.push(st); } const r = expect("rbrace", "Expected '}'"); return { kind: "Block", body, line: l.line, column: l.column }; }

  function parseIf(): IfStmt { const t = expect("kw_if", "Expected 'if'"); const test = parseParenOrExpr(); const then = parseBlock(); let otherwise: BlockStmt | undefined; if (eat("kw_else")) otherwise = parseBlock(); return { kind: "If", test, then, otherwise, line: t.line, column: t.column }; }

  function parseWhile(): WhileStmt { const t = expect("kw_while", "Expected 'while'"); const test = parseParenOrExpr(); const body = parseBlock(); return { kind: "While", test, body, line: t.line, column: t.column }; }

  function parseFor(): ForStmt | ForOfStmt | ForInStmt {
    const t = expect("kw_for", "Expected 'for'");
    expect("lparen", "Expected '('");

    // Lookahead for for-of / for-in: var IDENT of|in ...
    if (match("kw_var")) {
      const save = i; i++; // kw_var
      if (match("identifier")) {
        const nameTok = tokens[i++];
        if (match("kw_of")) { i++; const iterable = parseExpr(); expect("rparen", "Expected ')'"); const body = parseBlock(); return { kind: "ForOf", varName: nameTok.value!, iterable, body, line: t.line, column: t.column } as ForOfStmt; }
        if (match("kw_in")) { i++; const object = parseExpr(); expect("rparen", "Expected ')'"); const body = parseBlock(); return { kind: "ForIn", varName: nameTok.value!, object, body, line: t.line, column: t.column } as ForInStmt; }
      }
      i = save; // not of/in; rewind
    }

    // classic for(init; test; post)
    let init: Statement | null = null;
    if (!match("semicolon")) init = parseStatement(); else expect("semicolon", "Expected ';'");
    let test: Expression | null = null;
    if (!match("semicolon")) test = parseExpr();
    expect("semicolon", "Expected ';'");
    let post: Statement | null = null;
    if (!match("rparen")) post = parseStatement();
    expect("rparen", "Expected ')'");
    const body = parseBlock();
    return { kind: "For", init: init ?? null, test: test ?? null, post: post ?? null, body, line: t.line, column: t.column } as ForStmt;
  }

  function parseFunctionDecl(): FunctionDecl { const t = expect("kw_function", "Expected 'function'"); const id = expect("identifier", "Expected function name"); expect("lparen", "Expected '('"); const params: string[] = []; if (!match("rparen")) { const p = expect("identifier", "Expected parameter name"); params.push(p.value!); while (eat("comma")) { const q = expect("identifier", "Expected parameter name"); params.push(q.value!); } } expect("rparen", "Expected ')'"); const body = parseBlock(); return { kind: "FunctionDecl", name: id.value!, params, body: body.body, line: t.line, column: t.column }; }

  function parseReturn(): ReturnStmt { const t = expect("kw_return", "Expected 'return'"); let value: Expression | null = null; if (!match("semicolon")) value = parseExpr(); expect("semicolon", "Missing ';'"); return { kind: "Return", value, line: t.line, column: t.column }; }

  function parseParenOrExpr(): Expression { if (match("lparen")) { eat("lparen"); const e = parseExpr(); expect("rparen", "Expected ')'"); return e; } return parseExpr(); }

  function parseRuleDecl(): RuleDecl { const t = expect("kw_rule", "Expected 'rule'"); const id = expect("identifier", "Expected rule name"); const body = parseBlock(); return { kind: "RuleDecl", name: id.value!, body: body.body, line: t.line, column: t.column }; }

  function parseCallOrBuiltin(): Statement | ExprStmt | null {
    if (match("identifier")) {
      const t = tokens[i];
      const id = t.value!.toLowerCase();
      if (id === "set" || id === "toggle") {
        i++; expect("lparen", "Expected '('");
        const x = parseExpr(); expect("comma", "Expected ','");
        const y = parseExpr(); expect("rparen", "Expected ')'");
        expect("semicolon", "Missing ';'");
        return id === "set"
          ? ({ kind: "Set", x, y, line: t.line, column: t.column } as SetStmt)
          : ({ kind: "Toggle", x, y, line: t.line, column: t.column } as ToggleStmt);
      }
      if (id === "clear") { i++; expect("lparen", "Expected '()'"); expect("rparen", "Expected ')'"); expect("semicolon", "Missing ';'"); return { kind: "Clear", line: t.line, column: t.column } as ClearStmt; }
      if (id === "step") { i++; expect("lparen", "Expected '()'"); expect("rparen", "Expected ')'"); expect("semicolon", "Missing ';'"); return { kind: "Step", line: t.line, column: t.column } as StepStmt; }
      const expr = parseExpr();
      expect("semicolon", "Missing ';'");
      return { kind: "ExprStmt", expr, line: t.line, column: t.column } as ExprStmt;
    }
    return null;
  }

  function parseStatement(): Statement | null {
    if (match("kw_var")) return parseVarDecl();
    if (match("kw_rule")) return parseRuleDecl();
    if (match("kw_function")) return parseFunctionDecl();
    if (match("kw_return")) return parseReturn();
    if (match("kw_if")) return parseIf();
    if (match("kw_while")) return parseWhile();
    if (match("kw_for")) return parseFor();
    if (match("lbrace")) return parseBlock();
    if (match("identifier")) return parseCallOrBuiltin() as Statement;
    if (match("semicolon")) { i++; return null; }
    if (match("eof")) return null;
    i++; return null;
  }

  const body: Statement[] = [];
  while (!match("eof")) { const stmt = parseStatement(); if (stmt) body.push(stmt); }
  return { program: { source, ast: { kind: "Program", body } }, errors };
}
```

### src/semantics.ts
```ts
import type { Diagnostic, Value } from "./types";
import type { ProgramNode, Statement, VarDecl, RuleDecl, FunctionDecl, ReturnStmt, ExprStmt, IfStmt, WhileStmt, ForStmt, ForOfStmt, ForInStmt, BlockStmt } from "./ast";

export function semanticCheck(ast: ProgramNode): Diagnostic[] {
  const errors: Diagnostic[] = [];

  function scope() {
    const m = new Map<string, true>();
    return { has: (k: string) => m.has(k), set: (k: string) => m.set(k, true), map: m };
  }

  const scopes: ReturnType<typeof scope>[] = [scope()];
  function enter() { scopes.push(scope()); }
  function exit() { scopes.pop(); }
  function defineVar(name: string, line: number, column: number) {
    const s = scopes[scopes.length - 1];
    if (s.has(name)) errors.push({ message: `Variable '${name}' already defined in this scope`, line, column, severity: "error" });
    s.set(name);
  }
  function isVar(name: string) { for (let i = scopes.length - 1; i >= 0; i--) if (scopes[i].has(name)) return true; return false; }

  const rules = new Map<string, { line: number; column: number }>();
  const funcs = new Map<string, { line: number; column: number; params: string[] }>();

  function checkExpr(e: any) {
    if (!e) return;
    if (e.kind === "Identifier") { if (!isVar(e.name)) errors.push({ message: `Undefined variable '${e.name}'`, line: e.line, column: e.column, severity: "error" }); }
    else if (e.kind === "BinaryExpr") { checkExpr(e.left); checkExpr(e.right); }
    else if (e.kind === "CallExpr") {
      for (const a of e.args) checkExpr(a);
    } else if (e.kind === "ArrayLiteral") { for (const el of e.elements) checkExpr(el); }
    else if (e.kind === "IndexExpr") { checkExpr(e.target); checkExpr(e.index); }
    else if (e.kind === "ObjectLiteral") { for (const kv of e.entries) checkExpr(kv.value); }
  }

  function walk(stmt: Statement) {
    switch (stmt.kind) {
      case "VarDecl": defineVar(stmt.name, stmt.line, stmt.column); checkExpr(stmt.init); break;
      case "RuleDecl": if (rules.has(stmt.name)) errors.push({ message: `Rule '${stmt.name}' already defined`, line: stmt.line, column: stmt.column, severity: "error" }); else { rules.set(stmt.name, { line: stmt.line, column: stmt.column }); enter(); stmt.body.forEach(walk); exit(); } break;
      case "FunctionDecl": if (funcs.has(stmt.name)) errors.push({ message: `Function '${stmt.name}' already defined`, line: stmt.line, column: stmt.column, severity: "error" }); else { funcs.set(stmt.name, { line: stmt.line, column: stmt.column, params: stmt.params }); enter(); for (const p of stmt.params) defineVar(p, stmt.line, stmt.column); stmt.body.forEach(walk); exit(); } break;
      case "Set": case "Toggle": break;
      case "ExprStmt": checkExpr((stmt as ExprStmt).expr); break;
      case "If": checkExpr(stmt.test); enter(); stmt.then.body.forEach(walk); exit(); if (stmt.otherwise) { enter(); stmt.otherwise.body.forEach(walk); exit(); } break;
      case "While": checkExpr(stmt.test); enter(); stmt.body.body.forEach(walk); exit(); break;
      case "For": if (stmt.init) walk(stmt.init); if (stmt.test) checkExpr(stmt.test); if (stmt.post) walk(stmt.post); enter(); stmt.body.body.forEach(walk); exit(); break;
      case "ForOf": defineVar(stmt.varName, stmt.line, stmt.column); checkExpr(stmt.iterable); enter(); stmt.body.body.forEach(walk); exit(); break;
      case "ForIn": defineVar(stmt.varName, stmt.line, stmt.column); checkExpr(stmt.object); enter(); stmt.body.body.forEach(walk); exit(); break;
      case "Block": enter(); stmt.body.forEach(walk); exit(); break;
      case "Return": if (stmt.value) checkExpr(stmt.value); break;
    }
  }

  ast.body.forEach(walk);
  return errors;
}
```

### src/executor.ts
```ts
import type { Grid, VMState, Diagnostic, Program as Prog, Value } from "./types";
import type { ProgramNode, Statement, Expression, VarDecl, RuleDecl, FunctionDecl, ReturnStmt, SetStmt, ToggleStmt, ClearStmt, StepStmt, Identifier, NumberLiteral, StringLiteral, BinaryExpr, CallExpr, ExprStmt, IfStmt, WhileStmt, ForStmt, ForOfStmt, ForInStmt, BlockStmt, ArrayLiteral, IndexExpr, ObjectLiteral } from "./ast";
import { setCell, toggleCell, step as stepGrid } from "./vm";

export interface ExecuteResult { state: VMState; errors: Diagnostic[]; logs: string[]; }

export function execute(program: Prog<ProgramNode>, state: VMState): ExecuteResult {
  const errors: Diagnostic[] = [];
  let g = state.grid;
  const logs: string[] = [];

  type Frame = Map<string, Value>;
  const rules = new Map<string, RuleDecl>();
  const funcs = new Map<string, FunctionDecl>();
  const globals: Frame = new Map();
  const scopes: Frame[] = [globals];

  for (const stmt of program.ast.body) {
    if (stmt.kind === "RuleDecl") rules.set(stmt.name, stmt as RuleDecl);
    if (stmt.kind === "FunctionDecl") funcs.set(stmt.name, stmt as FunctionDecl);
  }

  const push = () => scopes.push(new Map());
  const pop = () => { scopes.pop(); };
  const setVar = (k: string, v: Value) => { scopes[scopes.length - 1].set(k, v); };
  const getVar = (k: string): Value => { for (let i = scopes.length - 1; i >= 0; i--) { const v = scopes[i].get(k); if (v !== undefined) return v; } return 0; };

  const isString = (v: Value): v is string => typeof v === "string";
  const toNum = (v: Value): number => typeof v === "number" ? (v|0) : Array.isArray(v) || v instanceof Map ? 0 : (isString(v) ? Number(v) || 0 : 0);
  const toStr = (v: Value): string => {
    if (typeof v === "string") return v;
    if (typeof v === "number") return String(v|0);
    if (Array.isArray(v)) return `[${v.map(toStr).join(",")}]`;
    if (v instanceof Map) return `{${Array.from(v.entries()).map(([k,val]) => `${k}:${toStr(val)}`).join(",")}}`;
    return "";
  };
  const truthy = (n: Value) => toNum(n) !== 0;

  function evalExpr(e: Expression): Value {
    switch (e.kind) {
      case "NumberLiteral": return (e as NumberLiteral).value | 0;
      case "StringLiteral": return (e as StringLiteral).value;
      case "Identifier": return getVar((e as Identifier).name) ?? 0;
      case "ArrayLiteral": return (e as ArrayLiteral).elements.map(evalExpr);
      case "ObjectLiteral": { const m = new Map<string, Value>(); for (const kv of (e as ObjectLiteral).entries) m.set(kv.key, evalExpr(kv.value)); return m; }
      case "IndexExpr": {
        const ix = e as IndexExpr; const target = evalExpr(ix.target); const kVal = evalExpr(ix.index);
        if (Array.isArray(target)) { const idx = toNum(kVal); return target[idx] ?? 0; }
        if (target instanceof Map) { const key = isString(kVal) ? kVal : String(toNum(kVal)); return target.get(key) ?? 0; }
        return 0;
      }
      case "BinaryExpr": {
        const b = e as BinaryExpr; const L = evalExpr(b.left); const R = evalExpr(b.right);
        if (b.op === "+" && (isString(L) || isString(R))) return toStr(L) + toStr(R);
        const Ln = toNum(L), Rn = toNum(R);
        switch (b.op) {
          case "+": return Ln + Rn; case "-": return Ln - Rn; case "*": return Ln * Rn; case "/": return Math.trunc(Rn === 0 ? 0 : Ln / Rn); case "%": return Rn === 0 ? 0 : (Ln | 0) % (Rn | 0);
          case "==": return Ln === Rn ? 1 : 0; case "!=": return Ln !== Rn ? 1 : 0; case "<": return Ln < Rn ? 1 : 0; case ">": return Ln > Rn ? 1 : 0; case "<=": return Ln <= Rn ? 1 : 0; case ">=": return Ln >= Rn ? 1 : 0;
        }
      }
      case "CallExpr": {
        const c = e as CallExpr;
        if (c.name === "step") { g = stepGrid(g); return 0; }
        if (c.name === "clear") { g.data.fill(0); return 0; }
        if (c.name === "print") { const vals = c.args.map((a) => evalExpr(a)); logs.push(vals.map(toStr).join(" ")); return 0; }
        if (c.name === "len") { const v = c.args.length ? evalExpr(c.args[0]) : 0; if (typeof v === "string") return v.length; if (Array.isArray(v)) return v.length; if (v instanceof Map) return v.size; return 0; }
        const rule = rules.get(c.name);
        if (rule) { runBlock(rule.body); return 0; }
        const fn = funcs.get(c.name);
        if (fn) return callFunction(fn, c.args.map((a) => evalExpr(a)));
        return 0;
      }
    }
    return 0;
  }

  function callFunction(fn: FunctionDecl, values: Value[]): Value { push(); for (let i = 0; i < fn.params.length; i++) setVar(fn.params[i], values[i] ?? 0); try { for (const s of fn.body) { const r = runStmtWithReturn(s); if (r && r.__return === true) return r.value ?? 0; } } finally { pop(); } return 0; }

  function runStmtWithReturn(stmt: Statement): { __return: true; value?: Value } | null {
    switch (stmt.kind) {
      case "Return": return { __return: true, value: stmt.value ? evalExpr(stmt.value) : 0 };
      case "Block": push(); for (const s of (stmt as BlockStmt).body) { const r = runStmtWithReturn(s); if (r) { pop(); return r; } } pop(); return null;
      case "If": { const I = stmt as IfStmt; const branch = truthy(evalExpr(I.test)) ? I.then : I.otherwise; if (!branch) return null; return runStmtWithReturn(branch); }
      case "While": { const W = stmt as WhileStmt; while (truthy(evalExpr(W.test))) { const r = runStmtWithReturn(W.body); if (r) return r; } return null; }
      case "For": { const F = stmt as ForStmt; push(); if (F.init) runStmt(F.init); while (!F.test || truthy(evalExpr(F.test))) { const r = runStmtWithReturn(F.body); if (r) { pop(); return r; } if (F.post) runStmt(F.post); } pop(); return null; }
      case "ForOf": { const F = stmt as ForOfStmt; const iter = evalExpr(F.iterable); if (Array.isArray(iter)) { push(); for (const item of iter) { setVar(F.varName, item); const r = runStmtWithReturn(F.body); if (r) { pop(); return r; } } pop(); } return null; }
      case "ForIn": { const F = stmt as ForInStmt; const obj = evalExpr(F.object); if (obj instanceof Map) { push(); for (const k of obj.keys()) { setVar(F.varName, k as any as Value); const r = runStmtWithReturn(F.body); if (r) { pop(); return r; } } pop(); } else if (Array.isArray(obj)) { push(); for (let idx = 0; idx < obj.length; idx++) { setVar(F.varName, idx); const r = runStmtWithReturn(F.body); if (r) { pop(); return r; } } pop(); } return null; }
      default: runStmt(stmt); return null;
    }
  }

  function runStmt(stmt: Statement) {
    switch (stmt.kind) {
      case "VarDecl": setVar((stmt as VarDecl).name, evalExpr((stmt as VarDecl).init)); break;
      case "Set": { const s = stmt as SetStmt; const x = toNum(evalExpr(s.x)); const y = toNum(evalExpr(s.y)); if (Number.isFinite(x) && Number.isFinite(y)) setCell(g, x|0, y|0, 1); break; }
      case "Toggle": { const t = stmt as ToggleStmt; const x = toNum(evalExpr(t.x)); const y = toNum(evalExpr(t.y)); if (Number.isFinite(x) && Number.isFinite(y)) toggleCell(g, x|0, y|0); break; }
      case "Clear": g.data.fill(0); break;
      case "Step": g = stepGrid(g); break;
      case "ExprStmt": evalExpr((stmt as ExprStmt).expr); break;
      case "Block": push(); for (const s of (stmt as BlockStmt).body) runStmt(s); pop(); break;
      case "If": { const I = stmt as IfStmt; if (truthy(evalExpr(I.test))) runStmt(I.then); else if (I.otherwise) runStmt(I.otherwise); break; }
      case "While": { const W = stmt as WhileStmt; while (truthy(evalExpr(W.test))) runStmt(W.body); break; }
      case "For": { const F = stmt as ForStmt; push(); if (F.init) runStmt(F.init); while (!F.test || truthy(evalExpr(F.test))) { runStmt(F.body); if (F.post) runStmt(F.post); } pop(); break; }
      case "ForOf": { const F = stmt as ForOfStmt; const iter = evalExpr(F.iterable); if (Array.isArray(iter)) { push(); for (const item of iter) { setVar(F.varName, item); runStmt(F.body); } pop(); } break; }
      case "ForIn": { const F = stmt as ForInStmt; const obj = evalExpr(F.object); if (obj instanceof Map) { push(); for (const k of obj.keys()) { setVar(F.varName, k as any as Value); runStmt(F.body); } pop(); } else if (Array.isArray(obj)) { push(); for (let idx = 0; idx < obj.length; idx++) { setVar(F.varName, idx); runStmt(F.body); } pop(); } break; }
      case "RuleDecl": case "FunctionDecl": /* registered already */ break;
      case "Return": /* only valid in functions */ break;
    }
  }

  function runBlock(body: Statement[]) { push(); for (const s of body) runStmt(s); pop(); }

  for (const stmt of program.ast.body) runStmt(stmt);
  return { state: { grid: g }, errors, logs };
}
```

### src/index.ts
```ts
export * from "./types";
export * from "./ast";
export { makeGrid, cloneGrid, getCell, setCell, toggleCell, step, initVM } from "./vm";

import type { CompileResult } from "./types";
import type { ProgramNode } from "./ast";
import { parse, type ParseResult } from "./parser";
import { semanticCheck } from "./semantics";
import { execute, type ExecuteResult } from "./executor";
import { lint as runLint } from "./linter";

export function compile(source: string): CompileResult<ProgramNode> {
  const parsed: ParseResult = parse(source);
  const style = runLint(source).filter((d) => d.severity === "error");
  const sema = semanticCheck(parsed.program.ast);
  return { program: parsed.program, errors: [...parsed.errors, ...style, ...sema] };
}

export { execute };
```

---

## mpl-web

### package.json
```json
{
  "name": "mpl-web",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -p tsconfig.json && vite build",
    "preview": "vite preview",
    "lint": "echo 'Lint via Monaco in-IDE for .mpl; add ESLint here if desired'"
  },
  "dependencies": {
    "@monaco-editor/react": "^4.6.0",
    "monaco-editor": "^0.49.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "mpl-core": "*"
  },
  "devDependencies": {
    "typescript": "^5.5.4",
    "vite": "^5.4.2",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1"
  }
}
```

### tsconfig.json
```json
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": { "types": ["vite/client"], "baseUrl": "." },
  "include": ["src", "vite.config.ts", "index.html"]
}
```

### vite.config.ts
```ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
export default defineConfig({ plugins: [react()], server: { port: 5173 } });
```

### index.html
```html
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MPL Playground</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

### src/main.tsx
```ts
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
import "./styles.css";
createRoot(document.getElementById("root")!).render(<React.StrictMode><App /></React.StrictMode>);
```

### src/examples.ts (strings + built-ins)
```ts
export const EXAMPLES: Record<string, string> = {
  Hello: `var msg = "Hi";\nprint(msg + " there");`,
  Lengths: `var a = [1,2,3]; var m = { x:[0,0], y:[1,1] }; var s = "abc";\nprint(len(a), len(m), len(s));`,
  MixedConcat: `print("Cells:" + 3 + " items");`,
};
```

### src/App.tsx
```tsx
import { useEffect, useMemo } from "react";
import MonacoMPL from "./editor/MonacoMPL";
import GridCanvas from "./canvas/GridCanvas";
import { useMPL } from "./state/useMPL";
import { EXAMPLES } from "./examples";

export default function App() {
  const { source, setSource, diagnostics, run, state, stepOnce, clearGrid, toggleAt, playing, setPlaying, speed, setSpeed, logs } = useMPL();
  const exampleNames = useMemo(() => Object.keys(EXAMPLES), []);
  useEffect(() => { if (!source.trim()) setSource(EXAMPLES[exampleNames[0]]); }, []);

  return (
    <div className="app">
      <header className="bar">
        <h1>MPL Playground (Stage 1I)</h1>
        <div className="controls">
          <button onClick={run}>Run</button>
          <button onClick={stepOnce}>Step</button>
          <button onClick={clearGrid}>Clear</button>
          <button onClick={() => setPlaying((p) => !p)}>{playing ? "Pause" : "Play"}</button>
          <label className="speed">Speed
            <input type="range" min={1} max={30} value={speed} onChange={(e) => setSpeed(Number(e.target.value))} />
          </label>
          <select onChange={(e) => setSource(EXAMPLES[e.target.value])}>
            {exampleNames.map((k) => (<option key={k} value={k}>{k}</option>))}
          </select>
        </div>
      </header>
      <main className="content content-1i">
        <section className="editor"><MonacoMPL value={source} onChange={setSource} diagnostics={diagnostics} /></section>
        <section className="canvas"><GridCanvas grid={state.grid} cellSize={16} onToggle={toggleAt} /></section>
        <section className="console" aria-label="Program output"><pre>{logs.join("\n")}</pre></section>
      </main>
    </div>
  );
}
```

### src/editor/MonacoMPL.tsx (no change needed – strings already styled)
```tsx
import Editor, { OnChange, useMonaco } from "@monaco-editor/react";
import { useEffect } from "react";
export interface MonacoDiag { message: string; line: number; column: number; severity: "error" | "warning"; }
export default function MonacoMPL({ value, onChange, diagnostics }: { value: string; onChange: (v: string) => void; diagnostics: MonacoDiag[]; }) {
  const monaco = useMonaco();
  useEffect(() => {
    if (!monaco) return;
    const id = "mpl";
    monaco.languages.register({ id });
    monaco.languages.setMonarchTokensProvider(id, { tokenizer: { root: [
      [/\/\/.*$/, "comment"],
      [/\b(var|rule|function|return|if|else|while|for|of|in|set|clear|toggle|step|print|len)\b/, "keyword"],
      [/\b\d+\b/, "number"],
      [/"[^"]*"/, "string"],
      [[/[{}()[\]]/, "delimiter"]],
      [/[,.:=+\-/*%<>!\[\]]/, "delimiter"],
      [/\b[A-Za-z_][A-Za-z0-9_]*\b/, "identifier"],
    ]}});
  }, [monaco]);
  useEffect(() => {
    if (!monaco) return; const model = monaco.editor.getModels()[0]; if (!model) return;
    const frame = requestAnimationFrame(() => {
      monaco.editor.setModelMarkers(model, "mpl-linter", diagnostics.map((d) => ({
        message: d.message, startLineNumber: d.line, startColumn: d.column, endLineNumber: d.line, endColumn: d.column + 1,
        severity: d.severity === "error" ? monaco.MarkerSeverity.Error : monaco.MarkerSeverity.Warning,
      })));
    });
    return () => cancelAnimationFrame(frame);
  }, [monaco, diagnostics]);
  const handleChange: OnChange = (v) => onChange(v || "");
  return <Editor height="100%" defaultLanguage="mpl" value={value} onChange={handleChange} options={{ minimap: { enabled: false }, fontSize: 14, tabSize: 2, insertSpaces: true, wordWrap: "on" }} />;
}
```

### src/state/useMPL.ts (collect logs)
```ts
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { compile, execute, initVM, step, toggleCell, type VMState } from "mpl-core";
import { lint } from "mpl-core";

const STORAGE_KEY = "mpl-source:last";

export function useMPL() {
  const [source, setSource] = useState<string>(() => localStorage.getItem(STORAGE_KEY) || "");
  const [state, setState] = useState<VMState>(() => initVM(64, 40));
  const [logs, setLogs] = useState<string[]>([]);
  const [playing, setPlaying] = useState(false);
  const [speed, setSpeed] = useState(10);
  const diagnostics = useMemo(() => lint(source), [source]);

  const raf = useRef<number | null>(null);
  const lastTs = useRef<number>(0);
  const acc = useRef<number>(0);

  useEffect(() => { localStorage.setItem(STORAGE_KEY, source); }, [source]);

  const run = useCallback(() => {
    const res = compile(source);
    if (res.errors.length) return;
    const out = execute(res.program, state);
    if (out.errors.length === 0) { setState(out.state); setLogs(out.logs); }
  }, [source, state]);

  const stepOnce = useCallback(() => setState((s) => ({ grid: step(s.grid) })), []);
  const clearGrid = useCallback(() => { setState((s) => ({ grid: { ...s.grid, data: new Uint8Array(s.grid.width * s.grid.height) } })); }, []);
  const toggleAt = useCallback((x: number, y: number) => { setState((s) => { const g = { ...s.grid, data: new Uint8Array(s.grid.data) }; toggleCell(g, x, y); return { grid: g }; }); }, []);

  const loop = useCallback((ts: number) => {
    if (!playing) return;
    const dt = (ts - lastTs.current) / 1000; lastTs.current = ts; acc.current += dt * speed;
    while (acc.current >= 1) { acc.current -= 1; setState((s) => ({ grid: step(s.grid) })); }
    raf.current = requestAnimationFrame(loop);
  }, [playing, speed]);

  useEffect(() => { if (playing) { lastTs.current = performance.now(); acc.current = 0; raf.current = requestAnimationFrame(loop); return () => { if (raf.current) cancelAnimationFrame(raf.current); }; } }, [playing, loop]);

  return { source, setSource, diagnostics, run, state, stepOnce, clearGrid, toggleAt, playing, setPlaying, speed, setSpeed, logs };
}
```

### src/styles.css (add console panel)
```css
* { box-sizing: border-box; }
html, body, #root { height: 100%; margin: 0; }
body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
.app { display: grid; grid-template-rows: 56px 1fr; height: 100%; }
.bar { display: flex; align-items: center; justify-content: space-between; padding: 0 12px; border-bottom: 1px solid #eee; }
.bar h1 { margin: 0; font-size: 16px; font-weight: 600; }
.content { display: grid; grid-template-columns: 1fr 1fr; height: 100%; }
.content-1i { grid-template-columns: 1fr 1fr 0.6fr; }
.editor { border-right: 1px solid #eee; }
.canvas { display: flex; align-items: stretch; justify-content: stretch; padding: 8px; }
.console { border-left: 1px solid #eee; padding: 8px; overflow: auto; background: #fafafa; }
.console pre { margin: 0; white-space: pre-wrap; word-break: break-word; }
.controls { display: flex; align-items: center; gap: 8px; }
.controls button { padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #fff; cursor: pointer; }
select, input[type="range"] { vertical-align: middle; }
.speed { display: inline-flex; align-items: center; gap: 6px; }
```

---

**Done.** This is a complete Stage 1I snapshot you can run as-is.

Want me to roll out **Stage 1J (comments, folding, tooltips)** next?
