# MPL – Stage 2S (Exportable Experiment Bundles + One‑Click Reproduce)

Stage **2S** makes every experiment portable and reproducible. You can **export a single file** that contains:

* environment (grid W×H, topology, edges),
* rule (B/S string), seed, steps, initial state snapshot,
* optional tags/logs/metrics,
* a semantic **manifest** with schema version.

Then **import & reproduce** the run in one click — same seed, same rule, same topology.

> Builds on 2J (sessions), 2K–2M (UI/sweeps), 2L (PRNG), 2O (tags), 2Q–2R (analytics + Pareto). Everything remains client‑side.

---

## Directory Tree (updated)

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ debug/
│  │  └─ trace.ts
│  ├─ web/
│  │  ├─ rulespec.ts
│  │  ├─ prng.ts
│  │  ├─ session.ts
│  │  ├─ sweep.ts
│  │  ├─ analytics.ts
│  │  ├─ optimizer.ts
│  │  ├─ sweep2r.ts
│  │  ├─ bundle.ts          # NEW: pack/unpack .mplbundle
│  │  └─ repro-main.ts      # NEW: one‑click reproduce UI logic
└─ index-2s.html            # NEW: 2S launcher (export/import)
```

Add this script to **package.json**:

```json
{
  "scripts": {
    "dev:2s": "vite --open index-2s.html"
  }
}
```

---

## src/web/bundle.ts (NEW — pack/unpack)

```ts
import { Grid2D } from '../runtime/grid.js';

export type Manifest = {
  schema: 'mpl-bundle@1';
  created: string;                // ISO date
  engine: { version: string };
  env: { width: number; height: number; topology: 'Moore'|'VonNeumann'; edges: 'Clip'|'Wrap' };
  rule: string;                   // B…/S…
  seed: number;                   // deterministic PRNG seed
  steps: number;                  // intended reproduction steps
  init?: 'snapshot'|'random';     // how initial state is provided
  p?: number;                     // random alive prob (if init=random)
  cells?: (null|{state:any;memory:any})[][]; // snapshot (if init=snapshot)
  metrics?: Record<string, any>;
  tags?: Array<{ step:number; type:string; meta?:any }>; // optional 2O tags
};

export function snapshot(grid: Grid2D){
  return (grid as any).cells.map((row:any[])=> row.map(m=> m? { state:{...m.state}, memory:{...m.memory} } : null));
}

export function pack(opts: Manifest): Blob {
  const text = JSON.stringify(opts, null, 2);
  return new Blob([text], { type: 'application/json' });
}

export async function unpack(file: File): Promise<Manifest>{
  const text = await file.text();
  const m = JSON.parse(text);
  if (m.schema !== 'mpl-bundle@1') throw new Error('Unsupported bundle schema');
  return m as Manifest;
}
```

---

## src/web/repro-main.ts (NEW — reproduce UI)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { createRng } from './prng.js';
import { rulesFromSpec, parseBS } from './rulespec.js';
import type { Manifest } from './bundle.js';
import { snapshot as snapCells, pack, unpack } from './bundle.js';

const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;
const canvas = $('grid') as HTMLCanvasElement; const ctx = canvas.getContext('2d')!;
const btnPlay = $('play'); const btnStep = $('step'); const btnExport = $('export');
const fileImport = $('import') as HTMLInputElement; const info = $('info');
const btnExportBundle = $('exportBundle');

let playing=false, ms=220; let step=0; let grid: Grid2D; let topoName: 'Moore'|'VonNeumann'='Moore'; let edges: 'Clip'|'Wrap'='Clip';
let manifest: Manifest | null = null;

function makeTopo(){ const base = topoName==='VonNeumann'? new VonNeumann() : new Moore(); return edges==='Wrap'? new Toroidal(base, ()=>({width:grid.width,height:grid.height})) : base; }

function draw(){
  const cell = 14; canvas.width = grid.width*cell; canvas.height = grid.height*cell;
  ctx.fillStyle='#0a0e11'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#e8eef2';
  for (let y=0;y<grid.height;y++) for (let x=0;x<grid.width;x++){ const m=(grid as any).cells[y][x]; if(m?.state?.alive) ctx.fillRect(x*cell,y*cell,cell,cell); }
}

function describe(m: Manifest){
  return `Rule ${m.rule}, seed=${m.seed}, ${m.env.width}x${m.env.height}, ${m.env.topology}/${m.env.edges}, steps=${m.steps}, init=${m.init}${m.init==='random'?` p=${m.p}`:''}`;
}

function fromManifest(m: Manifest){
  topoName = m.env.topology; edges = m.env.edges;
  const intr = new Interpreter(rulesFromSpec(parseBS(m.rule)));
  grid = new Grid2D(m.env.width, m.env.height, intr, makeTopo());
  if (m.init==='snapshot' && m.cells){
    for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ const c=m.cells[y][x]; if(c) (grid as any).cells[y][x] = new Monad(c.state, c.memory); }
  } else {
    const rng = createRng(m.seed); const p = m.p ?? 0.22;
    for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ (grid as any).cells[y][x] = rng.random()<p? new Monad({alive:true}) : null; }
  }
  step = 0; draw(); info.textContent = describe(m);
}

function toManifest(): Manifest {
  return {
    schema: 'mpl-bundle@1', created: new Date().toISOString(), engine: { version: '2S' },
    env: { width: grid.width, height: grid.height, topology: topoName, edges },
    rule: manifest?.rule ?? 'B3/S23', seed: manifest?.seed ?? 1, steps: manifest?.steps ?? 200,
    init: 'snapshot', cells: snapCells(grid)
  };
}

function tick(){ grid.tick(); step++; draw(); }
function loop(){ if(!playing) return; const t0=performance.now(); tick(); const dt=Math.max(0, ms-(performance.now()-t0)); setTimeout(loop, dt); }

btnPlay.onclick = () => { playing=!playing; btnPlay.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); };
btnStep.onclick = () => { if(!playing) tick(); };
btnExport.onclick = () => { const dump = { width:grid.width, height:grid.height, step, cells: snapCells(grid) }; const blob = new Blob([JSON.stringify(dump,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`snapshot-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href); };
btnExportBundle.onclick = () => { const blob = pack(toManifest()); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`experiment-${Date.now()}.mplbundle`; a.click(); URL.revokeObjectURL(a.href); };

fileImport.onchange = async () => { const f=fileImport.files?.[0]; if(!f) return; try { const m = await unpack(f); manifest = m; fromManifest(m); } catch(e:any){ alert('Invalid bundle: '+e.message); } };

// Demo default
manifest = { schema:'mpl-bundle@1', created:new Date().toISOString(), engine:{version:'2S'}, env:{width:40,height:30,topology:'Moore',edges:'Clip'}, rule:'B3/S23', seed:12345, steps:200, init:'random', p:0.22 };
fromManifest(manifest);
```

---

## index-2s.html (NEW — export/import launcher)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2S – Experiment Bundles</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; }
    button, input { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 2S (Exportable Bundles + Reproduce)</h1>
    <small>Single‑file export • Deterministic replay • Snapshot capture</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <input id="import" type="file" accept="application/json,.mplbundle" />
      </div>
      <div class="row">
        <button id="export">Export Snapshot JSON</button>
        <button id="exportBundle">Export .mplbundle</button>
      </div>
      <div class="row"><small id="info"></small></div>
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
      </div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="560" height="420"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/repro-main.ts"></script>
</body>
</html>
```

---

## README addendum (2S)

````md
### 2S – Exportable Experiment Bundles + One‑Click Reproduce

Run the exporter/reproducer:
```bash
npm i
npm run dev:2s
````

* **Import** an `.mplbundle` to load an experiment (rule/seed/grid/topology/edges and either snapshot or random init).
* **Play/Step** to reproduce the run deterministically.
* **Export** either a raw snapshot JSON or a full `.mplbundle` you can share.

**Bundle schema** (`mpl-bundle@1`):

* `env`: width, height, topology, edges
* `rule`: Life‑like B/S string
* `seed`, `steps`, `init` (`snapshot|random`), optional `p`
* `cells`: snapshot matrix when `init=snapshot`
* `metrics`, `tags`: optional extras from earlier stages

```
```
