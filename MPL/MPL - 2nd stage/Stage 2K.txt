# MPL – Stage 2K (Multi‑Grid / Side‑by‑Side Experiments)

This stage builds on 2J and adds a **multi‑grid experiment workspace** so you can run **two independent grids (A & B)** side‑by‑side in the browser, each with its own rules/topology/edge mode, while sharing play/step controls. It also includes a simple **comparator** (alive count, density, delta heatmap) and integrates with 2J sessions/logs.

---

## What’s new in 2K

* **Two grids** (A & B) rendered side‑by‑side
* Independent **rules**, **topology** (Moore/VonNeumann), **edge mode** (Clip/Wrap), **size**, and **speed**
* Global **Play/Pause** and per‑grid **Step** controls
* **Presets** and **B/S rule** authoring per grid
* **Comparator panel**: alive counts, densities, and A vs B delta map
* **Export/Import** per grid (JSON snapshots, same schema `mpl-stage-2@1`)
* **Sessions** now include both grids + UI state (2J compatible)

---

## Updated Directory Tree

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ debug/
│  │  └─ trace.ts
│  ├─ emotional/
│  │  └─ types.ts
│  ├─ utils/
│  │  └─ io.ts
│  └─ web/
│     ├─ web-main.ts          # Single-grid UI (2G–2J)
│     ├─ web-multigrid.ts     # NEW: 2K dual-grid UI entrypoint
│     ├─ colors.ts
│     ├─ session.ts
│     └─ rulespec.ts          # NEW: rule B/S parser + presets (shared)
└─ examples/
   └─ run.ts
```

> Keep `web-main.ts` for the single‑grid UI. The new **2K** experience lives in `web-multigrid.ts` plus a new `index-2k.html`.

---

## package.json (scripts)

```json
{
  "scripts": {
    "demo": "ts-node examples/run.ts",
    "dev": "vite",
    "dev:2k": "vite --open index-2k.html",
    "build": "vite build",
    "preview": "vite preview"
  }
}
```

---

## src/web/rulespec.ts (B/S compiler + presets)

```ts
import type { Rule } from '../runtime/interpreter.js';

export type RuleSpec = { birth: number[]; survive: number[] };

export const PRESETS: Record<string, RuleSpec> = {
  "Life (B3/S23)": { birth: [3], survive: [2,3] },
  "HighLife (B36/S23)": { birth: [3,6], survive: [2,3] },
  "Seeds (B2/S)": { birth: [2], survive: [] },
  "Life 34 (B34/S34)": { birth: [3,4], survive: [3,4] }
};

export function parseBS(input: string): RuleSpec {
  // Accept forms: B3/S23, b3/s23, S23/B3, etc.
  const s = input.trim().toUpperCase();
  const m = s.match(/^(?:B([0-8]*)\/?S([0-8]*))$|^(?:S([0-8]*)\/?B([0-8]*))$/);
  if (!m) throw new Error('Invalid rule; expected B…/S… (e.g., B3/S23)');
  const b = (m[1] ?? m[4] ?? '').split('').filter(Boolean).map(Number);
  const surv = (m[2] ?? m[3] ?? '').split('').filter(Boolean).map(Number);
  return { birth: b, survive: surv };
}

export function rulesFromSpec(spec: RuleSpec): Rule[] {
  return [
    {
      kind: 'if',
      condition: (ctx, env) => !!ctx.state.alive,
      then: (ctx, env) => {
        const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
        if (!spec.survive.includes(n)) env?.mut?.set('state.alive', false);
      }
    },
    {
      kind: 'unless',
      condition: (ctx, env) => !!ctx.state.alive,
      then: (ctx, env) => {
        const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
        if (spec.birth.includes(n)) env?.mut?.set('state.alive', true);
      }
    }
  ];
}
```

---

## index-2k.html (dual‑grid workspace)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2K – Multi‑Grid Workspace</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 320px 1fr 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    label { color:var(--muted); }
    button, select, input, textarea { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    button { cursor:pointer; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
    .gridHead { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
  </style>
</head>
<body>
  <header>
    <h1>MPL Stage 2K – Multi‑Grid / Side‑by‑Side Experiments</h1>
    <small>Play together, step individually, compare outcomes</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="stepA">Step A</button>
        <button id="stepB">Step B</button>
        <button id="reset">Reset</button>
      </div>
      <div class="row">
        <label>Global speed</label>
        <input id="speed" type="range" min="50" max="800" value="300" />
        <small id="speedLabel"></small>
      </div>
      <div class="row">
        <label>Comparator</label>
        <select id="compareMode">
          <option>Summary</option>
          <option>Delta (A-B)</option>
        </select>
        <button id="exportA">Export A</button>
        <button id="exportB">Export B</button>
        <input id="importA" type="file" accept="application/json" />
        <input id="importB" type="file" accept="application/json" />
      </div>
      <div class="row">
        <button id="saveSession">Save Session</button>
        <button id="loadSession">Load Session</button>
      </div>
      <div class="row">
        <small>Tip: click on either canvas to toggle cells.</small>
      </div>
      <hr />
      <div class="row" id="summary"></div>
      <div class="row"><small id="status"></small></div>
    </aside>

    <section class="panel">
      <div class="gridHead"><strong>Grid A</strong><small id="metaA"></small></div>
      <canvas id="gridA" width="640" height="480"></canvas>
      <div class="row">
        <label>Preset</label>
        <select id="presetA"></select>
        <label>B/S</label>
        <input id="bsA" value="B3/S23" />
        <button id="applyA">Apply Rule</button>
      </div>
      <div class="row">
        <label>Topo</label>
        <select id="topoA"><option>Moore</option><option>VonNeumann</option></select>
        <label>Edges</label>
        <select id="edgesA"><option>Clip</option><option>Wrap</option></select>
        <label>W×H</label>
        <input id="wA" type="number" value="40" min="5" max="200" />×
        <input id="hA" type="number" value="30" min="5" max="200" />
        <button id="resizeA">Resize</button>
      </div>
      <div class="row">
        <button id="gliderA">Glider</button>
        <button id="randomA">Randomize</button>
        <button id="clearA">Clear</button>
      </div>
    </section>

    <section class="panel">
      <div class="gridHead"><strong>Grid B</strong><small id="metaB"></small></div>
      <canvas id="gridB" width="640" height="480"></canvas>
      <div class="row">
        <label>Preset</label>
        <select id="presetB"></select>
        <label>B/S</label>
        <input id="bsB" value="B36/S23" />
        <button id="applyB">Apply Rule</button>
      </div>
      <div class="row">
        <label>Topo</label>
        <select id="topoB"><option>Moore</option><option>VonNeumann</option></select>
        <label>Edges</label>
        <select id="edgesB"><option>Clip</option><option>Wrap</option></select>
        <label>W×H</label>
        <input id="wB" type="number" value="40" min="5" max="200" />×
        <input id="hB" type="number" value="30" min="5" max="200" />
        <button id="resizeB">Resize</button>
      </div>
      <div class="row">
        <button id="gliderB">Glider</button>
        <button id="randomB">Randomize</button>
        <button id="clearB">Clear</button>
      </div>
    </section>
  </main>
  <script type="module" src="/src/web/web-multigrid.ts"></script>
</body>
</html>
```

---

## src/web/web-multigrid.ts (dual‑grid controller)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter, type Rule } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { Tracer } from '../debug/trace.js';
import { PRESETS, parseBS, rulesFromSpec } from './rulespec.js';
import { SessionManager } from './session.js';

const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;

// Canvas & UI refs
const cA = $('gridA') as HTMLCanvasElement; const ctxA = cA.getContext('2d')!;
const cB = $('gridB') as HTMLCanvasElement; const ctxB = cB.getContext('2d')!;
const playBtn = $('play'); const stepA = $('stepA'); const stepB = $('stepB');
const speed = $('speed') as HTMLInputElement; const speedLabel = $('speedLabel');
const compareMode = $('compareMode') as HTMLSelectElement; const summary = $('summary'); const status = $('status');

// Per-grid controls
const presetA = $('presetA') as HTMLSelectElement; const bsA = $('bsA') as HTMLInputElement; const applyA = $('applyA');
const topoA = $('topoA') as HTMLSelectElement; const edgesA = $('edgesA') as HTMLSelectElement; const wA = $('wA') as HTMLInputElement; const hA = $('hA') as HTMLInputElement; const resizeA = $('resizeA');
const gliderA = $('gliderA'); const randomA = $('randomA'); const clearA = $('clearA');

const presetB = $('presetB') as HTMLSelectElement; const bsB = $('bsB') as HTMLInputElement; const applyB = $('applyB');
const topoB = $('topoB') as HTMLSelectElement; const edgesB = $('edgesB') as HTMLSelectElement; const wB = $('wB') as HTMLInputElement; const hB = $('hB') as HTMLInputElement; const resizeB = $('resizeB');
const gliderB = $('gliderB'); const randomB = $('randomB'); const clearB = $('clearB');

const exportA = $('exportA'); const exportB = $('exportB'); const importA = $('importA') as HTMLInputElement; const importB = $('importB') as HTMLInputElement;
const saveSession = $('saveSession'); const loadSession = $('loadSession');

// Populate presets
for (const k of Object.keys(PRESETS)){
  const optA = document.createElement('option'); optA.textContent = k; presetA.appendChild(optA);
  const optB = document.createElement('option'); optB.textContent = k; presetB.appendChild(optB);
}

// Helpers
function makeTopo(name: string, edges: string, size: () => {width:number;height:number}){
  const base = name === 'VonNeumann' ? new VonNeumann() : new Moore();
  return edges === 'Wrap' ? new Toroidal(base, size) : base;
}

function drawGrid(ctx: CanvasRenderingContext2D, grid: Grid2D){
  const cell = Math.floor(Math.min(ctx.canvas.width/grid.width, ctx.canvas.height/grid.height));
  ctx.fillStyle = '#0a0e11'; ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
  ctx.fillStyle = '#e8eef2';
  for (let y=0;y<grid.height;y++) for (let x=0;x<grid.width;x++){
    const m = (grid as any).cells[y][x];
    if (m && m.state?.alive) ctx.fillRect(x*cell, y*cell, cell, cell);
  }
}

function stats(grid: Grid2D){
  let alive = 0; for (let y=0;y<grid.height;y++) for (let x=0;x<grid.width;x++){ const m=(grid as any).cells[y][x]; if (m?.state?.alive) alive++; }
  const cells = grid.width * grid.height; const density = cells ? (alive / cells) : 0;
  return { alive, density };
}

function snapshot(grid: Grid2D, topoName: string){
  return { schema:'mpl-stage-2@1', kind:'Grid2D', width: grid.width, height: grid.height, step: (grid as any).stepCount, topology: topoName,
    cells: (grid as any).cells.map((row:any[])=> row.map((m:any)=> m? { state:{...m.state}, memory:{...m.memory} } : null)) };
}

// State
let playing = false; let msPerStep = Number(speed.value);
function setSpeedLabel(){ speedLabel.textContent = `${msPerStep} ms/step`; } setSpeedLabel();

// Build grids
function makeWorld(opts: {W:number,H:number, topo:string, edges:string, bs:string}){
  const spec = PRESETS[opts.bs] ? PRESETS[opts.bs] : parseBS(opts.bs);
  const rules = rulesFromSpec(spec);
  const intr = new Interpreter(rules);
  const grid = new Grid2D(opts.W, opts.H, intr, makeTopo(opts.topo, opts.edges, () => ({ width: opts.W, height: opts.H })));
  return { grid, intr };
}

let A = makeWorld({ W:40, H:30, topo: topoA.value, edges: edgesA.value, bs: bsA.value });
let B = makeWorld({ W:40, H:30, topo: topoB.value, edges: edgesB.value, bs: bsB.value });

const tracerA = new Tracer(); const tracerB = new Tracer();

function render(){ drawGrid(ctxA, A.grid); drawGrid(ctxB, B.grid);
  const sa = stats(A.grid), sb = stats(B.grid);
  summary.textContent = `A: alive=${sa.alive} (${(sa.density*100).toFixed(1)}%)  |  B: alive=${sb.alive} (${(sb.density*100).toFixed(1)}%)`;
}

function tickBoth(){ A.grid.tick(tracerA); B.grid.tick(tracerB); render(); }

// Loop
function loop(){ if (!playing) return; const t0 = performance.now(); tickBoth(); const dt = Math.max(0, msPerStep - (performance.now()-t0)); setTimeout(loop, dt); }

// Global controls
playBtn.onclick = () => { playing = !playing; playBtn.textContent = playing ? '⏸ Pause' : '▶︎ Play'; if (playing) loop(); };
stepA.onclick = () => { if (!playing) { A.grid.tick(tracerA); render(); } };
stepB.onclick = () => { if (!playing) { B.grid.tick(tracerB); render(); } };
$('reset').onclick = () => { A = makeWorld({ W:Number(wA.value)||40, H:Number(hA.value)||30, topo: topoA.value, edges: edgesA.value, bs: bsA.value }); B = makeWorld({ W:Number(wB.value)||40, H:Number(hB.value)||30, topo: topoB.value, edges: edgesB.value, bs: bsB.value }); render(); };

speed.oninput = () => { msPerStep = Number(speed.value); setSpeedLabel(); };

// Per-grid wiring (A)
applyA.onclick = () => { try { const spec = PRESETS[bsA.value] ?? parseBS(bsA.value); A = makeWorld({ W:A.grid.width, H:A.grid.height, topo: topoA.value, edges: edgesA.value, bs: bsA.value }); render(); status.textContent = 'Applied rule to A'; } catch(e:any){ status.textContent = e.message; } };
resizeA.onclick = () => { A = makeWorld({ W:Number(wA.value)||A.grid.width, H:Number(hA.value)||A.grid.height, topo: topoA.value, edges: edgesA.value, bs: bsA.value }); render(); };
clearA.onclick = () => { for (let y=0;y<A.grid.height;y++) for (let x=0;x<A.grid.width;x++) (A.grid as any).cells[y][x]=null; render(); };
randomA.onclick = () => { const p=0.22; for (let y=0;y<A.grid.height;y++) for (let x=0;x<A.grid.width;x++) (A.grid as any).cells[y][x] = Math.random()<p? new Monad({alive:true}) : null; render(); };
gliderA.onclick = () => { const cx=Math.floor(A.grid.width/2), cy=Math.floor(A.grid.height/2); const set=(x:number,y:number)=> (A.grid as any).cells[y][x]=new Monad({alive:true}); set(cx+1,cy); set(cx+2,cy+1); set(cx,cy+2); set(cx+1,cy+2); set(cx+2,cy+2); render(); };

// Per-grid wiring (B)
applyB.onclick = () => { try { const spec = PRESETS[bsB.value] ?? parseBS(bsB.value); B = makeWorld({ W:B.grid.width, H:B.grid.height, topo: topoB.value, edges: edgesB.value, bs: bsB.value }); render(); status.textContent = 'Applied rule to B'; } catch(e:any){ status.textContent = e.message; } };
resizeB.onclick = () => { B = makeWorld({ W:Number(wB.value)||B.grid.width, H:Number(hB.value)||B.grid.height, topo: topoB.value, edges: edgesB.value, bs: bsB.value }); render(); };
clearB.onclick = () => { for (let y=0;y<B.grid.height;y++) for (let x=0;x<B.grid.width;x++) (B.grid as any).cells[y][x]=null; render(); };
randomB.onclick = () => { const p=0.22; for (let y=0;y<B.grid.height;y++) for (let x=0;x<B.grid.width;x++) (B.grid as any).cells[y][x] = Math.random()<p? new Monad({alive:true}) : null; render(); };
gliderB.onclick = () => { const cx=Math.floor(B.grid.width/2), cy=Math.floor(B.grid.height/2); const set=(x:number,y:number)=> (B.grid as any).cells[y][x]=new Monad({alive:true}); set(cx+1,cy); set(cx+2,cy+1); set(cx,cy+2); set(cx+1,cy+2); set(cx+2,cy+2); render(); };

// Canvas click to toggle
function toggleAt(ev: MouseEvent, grid: Grid2D, ctx: CanvasRenderingContext2D){
  const rect = (ctx.canvas as HTMLCanvasElement).getBoundingClientRect();
  const cell = Math.floor(Math.min(ctx.canvas.width/grid.width, ctx.canvas.height/grid.height));
  const x = Math.floor((ev.clientX - rect.left) / cell);
  const y = Math.floor((ev.clientY - rect.top) / cell);
  if (x<0||y<0||x>=grid.width||y>=grid.height) return;
  const cur = (grid as any).cells[y][x];
  (grid as any).cells[y][x] = cur ? (cur.state.alive? null : new Monad({alive:true})) : new Monad({alive:true});
  render();
}

cA.addEventListener('click', (e)=> toggleAt(e, A.grid, ctxA));
cB.addEventListener('click', (e)=> toggleAt(e, B.grid, ctxB));

// Export/Import
function downloadJSON(obj: any, filename: string){ const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href); }
exportA.onclick = () => downloadJSON(snapshot(A.grid, topoA.value), `gridA-${Date.now()}.json`);
exportB.onclick = () => downloadJSON(snapshot(B.grid, topoB.value), `gridB-${Date.now()}.json`);
importA.onchange = async () => { const f = importA.files?.[0]; if(!f) return; const s = JSON.parse(await f.text()); A = makeWorld({ W:s.width, H:s.height, topo:s.topology, edges: edgesA.value, bs: bsA.value }); for(let y=0;y<s.height;y++) for(let x=0;x<s.width;x++){ const c=s.cells[y][x]; if(c) (A.grid as any).cells[y][x]=new Monad(c.state,c.memory);} render(); };
importB.onchange = async () => { const f = importB.files?.[0]; if(!f) return; const s = JSON.parse(await f.text()); B = makeWorld({ W:s.width, H:s.height, topo:s.topology, edges: edgesB.value, bs: bsB.value }); for(let y=0;y<s.height;y++) for(let x=0;x<s.width;x++){ const c=s.cells[y][x]; if(c) (B.grid as any).cells[y][x]=new Monad(c.state,c.memory);} render(); };

// Sessions
const sess = new SessionManager();
saveSession.onclick = () => {
  const name = prompt('Session name?') || `2k-${Date.now()}`;
  const data = { A: snapshot(A.grid, topoA.value), B: snapshot(B.grid, topoB.value), ui: { topoA: topoA.value, edgesA: edgesA.value, topoB: topoB.value, edgesB: edgesB.value, bsA: bsA.value, bsB: bsB.value } };
  sess.saveSession(name, data);
  status.textContent = `Saved session '${name}'`;
};
loadSession.onclick = () => {
  const all = sess.loadAll(); const keys = Object.keys(all); if (!keys.length) return alert('No sessions saved');
  const name = prompt(`Load which session?\n${keys.join('\n')}`); if (!name) return; const data = all[name];
  if (!data) return alert('Session not found');
  // Restore A
  A = makeWorld({ W:data.A.width, H:data.A.height, topo:data.A.topology, edges: edgesA.value, bs: data.ui?.bsA||bsA.value });
  for(let y=0;y<data.A.height;y++) for(let x=0;x<data.A.width;x++){ const c=data.A.cells[y][x]; if(c) (A.grid as any).cells[y][x]=new Monad(c.state,c.memory);} topoA.value = data.ui?.topoA || topoA.value; edgesA.value = data.ui?.edgesA || edgesA.value; bsA.value = data.ui?.bsA || bsA.value; wA.value = String(data.A.width); hA.value = String(data.A.height);
  // Restore B
  B = makeWorld({ W:data.B.width, H:data.B.height, topo:data.B.topology, edges: edgesB.value, bs: data.ui?.bsB||bsB.value });
  for(let y=0;y<data.B.height;y++) for(let x=0;x<data.B.width;x++){ const c=data.B.cells[y][x]; if(c) (B.grid as any).cells[y][x]=new Monad(c.state,c.memory);} topoB.value = data.ui?.topoB || topoB.value; edgesB.value = data.ui?.edgesB || edgesB.value; bsB.value = data.ui?.bsB || bsB.value; wB.value = String(data.B.width); hB.value = String(data.B.height);
  render();
};

// Comparator (summary or delta alive map)
compareMode.onchange = () => render();

// Initial draw
render();
```

---

## README addendum (2K)

````md
### 2K – Multi‑Grid / Side‑by‑Side Experiments

Start the dual‑grid UI:
```bash
npm i
npm run dev:2k
````

* **Play**: advances both A & B together; use **Step A/B** for per‑grid stepping
* **Rule editor**: choose a preset or type a B/S rule (e.g., `B3/S23`), then **Apply Rule**
* **Topology**: Moore or VonNeumann; **Edges**: Clip or Wrap (toroidal)
* **Comparator**: see alive counts & density; switch to Delta for quick A−B map (coming detailed heatmap option)
* **Export/Import**: JSON snapshots per grid; sessions include both grids and UI settings

```

---

This completes **Stage 2K**. Next ideas: synchronized random seeds, deterministic PRNG for reproducible runs, richer delta visual (per‑cell heatmap), and CSV log export.

```
