# MPL – Stage 2T (Cloud‑Ready Share Links • Integrity Hash • Multi‑Bundle Drag‑Drop)

**Goal:** make experiments easy to **share, verify, and batch‑load** — all client‑side. 2T introduces:

* **Share links** that embed an experiment bundle in the URL hash (base64url),
* **Integrity hashing (SHA‑256)** to verify bundles on import,
* **Drag‑and‑drop of multiple .mplbundle files**, with a selectable list to preview/reproduce any bundle.

> Builds on 2S (bundles+reproduce). No backend required.

---

## Directory Tree (updated)

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ debug/
│  │  └─ trace.ts
│  ├─ web/
│  │  ├─ rulespec.ts
│  │  ├─ prng.ts
│  │  ├─ session.ts
│  │  ├─ sweep.ts
│  │  ├─ analytics.ts
│  │  ├─ optimizer.ts
│  │  ├─ sweep2r.ts
│  │  ├─ bundle.ts
│  │  ├─ hash.ts           # NEW: SHA‑256 helpers (Web Crypto)
│  │  ├─ share.ts          # NEW: base64url share‑link helpers
│  │  └─ repro-2t.ts       # NEW: 2T UI logic (multi‑bundle + integrity)
└─ index-2t.html           # NEW: 2T launcher (share/verify/drag‑drop)
```

Add this script to **package.json**:

```json
{
  "scripts": {
    "dev:2t": "vite --open index-2t.html"
  }
}
```

---

## src/web/hash.ts (NEW — SHA‑256)

```ts
export async function sha256Hex(input: string | ArrayBuffer): Promise<string> {
  const data = typeof input === 'string' ? new TextEncoder().encode(input) : input;
  const buf = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}
```

---

## src/web/share.ts (NEW — base64url + share‑link)

```ts
import type { Manifest } from './bundle.js';
import { sha256Hex } from './hash.js';

export function b64urlEncode(bytes: Uint8Array): string {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
}
export function b64urlDecode(s: string): Uint8Array {
  const pad = s.length % 4 ? '='.repeat(4 - (s.length % 4)) : '';
  const b64 = s.replace(/-/g,'+').replace(/_/g,'/') + pad;
  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
  return out;
}

export async function makeShareURL(man: Manifest): Promise<string> {
  const json = JSON.stringify(man);
  const sha = await sha256Hex(json);
  const enc = b64urlEncode(new TextEncoder().encode(json));
  const base = location.origin + location.pathname.replace(/index-2s\.html$/,'index-2t.html');
  const hash = `bundle=${enc}&sha256=${sha}`;
  return `${base}#${hash}`;
}

export function parseHash(): { bundle?: Manifest; sha256?: string } | null {
  if (!location.hash) return null;
  const q = new URLSearchParams(location.hash.slice(1));
  const b = q.get('bundle'); const sha = q.get('sha256') || undefined;
  if (!b) return { sha256: sha };
  try {
    const json = new TextDecoder().decode(b64urlDecode(b));
    return { bundle: JSON.parse(json), sha256: sha } as any;
  } catch {
    return { sha256: sha };
  }
}
```

---

## src/web/repro-2t.ts (NEW — multi‑bundle, verify, share)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { rulesFromSpec, parseBS } from './rulespec.js';
import { createRng } from './prng.js';
import { snapshot as snapCells, unpack, type Manifest } from './bundle.js';
import { sha256Hex } from './hash.js';
import { makeShareURL, parseHash } from './share.js';

const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;
const canvas = $('grid') as HTMLCanvasElement; const ctx = canvas.getContext('2d')!;
const drop = $('drop'); const fileInput = $('file') as HTMLInputElement; const list = $('bundleList') as HTMLSelectElement;
const info = $('info'); const status = $('status');
const btnPlay = $('play'); const btnStep = $('step'); const btnCopy = $('copyLink'); const btnVerify = $('verify');
const btnExport = $('exportSnap'); const btnExportBundle = $('exportBundle');

let grid: Grid2D; let topoName: 'Moore'|'VonNeumann'='Moore'; let edges: 'Clip'|'Wrap'='Clip';
let playing=false, ms=220, step=0;
const store: { name: string; manifest: Manifest; sha256?: string }[] = [];

function makeTopo(){ const base = topoName==='VonNeumann'? new VonNeumann() : new Moore(); return edges==='Wrap'? new Toroidal(base, ()=>({width:grid.width,height:grid.height})) : base; }
function draw(){ const cell=14; canvas.width=grid.width*cell; canvas.height=grid.height*cell; ctx.fillStyle='#0a0e11'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#e8eef2'; for(let y=0;y<grid.height;y++) for(let x=0;x<grid.width;x++){ const m=(grid as any).cells[y][x]; if(m?.state?.alive) ctx.fillRect(x*cell,y*cell,cell,cell);} }

function describe(m: Manifest){ return `Rule ${m.rule}, seed=${m.seed}, ${m.env.width}x${m.env.height}, ${m.env.topology}/${m.env.edges}, steps=${m.steps}, init=${m.init}`; }

function fromManifest(m: Manifest){
  topoName = m.env.topology; edges = m.env.edges;
  const intr = new Interpreter(rulesFromSpec(parseBS(m.rule)));
  grid = new Grid2D(m.env.width, m.env.height, intr, makeTopo());
  if (m.init==='snapshot' && m.cells){ for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ const c=m.cells[y][x]; if(c) (grid as any).cells[y][x]=new Monad(c.state,c.memory); } }
  else { const rng=createRng(m.seed); const p=m.p ?? 0.22; for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ (grid as any).cells[y][x] = rng.random()<p? new Monad({alive:true}) : null; } }
  step=0; draw(); info.textContent = describe(m);
}

async function addToList(name: string, file: File){
  try {
    const text = await file.text();
    const sha = await sha256Hex(text);
    const man = JSON.parse(text) as Manifest; // allow raw JSON or .mplbundle
    store.push({ name, manifest: man, sha256: sha });
    const opt = document.createElement('option'); opt.textContent = `${name}  •  sha256=${sha.slice(0,8)}…`; opt.value = String(store.length-1); list.appendChild(opt);
    status.textContent = `Loaded ${name}`;
  } catch(e:any){ status.textContent = `Failed to load ${name}: ${e.message}`; }
}

// Drag‑drop
['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('hover'); }));
['dragleave','drop'].forEach(ev => drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.remove('hover'); }));
drop.addEventListener('drop', (e:any)=>{
  const files: FileList = e.dataTransfer?.files; if(!files) return; for (const f of Array.from(files)) addToList(f.name, f);
});
fileInput.onchange = () => { const files = fileInput.files; if(!files) return; for (const f of Array.from(files)) addToList(f.name, f); };

list.onchange = () => { const idx = Number(list.value); const row = store[idx]; if(row) fromManifest(row.manifest); };

btnCopy.onclick = async () => {
  const idx = Number(list.value); const row = store[idx]; if(!row){ status.textContent='No bundle selected'; return; }
  const url = await makeShareURL(row.manifest);
  await navigator.clipboard.writeText(url);
  status.textContent = 'Share link copied to clipboard';
};

btnVerify.onclick = async () => {
  const idx = Number(list.value); const row = store[idx]; if(!row){ status.textContent='No bundle selected'; return; }
  const json = JSON.stringify(row.manifest);
  const sha = await sha256Hex(json);
  status.textContent = sha === row.sha256 ? 'Integrity OK (sha256 matches file)' : `Integrity mismatch! computed=${sha} stored=${row.sha256}`;
};

btnExport.onclick = () => { const dump = { width:grid.width, height:grid.height, step, cells: snapCells(grid) }; const blob = new Blob([JSON.stringify(dump,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`snapshot-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href); };
btnExportBundle.onclick = async () => { const idx = Number(list.value); const row = store[idx]; const man = row?.manifest; if(!man){ status.textContent='No bundle selected'; return; } const text = JSON.stringify(man, null, 2); const blob = new Blob([text],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download = `${(row.name||'experiment')}.mplbundle`; a.click(); URL.revokeObjectURL(a.href); };

// Play/step
function tick(){ grid.tick(); step++; draw(); }
function loop(){ if(!playing) return; const t0=performance.now(); tick(); const dt=Math.max(0, ms-(performance.now()-t0)); setTimeout(loop, dt); }
btnPlay.onclick = ()=> { playing=!playing; btnPlay.textContent = playing? '⏸ Pause' : '▶︎ Play'; if(playing) loop(); };
btnStep.onclick = ()=> { if(!playing) tick(); };

// Auto‑hydrate from share link
(async function initFromHash(){
  const parsed = parseHash();
  if (parsed?.bundle){
    const man = parsed.bundle as Manifest; const json = JSON.stringify(man); const sha = await sha256Hex(json);
    const name = `shared@${sha.slice(0,8)}`;
    store.push({ name, manifest: man, sha256: parsed.sha256 });
    const opt = document.createElement('option'); opt.textContent = `${name}  •  sha256=${sha.slice(0,8)}…`; opt.value = String(store.length-1); list.appendChild(opt);
    list.value = String(store.length-1); fromManifest(man);
    status.textContent = parsed.sha256 && parsed.sha256!==sha ? 'WARNING: sha256 mismatch between link and payload' : 'Loaded from share link';
  } else {
    // Fallback demo manifest
    const demo: Manifest = { schema:'mpl-bundle@1', created:new Date().toISOString(), engine:{version:'2T'}, env:{width:40,height:30,topology:'Moore',edges:'Clip'}, rule:'B3/S23', seed:12345, steps:200, init:'random', p:0.22 };
    const sha = await sha256Hex(JSON.stringify(demo));
    store.push({ name:`demo@${sha.slice(0,8)}`, manifest: demo, sha256: sha });
    const opt = document.createElement('option'); opt.textContent = `demo@${sha.slice(0,8)}  •  sha256=${sha.slice(0,8)}…`; opt.value = '0'; list.appendChild(opt); list.value='0'; fromManifest(demo);
  }
})();
```

---

## index-2t.html (NEW — share/verify/drag‑drop UI)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2T – Share • Verify • Drag‑Drop</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input, select { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    #drop { border:2px dashed #2a3640; border-radius:10px; padding:14px; text-align:center; color:#8aa1b1; }
    #drop.hover { background:#0b1115; border-color:#56b6c2; color:#bfe7ee; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 2T (Share Links • Integrity • Multi‑Bundle)</h1>
    <small>Copyable links • SHA‑256 verify • Drag‑drop many bundles</small>
  </header>
  <main>
    <aside class="panel">
      <div id="drop">Drag & drop .mplbundle / JSON here</div>
      <div class="row"><input id="file" type="file" multiple accept="application/json,.mplbundle" /></div>
      <div class="row">
        <label>Bundles</label>
        <select id="bundleList" size="6" style="width:100%"></select>
      </div>
      <div class="row">
        <button id="copyLink">Copy Share Link</button>
        <button id="verify">Verify Hash</button>
      </div>
      <div class="row">
        <button id="exportSnap">Export Snapshot</button>
        <button id="exportBundle">Export .mplbundle</button>
      </div>
      <div class="row"><small id="status"></small></div>
      <div class="row"><small id="info"></small></div>
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
      </div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="560" height="420"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/repro-2t.ts"></script>
</body>
</html>
```

---

## README addendum (2T)

````md
### 2T – Cloud‑Ready Share Links • Integrity Hash • Multi‑Bundle Drag‑Drop

Run the 2T launcher:
```bash
npm i
npm run dev:2t
````

* **Share link:** select a bundle → **Copy Share Link**. The URL encodes the bundle in the `#bundle=` hash and includes `sha256=`.
* **Auto‑hydrate:** opening a share link loads the bundle instantly; we verify the SHA‑256 and warn on mismatch.
* **Verify:** select a bundle → **Verify Hash** to recompute SHA‑256 and compare with the file hash.
* **Multi‑load:** drag & drop many `.mplbundle` files (or choose with file picker). Use the **Bundles** list to switch between them.

**Notes**

* Hashing uses the Web Crypto API (SHA‑256) and base64url encoding for share links. Links can be long for big snapshots; for large bundles, consider file‑based sharing.
* This is backend‑free; swapping to a real cloud short‑link service later just means posting the encoded payload and returning a short id.

```
```
