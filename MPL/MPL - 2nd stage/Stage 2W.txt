# MPL – Stage 2W (Plugin‑Style Rule Packs + Runtime Capability Flags)

Stage **2W** turns the rules system into a **pluginable architecture** and adds **capability flags** so UIs can adapt to the currently loaded engine features.

* **Rule Packs**: self‑contained modules with metadata + factory to produce runtime rules (B/S Life‑like, Generations, custom neighborhood/topology, non‑binary states, etc.)
* **Discovery & Loading**: load rule packs at runtime (local file, URL, or built‑in gallery).
* **Capabilities**: each pack declares what it supports (e.g., multi‑state, weighted neighborhoods, stochastic transitions, tags provider), allowing dashboards to toggle UI affordances safely.

> Builds on earlier stages (2A‑2V). No engine changes required to *use* packs, but packs can leverage existing interpreter/topology APIs.

---

## Directory Tree (updated)

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ web/
│  │  ├─ rulespec.ts
│  │  ├─ prng.ts
│  │  ├─ session.ts
│  │  ├─ sweep.ts
│  │  ├─ analytics.ts
│  │  ├─ optimizer.ts
│  │  ├─ share2u.ts
│  │  ├─ bundle.ts
│  │  ├─ schema.ts
│  │  ├─ capabilities.ts   # NEW: capability flags + negotiation
│  │  ├─ rulepack.ts       # NEW: Rule Pack interface + loader
│  │  ├─ packs/
│  │  │  ├─ conway.ts      # NEW: built‑in Conway Life pack
│  │  │  ├─ highlife.ts    # NEW: built‑in HighLife pack
│  │  │  └─ generations.ts # NEW: simple Generations (multi‑state) pack
│  │  └─ rulehub.ts        # NEW: UI logic for pack discovery + load
└─ index-2w.html           # NEW: 2W launcher (Rule Hub)
```

Add this script to **package.json**:

```json
{
  "scripts": {
    "dev:2w": "vite --open index-2w.html"
  }
}
```

---

## src/web/capabilities.ts (NEW)

```ts
export type Capability =
  | 'binary-state'         // alive/dead
  | 'multi-state'          // 0..N states
  | 'stochastic'           // uses randomness in transitions
  | 'weighted-neighborhood'// weights kernel when counting neighbors
  | 'custom-topology'      // pack provides its own topology
  | 'tags-provider'        // emits PatternTag[] per step
  | 'metrics-provider';    // emits custom metrics per tick

export type CapSet = Record<Capability, boolean>;

export const EmptyCaps: CapSet = {
  'binary-state': false,
  'multi-state': false,
  'stochastic': false,
  'weighted-neighborhood': false,
  'custom-topology': false,
  'tags-provider': false,
  'metrics-provider': false,
};

export function mergeCaps(...sets: CapSet[]): CapSet {
  return sets.reduce((acc, s) => {
    for (const k in s) (acc as any)[k] = (acc as any)[k] || (s as any)[k];
    return acc;
  }, { ...EmptyCaps });
}
```

---

## src/web/rulepack.ts (NEW)

```ts
import type { CapSet } from './capabilities.js';
import type { Rule } from '../runtime/interpreter.js';
import type { Grid2D } from '../runtime/grid.js';

export type RulePackMeta = {
  id: string;                 // unique within session
  title: string;              // human label
  version: string;            // semver
  authors?: string[];
  description?: string;
  homepage?: string;
};

export type RulePackOptions = Record<string, any>;

export interface RulePack {
  meta: RulePackMeta;
  capabilities: CapSet;
  /** Return a set of interpreter rules built from options. */
  createRules(options: RulePackOptions): Rule[];
  /** Optional per‑tick hook to emit custom metrics or tags. */
  onTick?(grid: Grid2D, step: number): void | Record<string, number>;
}

export type PackModule = { default: RulePack } | RulePack;

export async function loadPackFromURL(url: string): Promise<RulePack> {
  const mod: any = await import(/* @vite-ignore */ url);
  const pack: PackModule = mod?.default ?? mod;
  if (!pack || !('meta' in pack) || !('capabilities' in pack) || !('createRules' in pack))
    throw new Error('Invalid rule pack module');
  return pack as RulePack;
}
```

---

## src/web/packs/conway.ts (NEW – built‑in pack)

```ts
import type { RulePack } from '../rulepack.js';
import type { Rule } from '../../runtime/interpreter.js';

function lifeRules(): Rule[] {
  // Classic Conway B3/S23 in interpreter DSL
  return [
    { kind: 'if', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => { const n = env?.countNeighbors(n => !!n.state.alive) ?? 0; if (!(n===2 || n===3)) env?.mut?.set('state.alive', false); } },
    { kind: 'unless', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => { const n = env?.countNeighbors(n => !!n.state.alive) ?? 0; if (n===3) env?.mut?.set('state.alive', true); } },
  ];
}

const pack: RulePack = {
  meta: { id: 'conway', title: 'Conway Life', version: '1.0.0', authors: ['MPL'], description: 'Classic B3/S23' },
  capabilities: { 'binary-state': true, 'multi-state': false, 'stochastic': false, 'weighted-neighborhood': false, 'custom-topology': false, 'tags-provider': false, 'metrics-provider': false },
  createRules(){ return lifeRules(); },
};

export default pack;
```

---

## src/web/packs/highlife.ts (NEW – B36/S23)

```ts
import type { RulePack } from '../rulepack.js';
import type { Rule } from '../../runtime/interpreter.js';

function highlifeRules(): Rule[] {
  return [
    { kind: 'if', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => { const n = env?.countNeighbors(n => !!n.state.alive) ?? 0; if (!(n===2 || n===3)) env?.mut?.set('state.alive', false); } },
    { kind: 'unless', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => { const n = env?.countNeighbors(n => !!n.state.alive) ?? 0; if (n===3 || n===6) env?.mut?.set('state.alive', true); } },
  ];
}

export default {
  meta: { id: 'highlife', title: 'HighLife', version: '1.0.0', authors: ['MPL'] },
  capabilities: { 'binary-state': true, 'multi-state': false, 'stochastic': false, 'weighted-neighborhood': false, 'custom-topology': false, 'tags-provider': false, 'metrics-provider': false },
  createRules(){ return highlifeRules(); },
} satisfies RulePack;
```

---

## src/web/packs/generations.ts (NEW – simple multi‑state)

```ts
import type { RulePack } from '../rulepack.js';
import type { Rule } from '../../runtime/interpreter.js';

// k‑state cyclic cellular automaton style: 0..K-1, state advances when >=T live neighbors
function genRules(K=3, T=3): Rule[] {
  return [
    { kind: 'effect', then: (ctx, env) => {
      const alive = (ctx.state.s ?? 0) > 0;
      const n = env?.countNeighbors(n => (n.state.s ?? 0) > 0) ?? 0;
      const s = ctx.state.s ?? 0;
      if (!alive && n >= T) env?.mut?.set('state.s', 1);
      else if (alive) env?.mut?.set('state.s', (s+1) % K);
    } }
  ];
}

export default {
  meta: { id: 'generations', title: 'Generations (K‑state)', version: '1.0.0', authors: ['MPL'], description: 'Simple multi‑state CA (0..K-1)' },
  capabilities: { 'binary-state': false, 'multi-state': true, 'stochastic': false, 'weighted-neighborhood': false, 'custom-topology': false, 'tags-provider': false, 'metrics-provider': false },
  createRules(opts){ const K = Number(opts?.K ?? 3); const T = Number(opts?.T ?? 3); return genRules(K, T); },
} satisfies RulePack;
```

---

## src/web/rulehub.ts (NEW – Rule Hub UI logic)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter, type Rule } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { loadPackFromURL, type RulePack, type RulePackOptions } from './rulepack.js';
import Conway from './packs/conway.ts';
import HighLife from './packs/highlife.ts';
import Generations from './packs/generations.ts';

const $ = <T extends HTMLElement>(id:string)=> document.getElementById(id) as T;
const canvas = $('grid') as HTMLCanvasElement; const ctx = canvas.getContext('2d')!;
const packList = $('pack') as HTMLSelectElement; const urlInput = $('url') as HTMLInputElement; const loadBtn = $('load');
const optsForm = $('opts') as HTMLFormElement; const capsDiv = $('caps');
const topoSel = $('topo') as HTMLSelectElement; const edgeSel = $('edges') as HTMLSelectElement;
const playBtn = $('play'); const stepBtn = $('step'); const randomBtn = $('random');

const builtins = [Conway, HighLife, Generations];
for (const p of builtins){ const o=document.createElement('option'); o.value=p.meta.id; o.textContent=`${p.meta.title} (${p.meta.version})`; packList.appendChild(o); }

let pack: RulePack = Conway; let rules: Rule[] = pack.createRules({});
let width=50, height=36, cell=14; let playing=false; let grid = makeGrid();

function makeTopo(){ const base = topoSel.value==='VonNeumann'? new VonNeumann() : new Moore(); return edgeSel.value==='Wrap'? new Toroidal(base, ()=>({width,height})) : base; }
function makeGrid(){ const intr=new Interpreter(rules); return new Grid2D(width, height, intr, makeTopo()); }

function draw(){ canvas.width=width*cell; canvas.height=height*cell; ctx.fillStyle='#0a0e11'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#e8eef2'; for(let y=0;y<height;y++) for(let x=0;x<width;x++){ const m=(grid as any).cells[y][x]; if(pack.capabilities['multi-state']){ const s=m?.state?.s??0; if(s>0){ const t=s/(opts.K||3); ctx.fillStyle=`hsl(${(1-t)*220},70%,65%)`; ctx.fillRect(x*cell,y*cell,cell,cell);} } else { if(m?.state?.alive) ctx.fillRect(x*cell,y*cell,cell,cell); } } }

function showCaps(){ capsDiv.innerHTML=''; const tbl=document.createElement('table'); tbl.style.fontSize='12px'; for(const [k,v] of Object.entries(pack.capabilities)){ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${v?'✅':'—'}</td>`; tbl.appendChild(tr);} capsDiv.appendChild(tbl); }

let opts: RulePackOptions = { K:3, T:3 };
function syncOptsUI(){ optsForm.innerHTML=''; if(pack.meta.id==='generations'){ optsForm.innerHTML = `K <input id="optK" type="number" value="${opts.K}" min="2" max="8"/> T <input id="optT" type="number" value="${opts.T}" min="1" max="8"/>`; const K=$('optK') as HTMLInputElement; const T=$('optT') as HTMLInputElement; K.onchange=()=>{ opts.K=Number(K.value)||3; recompile(); }; T.onchange=()=>{ opts.T=Number(T.value)||3; recompile(); }; } }

function recompile(){ rules = pack.createRules(opts); grid = makeGrid(); draw(); showCaps(); }

packList.onchange = ()=>{ const id=packList.value; pack = builtins.find(p=> p.meta.id===id) || pack; opts = { K:3, T:3 }; syncOptsUI(); recompile(); };

loadBtn.onclick = async ()=>{
  try { const m = await loadPackFromURL(urlInput.value.trim()); pack = m; opts={}; syncOptsUI(); recompile(); }
  catch(e:any){ alert('Failed to load pack: '+e.message); }
};

randomBtn.onclick = ()=>{ const p=0.22; for(let y=0;y<height;y++) for(let x=0;x<width;x++) (grid as any).cells[y][x] = Math.random()<p? (pack.capabilities['multi-state']? new Monad({s:1}) : new Monad({alive:true})) : null; draw(); };

playBtn.onclick = ()=>{ playing=!playing; playBtn.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); };
stepBtn.onclick = ()=>{ if(!playing){ grid.tick(); draw(); } };
function loop(){ if(!playing) return; const t0=performance.now(); grid.tick(); draw(); const dt=Math.max(0, 220-(performance.now()-t0)); setTimeout(loop, dt); }

draw(); showCaps(); syncOptsUI();
```

---

## index-2w\.html (NEW — Rule Hub)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2W – Rule Packs + Capabilities</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input, select { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 2W (Rule Packs + Capabilities)</h1>
    <small>Plugin packs • Capability flags • Runtime discovery</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <label>Built‑in packs</label>
        <select id="pack"></select>
      </div>
      <div class="row">
        <input id="url" placeholder="https://…/my-pack.js" style="width:100%" />
        <button id="load">Load Pack</button>
      </div>
      <div class="row"><strong>Capabilities</strong></div>
      <div id="caps"></div>
      <div class="row"><strong>Options</strong></div>
      <form id="opts"></form>
      <div class="row">
        <label>Topology</label>
        <select id="topo"><option>Moore</option><option>VonNeumann</option></select>
        <label>Edges</label>
        <select id="edges"><option>Clip</option><option>Wrap</option></select>
      </div>
      <div class="row">
        <button id="random">Randomize</button>
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
      </div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="560" height="420"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/rulehub.ts"></script>
</body>
</html>
```

---

## README addendum (2W)

````md
### 2W – Plugin‑Style Rule Packs + Runtime Capability Flags

Run the Rule Hub:
```bash
npm i
npm run dev:2w
````

* Choose a **built‑in pack** (Conway, HighLife, Generations) or paste a **URL** to a pack module (ESM exporting a `RulePack`).
* The **Capabilities** table updates so UIs can enable/disable features safely.
* Some packs expose **Options** (e.g., `Generations: K, T`) — tweak and the grid recompiles.

**Authoring a Pack**
Create an ES module exporting `default: RulePack`:

```ts
export default {
  meta: { id: 'my-pack', title: 'My Rules', version: '1.0.0' },
  capabilities: { 'binary-state': true, 'multi-state': false, 'stochastic': true, 'weighted-neighborhood': false, 'custom-topology': false, 'tags-provider': false, 'metrics-provider': false },
  createRules(opts){ /* return interpreter rules */ },
  onTick(grid, step){ /* optional metrics */ }
};
```

Then load it via the **Load Pack** URL input.

```
```
