# MPL – Stage 2R (Auto Sweeps + Multi‑Objective Pareto Optimization)

Stage **2R** adds an automated **hyperparameter sweep** engine with **multi‑objective Pareto optimization** over batch outcomes. Define objectives (e.g., maximize alive\_final, minimize density\_std), set a budget, and 2R proposes candidate rules/params, evaluates them deterministically, and returns the **Pareto frontier** + exports.

> Builds on 2M (sweeps) and 2Q (analytics). All client‑side.

---

## What’s new in 2R

* `optimizer.ts` – Pareto utilities (dominance, non‑dominated sort), simple **(μ+λ)** evolution with mutation over B/S rules & seed
* `sweep2r.ts` – orchestrates runs, collects summaries, feeds optimizer
* `index-2r.html` – UI to pick objectives, budget, run the search, show **Pareto scatter** + table, export CSV/JSON

---

## Directory Tree (updated)

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ debug/
│  │  └─ trace.ts
│  ├─ web/
│  │  ├─ rulespec.ts
│  │  ├─ prng.ts
│  │  ├─ analytics.ts
│  │  ├─ sweep.ts
│  │  ├─ optimizer.ts        # NEW (Pareto + evolution)
│  │  └─ sweep2r.ts          # NEW (search orchestrator)
└─ index-2r.html             # NEW (2R UI)
```

Add this script to **package.json**:

```json
{
  "scripts": {
    "dev:2r": "vite --open index-2r.html"
  }
}
```

---

## src/web/optimizer.ts (NEW)

```ts
export type Objective = { key: string; dir: 'max' | 'min' };
export type Point = Record<string, number> & { id: string; rule: string; seed: number };

/** true if a dominates b for the given objectives */
export function dominates(a: Point, b: Point, objs: Objective[]): boolean {
  let better = 0, worse = 0;
  for (const o of objs){
    const av = a[o.key] ?? 0, bv = b[o.key] ?? 0;
    const cmp = o.dir==='max' ? (av - bv) : (bv - av);
    if (cmp > 0) better++; else if (cmp < 0) worse++;
  }
  return better>0 && worse===0;
}

export function paretoFront(points: Point[], objs: Objective[]): Point[] {
  const nd: Point[] = [];
  for (const p of points){
    let dominated = false;
    for (const q of points){ if (q===p) continue; if (dominates(q,p,objs)){ dominated = true; break; } }
    if (!dominated) nd.push(p);
  }
  return nd;
}

// --- simple (μ+λ) evolution over B/S rules (Life‑like) ---
export type Candidate = { rule: string; seed: number };

export function mutateRule(rule: string, rate=0.2): string {
  // rule as B…/S…; randomly toggle digits 0..8
  const up = rule.toUpperCase();
  const m = up.match(/B([0-8]*)\/S([0-8]*)/);
  const togg = (s: string)=>{
    const set = new Set(s.split('').filter(Boolean));
    for (let d=0; d<=8; d++) if (Math.random() < rate){ set.has(String(d))? set.delete(String(d)) : set.add(String(d)); }
    return Array.from(set).sort().join('');
  };
  if (!m) return 'B3/S23';
  const B = togg(m[1]); const S = togg(m[2]);
  return `B${B}/S${S}`;
}

export function crossoverRule(a: string, b: string): string {
  const pa = a.toUpperCase().match(/B([0-8]*)\/S([0-8]*)/); const pb = b.toUpperCase().match(/B([0-8]*)\/S([0-8]*)/);
  if (!pa || !pb) return a;
  const mix = (sa:string, sb:string) => {
    const A = new Set(sa.split('')); const B = new Set(sb.split(''));
    const out = new Set<string>();
    for (let d=0; d<=8; d++) if ((Math.random()<0.5?A:B).has(String(d))) out.add(String(d));
    return Array.from(out).sort().join('');
  };
  return `B${mix(pa[1],pb[1])}/S${mix(pa[2],pb[2])}`;
}

export function nextGen(muParents: Candidate[], lambda=8): Candidate[] {
  const kids: Candidate[] = [];
  for (let i=0; i<lambda; i++){
    const a = muParents[Math.floor(Math.random()*muParents.length)];
    const b = muParents[Math.floor(Math.random()*muParents.length)];
    const childRule = mutateRule(crossoverRule(a.rule, b.rule), 0.15);
    kids.push({ rule: childRule, seed: Math.floor(Math.random()*1e6) });
  }
  return kids;
}
```

---

## src/web/sweep2r.ts (NEW – orchestrator)

```ts
import { rulesFromSpec, parseBS } from './rulespec.js';
import { Grid2D } from '../runtime/grid.js';
import { Interpreter } from '../runtime/interpreter.js';
import { Moore } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { createRng } from './prng.js';
import type { Objective, Point, Candidate } from './optimizer.js';
import { paretoFront, nextGen } from './optimizer.js';

export type RunConfig = { W:number; H:number; steps:number; p:number };

export async function evalCandidate(c: Candidate, cfg: RunConfig): Promise<Point> {
  const spec = parseBS(c.rule);
  const intr = new Interpreter(rulesFromSpec(spec));
  const grid = new Grid2D(cfg.W, cfg.H, intr, new Moore());
  const rng = createRng(c.seed);
  for (let y=0;y<cfg.H;y++) for (let x=0;x<cfg.W;x++) (grid as any).cells[y][x] = rng.random() < cfg.p ? new Monad({alive:true}) : null;

  let alive_peak = 0; const densities:number[] = [];
  for (let t=0;t<cfg.steps;t++){
    let alive=0; for (let y=0;y<cfg.H;y++) for (let x=0;x<cfg.W;x++){ const m=(grid as any).cells[y][x]; if(m?.state?.alive) alive++; }
    alive_peak = Math.max(alive_peak, alive);
    densities.push(alive/(cfg.W*cfg.H));
    grid.tick();
  }
  const alive_final = densities[densities.length-1]*(cfg.W*cfg.H);
  const density_mean = densities.reduce((a,b)=>a+b,0)/densities.length;
  const mu = density_mean; const density_std = Math.sqrt(densities.reduce((s,v)=> s+(v-mu)*(v-mu),0)/densities.length);
  const survival_ratio = (alive_final)/(cfg.W*cfg.H);
  return { id:`${c.rule}@${c.seed}`, rule:c.rule, seed:c.seed, steps:cfg.steps, alive_final, density_mean, density_std, alive_peak, survival_ratio } as Point;
}

export async function search(initial: Candidate[], cfg: RunConfig, objs: Objective[], iters=3, lambda=10){
  let pool = [...initial];
  const all: Point[] = [];
  for (let gen=0; gen<iters; gen++){
    const evals = await Promise.all(pool.map(c => evalCandidate(c, cfg)));
    all.push(...evals);
    const frontier = paretoFront(all, objs);
    // select μ parents from frontier (or top-n by crowding distance – simplified here)
    const mu = Math.max(4, Math.min(frontier.length, 12));
    const parents = frontier.slice(0, mu).map(p => ({ rule: p.rule, seed: p.seed }));
    pool = nextGen(parents, lambda);
  }
  const frontier = paretoFront(all, objs);
  return { all, frontier };
}
```

---

## index-2r.html (NEW – Pareto UI)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2R – Auto Sweeps + Pareto</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; width:100%; height:420px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, select, input { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    table { width:100%; border-collapse: collapse; font-size:12px; }
    th, td { border-bottom:1px solid #1b2227; padding:6px 4px; text-align:left; }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 2R (Auto Sweeps + Pareto)</h1>
    <small>Multi‑objective search over B/S rules</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <label>Grid</label>
        <input id="W" type="number" value="40" min="10" max="120" />×
        <input id="H" type="number" value="30" min="10" max="120" />
      </div>
      <div class="row">
        <label>Steps</label><input id="steps" type="number" value="200" />
        <label>p(alive)</label><input id="p" type="number" value="0.22" step="0.01" />
      </div>
      <div class="row">
        <label>Objectives</label>
        <select id="obj1">
          <option value="alive_final,max">alive_final (max)</option>
          <option value="survival_ratio,max">survival_ratio (max)</option>
          <option value="density_mean,max">density_mean (max)</option>
          <option value="density_mean,min">density_mean (min)</option>
          <option value="density_std,min">density_std (min)</option>
        </select>
        <select id="obj2">
          <option value="density_std,min">density_std (min)</option>
          <option value="alive_final,max">alive_final (max)</option>
          <option value="survival_ratio,max">survival_ratio (max)</option>
        </select>
      </div>
      <div class="row">
        <label>Budget</label>
        <input id="iters" type="number" value="3" min="1" max="20" /> iters ×
        <input id="lambda" type="number" value="10" min="2" max="50" /> λ
      </div>
      <div class="row">
        <button id="run">Run Search</button>
        <button id="exportCSV">Export CSV</button>
        <small id="status"></small>
      </div>
    </aside>

    <section class="panel">
      <h3>Pareto Scatter</h3>
      <canvas id="scatter"></canvas>
      <h3>Frontier Table</h3>
      <table id="table"><thead><tr>
        <th>rule</th><th>seed</th><th>alive_final</th><th>density_mean</th><th>density_std</th><th>alive_peak</th><th>survival_ratio</th>
      </tr></thead><tbody></tbody></table>
    </section>
  </main>

  <script type="module">
    import { search } from '/src/web/sweep2r.ts';

    const W = document.getElementById('W');
    const H = document.getElementById('H');
    const steps = document.getElementById('steps');
    const p = document.getElementById('p');
    const obj1 = document.getElementById('obj1');
    const obj2 = document.getElementById('obj2');
    const iters = document.getElementById('iters');
    const lambda = document.getElementById('lambda');
    const runBtn = document.getElementById('run');
    const status = document.getElementById('status');
    const exportCSV = document.getElementById('exportCSV');
    const scatter = document.getElementById('scatter').getContext('2d');

    const tableBody = document.querySelector('#table tbody');

    function drawScatter(ctx, pts, keyX, keyY, front){
      const w=ctx.canvas.width, h=ctx.canvas.height; ctx.clearRect(0,0,w,h);
      const xs=pts.map(p=>p[keyX]), ys=pts.map(p=>p[keyY]);
      const minX=Math.min(...xs), maxX=Math.max(...xs); const minY=Math.min(...ys), maxY=Math.max(...ys);
      const pad=20, sx=(w-2*pad)/(maxX-minX||1), sy=(h-2*pad)/(maxY-minY||1);
      // all points
      ctx.fillStyle='rgba(130,180,255,0.6)';
      for(const pt of pts){ const x=pad+(pt[keyX]-minX)*sx, y=h-(pad+(pt[keyY]-minY)*sy); ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); }
      // frontier
      ctx.fillStyle='rgba(239,71,111,0.9)';
      for(const pt of front){ const x=pad+(pt[keyX]-minX)*sx, y=h-(pad+(pt[keyY]-minY)*sy); ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); }
    }

    function toCSV(rows, header){
      const esc=v=> typeof v==='string' && v.includes(',') ? '"'+v.replace(/"/g,'""')+'"' : v;
      return [header.join(','), ...rows.map(r => header.map(h=> esc(r[h] ?? '')).join(','))].join('\n');
    }

    runBtn.onclick = async () => {
      status.textContent = 'Running…';
      const [k1,dir1] = obj1.value.split(',');
      const [k2,dir2] = obj2.value.split(',');
      const objs = [ {key:k1, dir:dir1}, {key:k2, dir:dir2} ];
      const cfg = { W:Number(W.value)||40, H:Number(H.value)||30, steps:Number(steps.value)||200, p:Number(p.value)||0.22 };
      // seed parents (start with common variants)
      const parents = [ 'B3/S23','B36/S23','B34/S34','B2/S' ].map(rule => ({ rule, seed: Math.floor(Math.random()*1e6) }));
      const { all, frontier } = await search(parents, cfg, objs, Number(iters.value)||3, Number(lambda.value)||10);
      status.textContent = `Evaluated ${all.length} candidates; frontier size ${frontier.length}.`;
      drawScatter(scatter, all, k1, k2, frontier);
      tableBody.innerHTML = '';
      for (const r of frontier){
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${r.rule}</td><td>${r.seed}</td><td>${r.alive_final.toFixed(0)}</td><td>${r.density_mean.toFixed(4)}</td><td>${r.density_std.toFixed(4)}</td><td>${r.alive_peak.toFixed(0)}</td><td>${r.survival_ratio.toFixed(4)}</td>`;
        tableBody.appendChild(tr);
      }
    };

    exportCSV.onclick = () => {
      const rows = Array.from(tableBody.querySelectorAll('tr')).map(tr => {
        const tds = tr.querySelectorAll('td');
        return { rule: tds[0].textContent, seed: tds[1].textContent, alive_final: tds[2].textContent, density_mean: tds[3].textContent, density_std: tds[4].textContent, alive_peak: tds[5].textContent, survival_ratio: tds[6].textContent };
      });
      const header = ['rule','seed','alive_final','density_mean','density_std','alive_peak','survival_ratio'];
      const csv = toCSV(rows, header); const blob = new Blob([csv],{type:'text/csv'});
      const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download = `pareto-${Date.now()}.csv`; a.click(); URL.revokeObjectURL(a.href);
    };
  </script>
</body>
</html>
```

---

## README addendum (2R)

````md
### 2R – Auto Sweeps + Pareto Optimization

Run the Pareto UI:
```bash
npm i
npm run dev:2r
````

* Choose **Objectives** (e.g., `alive_final (max)` vs `density_std (min)`).
* Set **Budget** (iterations × λ children per generation).
* Click **Run Search** to evaluate candidates and display the **Pareto frontier**.
* **Export CSV** of the current frontier.

**Notes**

* The evolution strategy is intentionally simple (μ+λ with crossover+mutation on B/S digits) and deterministic seeding per candidate.
* Replace the parent seed list or wire to your 2M sweep results for smarter initialization.

```
```
