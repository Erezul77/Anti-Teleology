# MPL Stage 2C – Trace Debugger Patch

This patch adds the **trace debugger** to your Stage‑2 project and updates the demo to print events. Copy these files over your existing ones.

## What’s included

* `src/debug/trace.ts` — flexible trace event type + `Tracer`
* `src/runtime/interpreter.ts` — emits `tick-start`, `rule`, `assign`, `tick-end`; exposes `env.mut` helper for traced writes
* `src/runtime/grid.ts` — forwards a `Tracer` into the interpreter and tags events with `meta.coord`
* `examples/run.ts` — prints ASCII grid **and** the trace each step
* README note: 2C enabled

---

## src/debug/trace.ts

```ts
export type TraceEvent = {
  type: 'tick-start' | 'rule' | 'assign' | 'tick-end';
  [k: string]: any; // flexible payload (e.g., step, index, taken, path, op, value, meta)
};

export class Tracer {
  events: TraceEvent[] = [];
  clear(){ this.events = []; }
  push(e: TraceEvent){ this.events.push(e); }
  take(): TraceEvent[] { const out = this.events; this.events = []; return out; }
}
```

---

## src/runtime/interpreter.ts

```ts
import type { Tracer } from '../debug/trace.js';

export type Context = {
  state: Record<string, any>;
  memory: Record<string, any>;
  step: number;
};

export type NeighborSnapshot = { state: Record<string, any>; memory: Record<string, any> };

export class Mut {
  constructor(private target: Context, private tracer?: Tracer, private meta?: any) {}
  set(path: string, value: any){
    const { root, keys } = parsePath(path);
    const base = root === 'memory' ? this.target.memory : this.target.state;
    const { parent, key } = ensurePath(base, keys);
    parent[key] = value;
    this.tracer?.push({ type: 'assign', path, op: '=', value, meta: this.meta });
  }
  add(path: string, delta: number){
    const { root, keys } = parsePath(path);
    const base = root === 'memory' ? this.target.memory : this.target.state;
    const { parent, key } = ensurePath(base, keys);
    const cur = Number(parent[key] ?? 0);
    const next = cur + Number(delta);
    parent[key] = next;
    this.tracer?.push({ type: 'assign', path, op: '+=', value: delta, meta: this.meta });
  }
  sub(path: string, delta: number){ this.add(path, -Number(delta)); }
}

export type Env = {
  neighbors: NeighborSnapshot[];
  countNeighbors: (pred: (n: NeighborSnapshot) => boolean) => number;
  sumNeighbors: (map: (n: NeighborSnapshot) => number) => number;
  /** Optional write helper for traced assignments */
  mut?: Mut;
  /** Optional metadata (e.g., coordinates) propagated to trace */
  meta?: any;
};

export type Rule = {
  kind: 'if' | 'unless';
  condition: (ctx: Context, env?: Env) => boolean;
  then: (ctx: Context, env?: Env) => void;
  otherwise?: (ctx: Context, env?: Env) => void;
};

export class Interpreter {
  rules: Rule[];
  constructor(rules: Rule[]) { this.rules = rules; }

  tick(contexts: Context[], envs?: (Env | undefined)[], tracer?: Tracer): Context[] {
    const out: Context[] = [];
    for (let i = 0; i < contexts.length; i++) {
      const ctx = contexts[i];
      const baseEnv = envs?.[i];

      const nextState = { ...ctx.state };
      const nextMemory = { ...ctx.memory };
      const newCtx: Context = { state: nextState, memory: nextMemory, step: ctx.step + 1 };

      const env: Env = {
        neighbors: baseEnv?.neighbors ?? [],
        countNeighbors: baseEnv?.countNeighbors ?? (() => 0),
        sumNeighbors: baseEnv?.sumNeighbors ?? (() => 0),
        meta: (baseEnv as any)?.meta,
        mut: new Mut(newCtx, tracer, (baseEnv as any)?.meta)
      };

      tracer?.push({ type: 'tick-start', step: newCtx.step, meta: env.meta });

      for (let rIndex = 0; rIndex < this.rules.length; rIndex++) {
        const r = this.rules[rIndex];
        const cond = !!r.condition(ctx, env);
        const taken = (r.kind === 'if' && cond) || (r.kind === 'unless' && !cond);
        tracer?.push({ type: 'rule', index: rIndex, condition: cond, taken, meta: env.meta });
        if (taken) r.then(newCtx, env); else if (r.otherwise) r.otherwise(newCtx, env);
      }

      tracer?.push({ type: 'tick-end', step: newCtx.step, meta: env.meta });
      out.push(newCtx);
    }
    return out;
  }
}

function parsePath(path: string): { root: 'state'|'memory'; keys: string[] }{
  if (path.startsWith('state.')) return { root: 'state', keys: path.slice(6).split('.') };
  if (path.startsWith('memory.')) return { root: 'memory', keys: path.slice(7).split('.') };
  // default to state if no prefix
  return { root: 'state', keys: path.split('.') };
}
function ensurePath(base: any, keys: string[]): { parent: any; key: string }{
  let parent = base; for (let i=0;i<keys.length-1;i++){ const k=keys[i]; if (typeof parent[k] !== 'object' || parent[k]==null) parent[k] = {}; parent = parent[k]; }
  const key = keys[keys.length-1]; return { parent, key };
}
```

---

## src/runtime/grid.ts

```ts
import type { Interpreter } from './interpreter.js';
import type { Env, Context, NeighborSnapshot } from './interpreter.js';
import { Monad } from './monad.js';
import type { Topology, Coord } from './topology/index.js';
import type { Tracer } from '../debug/trace.js';

function snap(m: Monad | null): NeighborSnapshot {
  if (!m) return { state: {}, memory: {} };
  return { state: { ...m.state }, memory: { ...m.memory } };
}

export class Grid2D {
  width: number; height: number;
  cells: (Monad | null)[][];
  stepCount = 0;
  interpreter: Interpreter;
  topology: Topology;

  constructor(width: number, height: number, interpreter: Interpreter, topology: Topology) {
    this.width = width; this.height = height; this.interpreter = interpreter; this.topology = topology;
    this.cells = Array.from({length: height}, () => Array.from({length: width}, () => null));
  }

  inBounds(c: Coord): boolean { return c.x >= 0 && c.x < this.width && c.y >= 0 && c.y < this.height; }

  place(c: Coord, m: Monad) { if (this.inBounds(c)) this.cells[c.y][c.x] = m; }

  tick(tracer?: Tracer): void {
    const step = this.stepCount;
    const contexts: Context[] = [];
    const envs: Env[] = [];
    const positions: Coord[] = [];

    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        const m = this.cells[y][x];
        if (!m) continue;
        positions.push({ x, y });
        contexts.push({ state: { ...m.state }, memory: { ...m.memory }, step });
        const neighCoords = this.topology.neighbors({ x, y }).filter(c => this.inBounds(c));
        const neighSnaps = neighCoords.map(c => snap(this.cells[c.y][c.x]));
        const env: Env = {
          neighbors: neighSnaps,
          countNeighbors: (pred) => neighSnaps.reduce((acc, n) => acc + (pred(n) ? 1 : 0), 0),
          sumNeighbors: (map) => neighSnaps.reduce((acc, n) => acc + (map(n) || 0), 0),
          meta: { coord: { x, y } }
        };
        envs.push(env);
      }
    }

    const next = this.interpreter.tick(contexts, envs, tracer);
    next.forEach((ctx, i) => {
      const pos = positions[i];
      const m = this.cells[pos.y][pos.x];
      if (m) { m.state = ctx.state; m.memory = ctx.memory; }
    });

    this.stepCount += 1;
  }

  snapshot(): any {
    return this.cells.map(row => row.map(m => m ? { state: { ...m.state }, memory: { ...m.memory } } : null));
  }

  toAscii(aliveKey: string = 'alive'): string {
    return this.cells.map(row => row.map(m => (m && m.state?.[aliveKey]) ? '█' : '·').join('')).join('\n');
  }
}
```

---

## examples/run.ts

```ts
import { Interpreter, type Rule } from '../src/runtime/interpreter.js';
import { Grid2D } from '../src/runtime/grid.js';
import { Monad } from '../src/runtime/monad.js';
import { Moore } from '../src/runtime/topology/index.js';
import { Tracer } from '../src/debug/trace.js';

// Conway's Game of Life using neighbor-aware env + tracing
const rules: Rule[] = [
  {
    kind: 'if',
    condition: (ctx, env) => !!ctx.state.alive,
    then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n < 2 || n > 3) env?.mut?.set('state.alive', false); // traced assign
    }
  },
  {
    kind: 'unless',
    condition: (ctx, env) => !!ctx.state.alive,
    then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n === 3) env?.mut?.set('state.alive', true); // traced assign
    }
  }
];

const interpreter = new Interpreter(rules);
const W=10, H=10;
const grid = new Grid2D(W, H, interpreter, new Moore());

// Seed a vertical blinker
grid.place({x:4, y:4}, new Monad({ alive: true }));
grid.place({x:4, y:5}, new Monad({ alive: true }));
grid.place({x:4, y:6}, new Monad({ alive: true }));

const tracer = new Tracer();

function print(step: number){
  console.log(`\nStep ${step}\n` + grid.toAscii('alive'));
  const events = tracer.take();
  if (events.length) console.log('Trace:', JSON.stringify(events, null, 2));
}

print(0);
for (let i=1; i<=6; i++){
  grid.tick(tracer);
  print(i);
}
```

---

## README addendum (2C)

```md
### 2C – Trace Debugger
Create a `Tracer` and pass it to `grid.tick(tracer)`. Use `env.mut.set('state.path', value)` (or `.add/.sub`) inside rules to record `assign` events.
```
