# MPL – Stage 2M (Reproducible A/B + Delta Heatmap + CSV)

This stage builds on **2K** and adds:

* **Deterministic PRNG** with a shared seed for reproducible A/B runs
* **Synchronized seeding**: apply a seed to both grids and randomize them identically
* **Delta heatmap** (A–B) canvas in the sidebar
* **CSV export** of A/B metrics per tick (step, alive, density)

Run the dual‑grid UI:

```bash
npm i
npm run dev:2k
```

Open the dev URL (usually [http://localhost:5173/index-2k.html](http://localhost:5173/index-2k.html)).

---

## What’s new in 2M

* `src/web/prng.ts` – mulberry32 PRNG (deterministic, fast, tiny)
* `index-2k.html` – seed controls, **Delta** canvas, **Export CSV** button
* `src/web/web-multigrid.ts` – uses PRNG for randomization, logs metrics, renders delta heatmap, exports CSV

---

## Updated Directory Tree

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ debug/
│  │  └─ trace.ts
│  ├─ emotional/
│  │  └─ types.ts
│  ├─ utils/
│  │  └─ io.ts
│  └─ web/
│     ├─ web-main.ts
│     ├─ web-multigrid.ts     # UPDATED for 2L
│     ├─ prng.ts              # NEW deterministic RNG
│     ├─ colors.ts
│     ├─ session.ts
│     └─ rulespec.ts
└─ examples/
   └─ run.ts
```

> Keep using `npm run dev:2k` to launch `index-2k.html`.

---

## src/web/prng.ts (NEW)

```ts
// Tiny deterministic PRNG (mulberry32)
export function createRng(seed: number){
  let t = seed >>> 0;
  function random(){
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296; // [0,1)
  }
  function int(min: number, max: number){
    return Math.floor(random() * (max - min + 1)) + min;
  }
  return { random, int };
}
```

---

## index-2k.html (UPDATED – seed controls, delta canvas, CSV export)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2L – Multi‑Grid (Reproducible A/B + Delta + CSV)</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 340px 1fr 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    label { color:var(--muted); }
    button, select, input, textarea { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    button { cursor:pointer; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
    .gridHead { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
  </style>
</head>
<body>
  <header>
    <h1>MPL Stage 2L – Reproducible A/B + Delta Heatmap + CSV</h1>
    <small>Deterministic seeds · Side‑by‑side delta · Metrics export</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="stepA">Step A</button>
        <button id="stepB">Step B</button>
        <button id="reset">Reset</button>
      </div>
      <div class="row">
        <label>Global speed</label>
        <input id="speed" type="range" min="50" max="800" value="300" />
        <small id="speedLabel"></small>
      </div>
      <div class="row">
        <label>Seed</label>
        <input id="seed" type="number" value="12345" />
        <button id="applySeedBoth">Apply to both</button>
        <button id="seedBoth">Seed both (randomize)</button>
      </div>
      <div class="row">
        <label>Comparator</label>
        <select id="compareMode">
          <option>Summary</option>
          <option>Delta (A-B)</option>
        </select>
        <button id="exportA">Export A</button>
        <button id="exportB">Export B</button>
        <button id="exportCSV">Export CSV</button>
        <input id="importA" type="file" accept="application/json" />
        <input id="importB" type="file" accept="application/json" />
      </div>
      <div class="row">
        <small>Tip: click on either canvas to toggle cells.</small>
      </div>
      <hr />
      <div class="row" id="summary"></div>
      <div class="row"><small id="status"></small></div>
      <div class="row">
        <label>Delta (A-B)</label>
        <canvas id="delta" width="320" height="240"></canvas>
      </div>
    </aside>

    <section class="panel">
      <div class="gridHead"><strong>Grid A</strong><small id="metaA"></small></div>
      <canvas id="gridA" width="640" height="480"></canvas>
      <div class="row">
        <label>Preset</label>
        <select id="presetA"></select>
        <label>B/S</label>
        <input id="bsA" value="B3/S23" />
        <button id="applyA">Apply Rule</button>
      </div>
      <div class="row">
        <label>Topo</label>
        <select id="topoA"><option>Moore</option><option>VonNeumann</option></select>
        <label>Edges</label>
        <select id="edgesA"><option>Clip</option><option>Wrap</option></select>
        <label>W×H</label>
        <input id="wA" type="number" value="40" min="5" max="200" />×
        <input id="hA" type="number" value="30" min="5" max="200" />
        <button id="resizeA">Resize</button>
      </div>
      <div class="row">
        <button id="gliderA">Glider</button>
        <button id="randomA">Randomize</button>
        <button id="clearA">Clear</button>
      </div>
    </section>

    <section class="panel">
      <div class="gridHead"><strong>Grid B</strong><small id="metaB"></small></div>
      <canvas id="gridB" width="640" height="480"></canvas>
      <div class="row">
        <label>Preset</label>
        <select id="presetB"></select>
        <label>B/S</label>
        <input id="bsB" value="B36/S23" />
        <button id="applyB">Apply Rule</button>
      </div>
      <div class="row">
        <label>Topo</label>
        <select id="topoB"><option>Moore</option><option>VonNeumann</option></select>
        <label>Edges</label>
        <select id="edgesB"><option>Clip</option><option>Wrap</option></select>
        <label>W×H</label>
        <input id="wB" type="number" value="40" min="5" max="200" />×
        <input id="hB" type="number" value="30" min="5" max="200" />
        <button id="resizeB">Resize</button>
      </div>
      <div class="row">
        <button id="gliderB">Glider</button>
        <button id="randomB">Randomize</button>
        <button id="clearB">Clear</button>
      </div>
    </section>
  </main>
  <script type="module" src="/src/web/web-multigrid.ts"></script>
</body>
</html>
```

---

## src/web/web-multigrid.ts (UPDATED – PRNG, delta heatmap, CSV)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { Tracer } from '../debug/trace.js';
import { PRESETS, parseBS, rulesFromSpec } from './rulespec.js';
import { SessionManager } from './session.js';
import { createRng } from './prng.js';

const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;

// Canvas & UI refs
const cA = $('gridA') as HTMLCanvasElement; const ctxA = cA.getContext('2d')!;
const cB = $('gridB') as HTMLCanvasElement; const ctxB = cB.getContext('2d')!;
const deltaCanvas = $('delta') as HTMLCanvasElement; const dtx = deltaCanvas.getContext('2d')!;
const playBtn = $('play'); const stepA = $('stepA'); const stepB = $('stepB');
const speed = $('speed') as HTMLInputElement; const speedLabel = $('speedLabel');
const compareMode = $('compareMode') as HTMLSelectElement; const summary = $('summary'); const status = $('status');
const seedInput = $('seed') as HTMLInputElement; const applySeedBoth = $('applySeedBoth'); const seedBoth = $('seedBoth');

// Per-grid controls
const presetA = $('presetA') as HTMLSelectElement; const bsA = $('bsA') as HTMLInputElement; const applyA = $('applyA');
const topoA = $('topoA') as HTMLSelectElement; const edgesA = $('edgesA') as HTMLSelectElement; const wA = $('wA') as HTMLInputElement; const hA = $('hA') as HTMLInputElement; const resizeA = $('resizeA');
const gliderA = $('gliderA'); const randomA = $('randomA'); const clearA = $('clearA');

const presetB = $('presetB') as HTMLSelectElement; const bsB = $('bsB') as HTMLInputElement; const applyB = $('applyB');
const topoB = $('topoB') as HTMLSelectElement; const edgesB = $('edgesB') as HTMLSelectElement; const wB = $('wB') as HTMLInputElement; const hB = $('hB') as HTMLInputElement; const resizeB = $('resizeB');
const gliderB = $('gliderB'); const randomB = $('randomB'); const clearB = $('clearB');

const exportA = $('exportA'); const exportB = $('exportB'); const exportCSV = $('exportCSV');
const importA = $('importA') as HTMLInputElement; const importB = $('importB') as HTMLInputElement;

// Populate presets
for (const k of Object.keys(PRESETS)){
  const optA = document.createElement('option'); optA.textContent = k; presetA.appendChild(optA);
  const optB = document.createElement('option'); optB.textContent = k; presetB.appendChild(optB);
}

// RNG state (deterministic)
let seed = Number(seedInput.value) || 12345;
let rngA = createRng(seed);
let rngB = createRng(seed);

// Helpers
function makeTopo(name: string, edges: string, size: () => {width:number;height:number}){
  const base = name === 'VonNeumann' ? new VonNeumann() : new Moore();
  return edges === 'Wrap' ? new Toroidal(base, size) : base;
}

function drawGrid(ctx: CanvasRenderingContext2D, grid: Grid2D){
  const cell = Math.floor(Math.min(ctx.canvas.width/grid.width, ctx.canvas.height/grid.height));
  ctx.fillStyle = '#0a0e11'; ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
  ctx.fillStyle = '#e8eef2';
  for (let y=0;y<grid.height;y++) for (let x=0;x<grid.width;x++){
    const m = (grid as any).cells[y][x];
    if (m && m.state?.alive) ctx.fillRect(x*cell, y*cell, cell, cell);
  }
}

function stats(grid: Grid2D){
  let alive = 0; for (let y=0;y<grid.height;y++) for (let x=0;x<grid.width;x++){ const m=(grid as any).cells[y][x]; if (m?.state?.alive) alive++; }
  const cells = grid.width * grid.height; const density = cells ? (alive / cells) : 0;
  return { alive, density };
}

function snapshot(grid: Grid2D, topoName: string){
  return { schema:'mpl-stage-2@1', kind:'Grid2D', width: grid.width, height: grid.height, step: (grid as any).stepCount, topology: topoName,
    cells: (grid as any).cells.map((row:any[])=> row.map((m:any)=> m? { state:{...m.state}, memory:{...m.memory} } : null)) };
}

// Delta heatmap (A - B): A-only = red, B-only = blue, same = dark
function drawDelta(A: Grid2D, B: Grid2D){
  const cell = Math.floor(Math.min(deltaCanvas.width/Math.max(A.width,B.width), deltaCanvas.height/Math.max(A.height,B.height)));
  dtx.fillStyle = '#0a0e11'; dtx.fillRect(0,0,deltaCanvas.width,deltaCanvas.height);
  for (let y=0; y<Math.max(A.height,B.height); y++){
    for (let x=0; x<Math.max(A.width,B.width); x++){
      const a = (A as any).cells?.[y]?.[x]; const b = (B as any).cells?.[y]?.[x];
      const av = a?.state?.alive ? 1 : 0; const bv = b?.state?.alive ? 1 : 0;
      const d = av - bv; if (d === 0) continue;
      dtx.fillStyle = d > 0 ? '#ef476f' : '#2a6fef';
      dtx.fillRect(x*cell, y*cell, cell, cell);
    }
  }
}

// State
let playing = false; let msPerStep = Number(speed.value);
function setSpeedLabel(){ speedLabel.textContent = `${msPerStep} ms/step`; } setSpeedLabel();

// Build worlds
function rulesFromInput(bs: string){ return rulesFromSpec(PRESETS[bs] ? PRESETS[bs] : parseBS(bs)); }
function makeWorld(opts: {W:number,H:number, topo:string, edges:string, bs:string}){
  const intr = new Interpreter(rulesFromInput(opts.bs));
  const grid = new Grid2D(opts.W, opts.H, intr, makeTopo(opts.topo, opts.edges, () => ({ width: opts.W, height: opts.H })));
  return { grid, intr };
}

let A = makeWorld({ W:40, H:30, topo: topoA.value, edges: edgesA.value, bs: bsA.value });
let B = makeWorld({ W:40, H:30, topo: topoB.value, edges: edgesB.value, bs: bsB.value });

const tracerA = new Tracer(); const tracerB = new Tracer();

// Metrics log
type Row = { step:number; aliveA:number; densityA:number; aliveB:number; densityB:number };
const rows: Row[] = [];
let step = 0;

function render(){
  drawGrid(ctxA, A.grid); drawGrid(ctxB, B.grid);
  const sa = stats(A.grid), sb = stats(B.grid);
  summary.textContent = `A: alive=${sa.alive} (${(sa.density*100).toFixed(1)}%)  |  B: alive=${sb.alive} (${(sb.density*100).toFixed(1)}%)  |  Δ=${sa.alive - sb.alive}`;
  if (compareMode.value.startsWith('Delta')) drawDelta(A.grid, B.grid);
  else { dtx.fillStyle = '#0a0e11'; dtx.fillRect(0,0,deltaCanvas.width,deltaCanvas.height); }
}

function tickBoth(){
  A.grid.tick(tracerA); B.grid.tick(tracerB); step++;
  const sa = stats(A.grid), sb = stats(B.grid);
  rows.push({ step, aliveA: sa.alive, densityA: sa.density, aliveB: sb.alive, densityB: sb.density });
  render();
}

// Loop
function loop(){ if (!playing) return; const t0 = performance.now(); tickBoth(); const dt = Math.max(0, msPerStep - (performance.now()-t0)); setTimeout(loop, dt); }

// Global controls
playBtn.onclick = () => { playing = !playing; playBtn.textContent = playing ? '⏸ Pause' : '▶︎ Play'; if (playing) loop(); };
stepA.onclick = () => { if (!playing) { A.grid.tick(tracerA); step++; const sa = stats(A.grid), sb = stats(B.grid); rows.push({ step, aliveA: sa.alive, densityA: sa.density, aliveB: sb.alive, densityB: sb.density }); render(); } };
stepB.onclick = () => { if (!playing) { B.grid.tick(tracerB); step++; const sa = stats(A.grid), sb = stats(B.grid); rows.push({ step, aliveA: sa.alive, densityA: sa.density, aliveB: sb.alive, densityB: sb.density }); render(); } };
$('reset').onclick = () => { A = makeWorld({ W:Number(wA.value)||40, H:Number(hA.value)||30, topo: topoA.value, edges: edgesA.value, bs: bsA.value }); B = makeWorld({ W:Number(wB.value)||40, H:Number(hB.value)||30, topo: topoB.value, edges: edgesB.value, bs: bsB.value }); rows.length = 0; step = 0; render(); };

speed.oninput = () => { msPerStep = Number(speed.value); setSpeedLabel(); };

// PRNG controls
applySeedBoth.onclick = () => { seed = Number(seedInput.value) || 12345; rngA = createRng(seed); rngB = createRng(seed); status.textContent = `Applied seed ${seed} to both RNGs`; };
seedBoth.onclick = () => { seed = Number(seedInput.value) || 12345; rngA = createRng(seed); rngB = createRng(seed); // Randomize both identically
  const p = 0.22;
  for (let y=0;y<A.grid.height;y++) for (let x=0;x<A.grid.width;x++) (A.grid as any).cells[y][x] = rngA.random()<p ? new Monad({alive:true}) : null;
  for (let y=0;y<B.grid.height;y++) for (let x=0;x<B.grid.width;x++) (B.grid as any).cells[y][x] = rngB.random()<p ? new Monad({alive:true}) : null;
  render(); status.textContent = `Seeded both grids with seed ${seed}`; };

// Per-grid wiring (A)
applyA.onclick = () => { try { A = makeWorld({ W:A.grid.width, H:A.grid.height, topo: topoA.value, edges: edgesA.value, bs: bsA.value }); render(); status.textContent = 'Applied rule to A'; } catch(e:any){ status.textContent = e.message; } };
resizeA.onclick = () => { A = makeWorld({ W:Number(wA.value)||A.grid.width, H:Number(hA.value)||A.grid.height, topo: topoA.value, edges: edgesA.value, bs: bsA.value }); render(); };
clearA.onclick = () => { for (let y=0;y<A.grid.height;y++) for (let x=0;x<A.grid.width;x++) (A.grid as any).cells[y][x]=null; render(); };
randomA.onclick = () => { const p=0.22; for (let y=0;y<A.grid.height;y++) for (let x=0;x<A.grid.width;x++) (A.grid as any).cells[y][x] = rngA.random()<p? new Monad({alive:true}) : null; render(); };
gliderA.onclick = () => { const cx=Math.floor(A.grid.width/2), cy=Math.floor(A.grid.height/2); const set=(x:number,y:number)=> (A.grid as any).cells[y][x]=new Monad({alive:true}); set(cx+1,cy); set(cx+2,cy+1); set(cx,cy+2); set(cx+1,cy+2); set(cx+2,cy+2); render(); };

// Per-grid wiring (B)
applyB.onclick = () => { try { B = makeWorld({ W:B.grid.width, H:B.grid.height, topo: topoB.value, edges: edgesB.value, bs: bsB.value }); render(); status.textContent = 'Applied rule to B'; } catch(e:any){ status.textContent = e.message; } };
resizeB.onclick = () => { B = makeWorld({ W:Number(wB.value)||B.grid.width, H:Number(hB.value)||B.grid.height, topo: topoB.value, edges: edgesB.value, bs: bsB.value }); render(); };
clearB.onclick = () => { for (let y=0;y<B.grid.height;y++) for (let x=0;x<B.grid.width;x++) (B.grid as any).cells[y][x]=null; render(); };
randomB.onclick = () => { const p=0.22; for (let y=0;y<B.grid.height;y++) for (let x=0;x<B.grid.width;x++) (B.grid as any).cells[y][x] = rngB.random()<p? new Monad({alive:true}) : null; render(); };
gliderB.onclick = () => { const cx=Math.floor(B.grid.width/2), cy=Math.floor(B.grid.height/2); const set=(x:number,y:number)=> (B.grid as any).cells[y][x]=new Monad({alive:true}); set(cx+1,cy); set(cx+2,cy+1); set(cx,cy+2); set(cx+1,cy+2); set(cx+2,cy+2); render(); };

// Canvas click to toggle
function toggleAt(ev: MouseEvent, grid: Grid2D, ctx: CanvasRenderingContext2D){
  const rect = (ctx.canvas as HTMLCanvasElement).getBoundingClientRect();
  const cell = Math.floor(Math.min(ctx.canvas.width/grid.width, ctx.canvas.height/grid.height));
  const x = Math.floor((ev.clientX - rect.left) / cell);
  const y = Math.floor((ev.clientY - rect.top) / cell);
  if (x<0||y<0||x>=grid.width||y>=grid.height) return;
  const cur = (grid as any).cells[y][x];
  (grid as any).cells[y][x] = cur ? (cur.state.alive? null : new Monad({alive:true})) : new Monad({alive:true});
  render();
}

cA.addEventListener('click', (e)=> toggleAt(e, A.grid, ctxA));
cB.addEventListener('click', (e)=> toggleAt(e, B.grid, ctxB));

// Export/Import JSON
function downloadJSON(obj: any, filename: string){ const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href); }
exportA.onclick = () => downloadJSON(snapshot(A.grid, topoA.value), `gridA-${Date.now()}.json`);
exportB.onclick = () => downloadJSON(snapshot(B.grid, topoB.value), `gridB-${Date.now()}.json`);
importA.onchange = async () => { const f = importA.files?.[0]; if(!f) return; const s = JSON.parse(await f.text()); A = makeWorld({ W:s.width, H:s.height, topo:s.topology, edges: edgesA.value, bs: bsA.value }); for(let y=0;y<s.height;y++) for(let x=0;x<s.width;x++){ const c=s.cells[y][x]; if(c) (A.grid as any).cells[y][x]=new Monad(c.state,c.memory);} render(); };
importB.onchange = async () => { const f = importB.files?.[0]; if(!f) return; const s = JSON.parse(await f.text()); B = makeWorld({ W:s.width, H:s.height, topo:s.topology, edges: edgesB.value, bs: bsB.value }); for(let y=0;y<s.height;y++) for(let x=0;x<s.width;x++){ const c=s.cells[y][x]; if(c) (B.grid as any).cells[y][x]=new Monad(c.state,c.memory);} render(); };

// Export CSV of metrics
function downloadCSV(text: string, filename: string){ const blob = new Blob([text], {type:'text/csv'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href); }
exportCSV.onclick = () => {
  const header = 'step,aliveA,densityA,aliveB,densityB\n';
  const body = rows.map(r => `${r.step},${r.aliveA},${r.densityA.toFixed(6)},${r.aliveB},${r.densityB.toFixed(6)}`).join('\n');
  downloadCSV(header + body, `ab-metrics-${Date.now()}.csv`);
};

// Comparator switch
compareMode.onchange = () => render();

// Initial draw
render();
```

---

## README addendum (2L)

```md
### 2M – Reproducible A/B + Delta Heatmap + CSV

- **Seed controls** (sidebar): set a numeric seed and click **Apply to both** to sync RNGs. Click **Seed both (randomize)** to fill both grids with identical random states.
- **Delta heatmap**: choose **Comparator → Delta (A-B)** to see where A has cells (red) and B has cells (blue).
- **CSV export**: **Export CSV** downloads per‑tick metrics for A & B.

Tip: for perfectly comparable A/B, sync seeds **and** keep W×H identical.
```
