# MPL – Stage 2V (Schema Validator + Backward‑Compat Loader + Integrity Warnings)

Stage **2V** makes bundles safer and future‑proof:

* **Strict schema validator** for `mpl-bundle@1` with helpful error messages
* **Backward‑compat loader** that accepts older/loose formats (e.g., raw `snapshot.json`) and auto‑migrates
* **Integrity & trust UI**: SHA‑256 verification, warning badges, and one‑click **Repack** into a clean `.mplbundle`

> Builds on 2U (compressed/chunked links) and 2S (bundles). Everything is client‑side.

---

## Directory Tree (updated)

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ debug/
│  │  └─ trace.ts
│  ├─ web/
│  │  ├─ rulespec.ts
│  │  ├─ prng.ts
│  │  ├─ session.ts
│  │  ├─ sweep.ts
│  │  ├─ analytics.ts
│  │  ├─ optimizer.ts
│  │  ├─ sweep2r.ts
│  │  ├─ bundle.ts
│  │  ├─ hash.ts
│  │  ├─ compress.ts
│  │  ├─ share.ts
│  │  ├─ share2u.ts
│  │  ├─ gist.ts
│  │  ├─ schema.ts        # NEW: schema + validator + migrator
│  │  └─ repro-2v.ts      # NEW: validator‑aware loader UI
└─ index-2v.html          # NEW: Stage 2V launcher
```

Add this script to **package.json**:

```json
{
  "scripts": {
    "dev:2v": "vite --open index-2v.html"
  }
}
```

---

## src/web/schema.ts (NEW — schema + validator + migrator)

```ts
import type { Manifest } from './bundle.js';

export type Validation = {
  ok: boolean;
  errors: string[];
  warnings: string[];
  manifest?: Manifest; // normalized manifest if ok
};

// Narrow checks
const isNum = (v:any) => typeof v === 'number' && isFinite(v);
const isStr = (v:any) => typeof v === 'string' && v.length > 0;
const oneOf = <T extends string>(v:any, xs: T[]): v is T => xs.includes(v);

// Loose snapshot fallback shape (older exports)
export type Snapshot = { width:number; height:number; step?:number; cells: (null|{state:any;memory:any})[][] };

// Try to detect a raw snapshot JSON (from 2S "Export Snapshot JSON")
export function looksLikeSnapshot(x:any): x is Snapshot {
  return x && isNum(x.width) && isNum(x.height) && Array.isArray(x.cells);
}

// Migrate raw snapshot → Manifest @1 with sensible defaults
export function migrateSnapshot(s: Snapshot): Manifest {
  return {
    schema: 'mpl-bundle@1',
    created: new Date().toISOString(),
    engine: { version: '2V' },
    env: { width: s.width, height: s.height, topology: 'Moore', edges: 'Clip' },
    rule: 'B3/S23',
    seed: 1,
    steps: Math.max(1, Number(s.step ?? 200)),
    init: 'snapshot',
    cells: s.cells,
  };
}

// Validate manifest strictly and also produce helpful warnings.
export function validateManifest(x:any): Validation {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Backward‑compat acceptance
  if (!x?.schema && looksLikeSnapshot(x)){
    const m = migrateSnapshot(x);
    warnings.push('Input looked like a raw snapshot; migrated to mpl-bundle@1 with defaults.');
    return { ok: true, errors, warnings, manifest: m };
  }

  if (!x || x.schema !== 'mpl-bundle@1'){
    errors.push(`Unsupported or missing schema (expected "mpl-bundle@1").`);
    return { ok: false, errors, warnings };
  }

  // Core fields
  if (!isStr(x.created)) warnings.push('created missing/invalid; will set to now on repack.');
  if (!x.engine || !isStr(x.engine.version)) warnings.push('engine.version missing; will set on repack.');

  const env = x.env;
  if (!env) errors.push('env is required.');
  else {
    if (!isNum(env.width) || env.width<=0) errors.push('env.width must be a positive number.');
    if (!isNum(env.height) || env.height<=0) errors.push('env.height must be a positive number.');
    if (!oneOf(env.topology, ['Moore','VonNeumann'])) errors.push('env.topology must be "Moore" or "VonNeumann".');
    if (!oneOf(env.edges, ['Clip','Wrap'])) errors.push('env.edges must be "Clip" or "Wrap".');
  }

  if (!isStr(x.rule) || !/^B[0-8]*\/S[0-8]*$/i.test(x.rule)) errors.push('rule must be a Life‑like string (e.g., B3/S23).');
  if (!isNum(x.seed)) errors.push('seed must be a number.');
  if (!isNum(x.steps) || x.steps<=0) errors.push('steps must be a positive number.');

  if (x.init === 'snapshot'){
    if (!Array.isArray(x.cells)) errors.push('cells (snapshot) are required when init = "snapshot".');
  } else if (x.init === 'random'){
    if (x.p != null && (!isNum(x.p) || x.p<0 || x.p>1)) errors.push('p must be in [0,1].');
  } else {
    warnings.push('init not set; defaulting to "random" on repack.');
  }

  // Optional fields
  if (x.tags && !Array.isArray(x.tags)) warnings.push('tags should be an array.');
  if (x.metrics && typeof x.metrics !== 'object') warnings.push('metrics should be an object.');

  return { ok: errors.length===0, errors, warnings, manifest: x as Manifest };
}

// Normalize manifest for repack: fill defaults, strip unknown keys
export function normalize(man: Manifest): Manifest {
  return {
    schema: 'mpl-bundle@1',
    created: man.created || new Date().toISOString(),
    engine: { version: man.engine?.version || '2V' },
    env: {
      width: Number(man.env.width),
      height: Number(man.env.height),
      topology: oneOf(man.env.topology, ['Moore','VonNeumann']) ? man.env.topology : 'Moore',
      edges: oneOf(man.env.edges, ['Clip','Wrap']) ? man.env.edges : 'Clip',
    },
    rule: (man.rule || 'B3/S23').toUpperCase(),
    seed: Number(man.seed ?? 1),
    steps: Math.max(1, Number(man.steps ?? 200)),
    init: man.init==='snapshot' ? 'snapshot' : (man.init==='random' ? 'random' : 'random'),
    p: man.init==='random' ? (typeof man.p==='number'? Math.min(1,Math.max(0,man.p)) : 0.22) : undefined,
    cells: man.init==='snapshot' ? man.cells : undefined,
    metrics: man.metrics,
    tags: Array.isArray(man.tags) ? man.tags : undefined,
  };
}
```

---

## src/web/repro-2v.ts (NEW — validator‑aware loader UI)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { rulesFromSpec, parseBS } from './rulespec.js';
import { createRng } from './prng.js';
import { snapshot as snapCells, pack, type Manifest } from './bundle.js';
import { sha256Hex } from './hash.js';
import { ingestFromHash, decodeReady } from './share2u.ts';
import { looksLikeSnapshot, validateManifest, migrateSnapshot, normalize } from './schema.ts';

const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;

// UI
const canvas = $('grid') as HTMLCanvasElement; const ctx = canvas.getContext('2d')!;
const drop = $('drop'); const fileInput = $('file') as HTMLInputElement;
const warns = $('warns') as HTMLUListElement; const errs = $('errs') as HTMLUListElement;
const sha = $('sha'); const status = $('status');
const btnRepack = $('repack'); const btnExport = $('export'); const btnVerify = $('verify');
const btnPlay = $('play'); const btnStep = $('step');

let grid: Grid2D; let topoName: 'Moore'|'VonNeumann'='Moore'; let edges: 'Clip'|'Wrap'='Clip';
let playing=false, ms=220, step=0; let current: Manifest | null = null; let currentHash: string | null = null;

function makeTopo(){ const base = topoName==='VonNeumann'? new VonNeumann() : new Moore(); return edges==='Wrap'? new Toroidal(base, ()=>({width:grid.width,height:grid.height})) : base; }
function draw(){ const cell=14; canvas.width=grid.width*cell; canvas.height=grid.height*cell; ctx.fillStyle='#0a0e11'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#e8eef2'; for(let y=0;y<grid.height;y++) for(let x=0;x<grid.width;x++){ const m=(grid as any).cells[y][x]; if(m?.state?.alive) ctx.fillRect(x*cell,y*cell,cell,cell);} }

function applyManifest(m: Manifest){
  topoName = m.env.topology; edges = m.env.edges;
  const intr = new Interpreter(rulesFromSpec(parseBS(m.rule)));
  grid = new Grid2D(m.env.width, m.env.height, intr, makeTopo());
  if (m.init==='snapshot' && m.cells){ for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ const c=m.cells[y][x]; if(c) (grid as any).cells[y][x]=new Monad(c.state,c.memory); } }
  else { const rng=createRng(m.seed); const p=m.p ?? 0.22; for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ (grid as any).cells[y][x] = rng.random()<p? new Monad({alive:true}) : null; } }
  step=0; draw();
}

function list(ul: HTMLUListElement, items: string[]){ ul.innerHTML=''; for (const s of items){ const li=document.createElement('li'); li.textContent=s; ul.appendChild(li);} }

async function loadAny(raw: any){
  warns.innerHTML = ''; errs.innerHTML = ''; status.textContent=''; sha.textContent=''; current = null; currentHash = null;
  // Accept manifest or snapshot; validate/migrate
  let validated = validateManifest(raw);
  if (!validated.ok && looksLikeSnapshot(raw)){
    const m = migrateSnapshot(raw); validated = validateManifest(m);
  }
  list(warns, validated.warnings);
  list(errs, validated.errors);
  if (!validated.ok){ status.textContent='Validation failed — cannot run'; return; }

  const man = normalize(validated.manifest!);
  current = man; currentHash = await sha256Hex(JSON.stringify(man));
  sha.textContent = currentHash!;
  status.textContent = 'Loaded and validated.';
  applyManifest(man);
}

async function handleFile(f: File){
  try {
    const text = await f.text();
    const json = JSON.parse(text);
    await loadAny(json);
  } catch(e:any){ status.textContent = `Failed to load ${f.name}: ${e.message}`; }
}

// Drag‑drop
['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('hover'); }));
['dragleave','drop'].forEach(ev => drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.remove('hover'); }));
drop.addEventListener('drop', (e:any)=>{ const files: FileList = e.dataTransfer?.files; if(!files) return; for (const f of Array.from(files)) handleFile(f); });
fileInput.onchange = () => { const files = fileInput.files; if(!files) return; for (const f of Array.from(files)) handleFile(f); };

// URL hash (supports 2U single/chunked)
(async function fromHash(){
  const got = ingestFromHash(); if (!got) return;
  if (got.ready){
    try { const man = await decodeReady(got.ready); await loadAny(man); status.textContent += got.status==='reassembled'? ' (reassembled from chunks)' : ' (from link)'; }
    catch(e:any){ status.textContent = 'Link decode error: '+e.message; }
  } else if (got.status==='partial'){
    status.textContent = 'Chunk stored; open remaining links to complete.';
  }
})();

btnVerify.onclick = async () => {
  if (!current) { status.textContent='Nothing loaded'; return; }
  const hash = await sha256Hex(JSON.stringify(current));
  status.textContent = `Computed sha256=${hash}` + (currentHash && currentHash!==hash ? ' (WARNING: differs from initial)' : '');
};

btnRepack.onclick = () => {
  if (!current) { status.textContent='Nothing to repack'; return; }
  const norm = normalize(current);
  const blob = pack(norm);
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `normalized-${Date.now()}.mplbundle`; a.click(); URL.revokeObjectURL(a.href);
};

btnExport.onclick = () => {
  if (!current) { status.textContent='Nothing to export'; return; }
  const dump = { width: current.env.width, height: current.env.height, step, cells: snapCells(grid) };
  const blob = new Blob([JSON.stringify(dump,null,2)],{type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `snapshot-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href);
};

function tick(){ grid.tick(); step++; draw(); }
function loop(){ if(!playing) return; const t0=performance.now(); tick(); const dt=Math.max(0, ms-(performance.now()-t0)); setTimeout(loop, dt); }
btnPlay.onclick = ()=> { playing=!playing; btnPlay.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); };
btnStep.onclick = ()=> { if(!playing) tick(); };

// Demo default (invalid on purpose → shows warnings → normalized)
(async function demo(){
  const demo = { schema:'mpl-bundle@1', created:'', engine:{version:''}, env:{width:40,height:30,topology:'Mooree',edges:'Clipp'}, rule:'b3/s23', seed:'123' as any, steps:200, init:'random', p:0.25 };
  await loadAny(demo);
})();
```

---

## index-2v.html (NEW — validator UI)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2V – Validate • Migrate • Verify</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; --bad:#ef476f; --warn:#f3a712; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    ul { margin:0; padding-left:18px; max-height: 20vh; overflow:auto; }
    .bad { color: var(--bad); }
    .warn { color: var(--warn); }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
    #drop { border:2px dashed #2a3640; border-radius:10px; padding:12px; text-align:center; color:#8aa1b1; }
    #drop.hover { background:#0b1115; border-color:#56b6c2; color:#bfe7ee; }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 2V (Schema Validator + Compat Loader + Integrity)</h1>
    <small>Validate • Migrate • Verify • Repack</small>
  </header>
  <main>
    <aside class="panel">
      <div id="drop">Drag & drop `.mplbundle` or `snapshot.json`</div>
      <div class="row"><input id="file" type="file" accept="application/json,.mplbundle" /></div>
      <div class="row"><strong>SHA‑256</strong>: <span id="sha"></span></div>
      <div class="row">
        <button id="verify">Verify</button>
        <button id="repack">Repack as clean .mplbundle</button>
        <button id="export">Export Snapshot</button>
      </div>
      <div class="row"><small id="status"></small></div>
      <div class="row"><strong>Warnings</strong></div>
      <ul id="warns" class="warn"></ul>
      <div class="row"><strong>Errors</strong></div>
      <ul id="errs" class="bad"></ul>
    </aside>
    <section class="panel">
      <canvas id="grid" width="560" height="420"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/repro-2v.ts"></script>
</body>
</html>
```

---

## README addendum (2V)

````md
### 2V – Schema Validator + Backward‑Compat Loader + Integrity Warnings

Run the validator UI:
```bash
npm i
npm run dev:2v
````

* Drop a `.mplbundle` or a raw `snapshot.json` — we **validate**, **migrate**, and **normalize**.
* See **Warnings/Errors** and SHA‑256. Fix with **Repack** to a clean bundle.
* Works with 2U **share links** (single or chunked); the page auto‑hydrates from URL hashes.

**Validation Rules (summary)**

* `schema` must be `mpl-bundle@1` (or a raw snapshot will be migrated).
* `env.width|height` > 0, `env.topology` ∈ {Moore, VonNeumann}, `env.edges` ∈ {Clip, Wrap}.
* `rule` matches `B…/S…`, `seed` is a number, `steps` > 0.
* If `init=snapshot` → `cells` required; if `init=random` → optional `p∈[0,1]`.

**Compat**: older snapshot dumps are accepted and upgraded with safe defaults.

```
```
