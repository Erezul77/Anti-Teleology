# MPL Stage 2L – Browser Live Visualization

Stage 2G extends visualization into the browser for **real-time interactive display**. This adds a web-based view that updates the grid live, allowing play/pause, step, and speed control.

---

## What’s included

* `public/index.html` – main page with canvas and controls
* `src/vis/browser.ts` – rendering + loop controller
* `examples/run-2g.ts` – server bootstrap (using Vite/Parcel or static serve)

---

## public/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MPL Stage 2G Viewer</title>
  <style>
    body { background:#111; color:#eee; font-family: sans-serif; text-align:center; }
    #controls { margin:1em; }
    canvas { background:#fff; border:1px solid #555; }
  </style>
</head>
<body>
  <h1>MPL Playground – Stage 2G</h1>
  <div id="controls">
    <button id="play">▶️ Play</button>
    <button id="pause">⏸ Pause</button>
    <button id="step">⏭ Step</button>
    <label>Speed <input id="speed" type="range" min="50" max="1000" value="300"></label>
  </div>
  <canvas id="grid" width="400" height="400"></canvas>
  <script type="module" src="/bundle.js"></script>
</body>
</html>
```

---

## src/vis/browser.ts

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter, Rule } from '../runtime/interpreter.js';
import { Moore } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';

export class BrowserRenderer {
  ctx: CanvasRenderingContext2D;
  cellSize: number;
  grid: Grid2D;
  interval: any;
  speed = 300;

  constructor(canvas: HTMLCanvasElement, grid: Grid2D, cellSize=20){
    this.ctx = canvas.getContext('2d')!;
    this.cellSize = cellSize;
    this.grid = grid;
  }

  draw(){
    this.ctx.fillStyle = 'white';
    this.ctx.fillRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height);
    for (let y=0; y<this.grid.height; y++){
      for (let x=0; x<this.grid.width; x++){
        const c = this.grid.cells[y][x];
        if (c?.state.alive){
          this.ctx.fillStyle = 'black';
          this.ctx.fillRect(x*this.cellSize,y*this.cellSize,this.cellSize,this.cellSize);
        }
      }
    }
  }

  start(){
    this.stop();
    this.interval = setInterval(()=>{
      this.grid.tick();
      this.draw();
    }, this.speed);
  }

  stop(){ if (this.interval) clearInterval(this.interval); }
  step(){ this.grid.tick(); this.draw(); }
  setSpeed(ms:number){ this.speed = ms; if(this.interval) this.start(); }
}
```

---

## bundle entry (examples/run-2g.ts)

```ts
import { Interpreter, Rule } from '../src/runtime/interpreter.js';
import { Grid2D } from '../src/runtime/grid.js';
import { Moore } from '../src/runtime/topology/index.js';
import { Monad } from '../src/runtime/monad.js';
import { BrowserRenderer } from '../src/vis/browser.js';

const rules: Rule[] = [
  { kind: 'if', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n < 2 || n > 3) env?.mut?.set('state.alive', false);
    } },
  { kind: 'unless', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n === 3) env?.mut?.set('state.alive', true);
    } },
];

const interpreter = new Interpreter(rules);
const grid = new Grid2D(20,20, interpreter, new Moore());

// seed glider
const m=(x:number,y:number)=>grid.place({x,y},new Monad({alive:true}));
m(1,0);m(2,1);m(0,2);m(1,2);m(2,2);

const canvas = document.getElementById('grid') as HTMLCanvasElement;
const renderer = new BrowserRenderer(canvas, grid, 20);
renderer.draw();

(document.getElementById('play') as HTMLButtonElement).onclick=()=>renderer.start();
(document.getElementById('pause') as HTMLButtonElement).onclick=()=>renderer.stop();
(document.getElementById('step') as HTMLButtonElement).onclick=()=>renderer.step();
(document.getElementById('speed') as HTMLInputElement).oninput=e=>renderer.setSpeed(parseInt((e.target as HTMLInputElement).value));
```

---

## README addendum (2G)

````md
### 2G – Browser Visualization

Run a dev server (e.g., Vite):
```bash
npm install vite -D
npx vite
````

Visit `http://localhost:5173/public/index.html`.

Controls:

* ▶️ Play (start continuous evolution)
* ⏸ Pause
* ⏭ Step one tick
* Speed slider (adjust tick interval)

````

---

With this, Stage 2G enables **live browser-based visualization with controls**. Next: Stage 2H could add **interactive editing** (click cells to toggle state).



---

# MPL Stage 2G – Live Browser Visualization (Interactive)

Stage 2G adds a **browser UI** with live play/pause, step, speed control, topology switch, click‑to‑toggle cells, random seeding, and export/import of snapshots. It uses **Vite** for a lightweight dev server and ES‑module TypeScript.

## package.json (add these scripts & dev dependency)
```json
{
  "scripts": {
    "demo": "ts-node examples/run.ts",
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "ts-node": "^10.9.2",
    "typescript": "^5.6.3",
    "vite": "^5.4.0"
  },
  "dependencies": {
    "chalk": "^5.3.0"
  }
}
````

> Note: `canvas` is only needed for Node PNG snapshots (2F). Install it if you use `renderPng`.

---

## index.html (Vite root)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2G – Live Grid</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 280px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    label { color:var(--muted); }
    button, select, input[type="number"], input[type="file"] { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    button { cursor:pointer; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; }
    small { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>MPL Stage 2G – Live Browser Visualization</h1>
    <small>Play / pause, step, speed, topology, edit cells, save/load</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
        <button id="clear">Clear</button>
      </div>
      <div class="row">
        <label>Speed</label>
        <input id="speed" type="range" min="50" max="800" value="300" />
        <small id="speedLabel"></small>
      </div>
      <div class="row">
        <label>Cell size</label>
        <input id="cellSize" type="number" value="16" min="4" max="40" step="1" />
      </div>
      <div class="row">
        <label>Grid</label>
        <input id="w" type="number" value="40" min="5" max="200" step="1" /> ×
        <input id="h" type="number" value="30" min="5" max="200" step="1" />
        <button id="resize">Resize</button>
      </div>
      <div class="row">
        <label>Topology</label>
        <select id="topo">
          <option>Moore</option>
          <option>VonNeumann</option>
        </select>
      </div>
      <div class="row">
        <button id="glider">Seed Glider</button>
        <button id="random">Randomize</button>
      </div>
      <div class="row">
        <button id="export">Export JSON</button>
        <label for="importFile" class="btn">Import</label>
        <input id="importFile" type="file" accept="application/json" />
      </div>
      <div class="row">
        <small>Tip: click on the canvas to toggle cells.</small>
      </div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="640" height="480"></canvas>
    </section>
  </main>
  <script type="module" src="/src/vis/web-main.ts"></script>
</body>
</html>
```

---

## src/vis/web-main.ts (browser UI)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter, type Rule } from '../runtime/interpreter.js';
import { Moore, VonNeumann } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { Tracer } from '../debug/trace.js';

// ----- DOM -----
const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;
const canvas = $('grid') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;
const playBtn = $('play');
const stepBtn = $('step');
const clearBtn = $('clear');
const speed = $('speed') as HTMLInputElement;
const speedLabel = $('speedLabel');
const cellSizeInput = $('cellSize') as HTMLInputElement;
const wInput = $('w') as HTMLInputElement;
const hInput = $('h') as HTMLInputElement;
const resizeBtn = $('resize');
const topoSelect = $('topo') as HTMLSelectElement;
const gliderBtn = $('glider');
const randBtn = $('random');
const exportBtn = $('export');
const importFile = $('importFile') as HTMLInputElement;

// ----- Rules (Game of Life) -----
const rules: Rule[] = [
  { kind: 'if', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n < 2 || n > 3) env?.mut?.set('state.alive', false);
    } },
  { kind: 'unless', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n === 3) env?.mut?.set('state.alive', true);
    } },
];

const interpreter = new Interpreter(rules);
let tracer = new Tracer();

// ----- World -----
let cellSize = 16;
let width = 40, height = 30;
let topoName: 'Moore' | 'VonNeumann' = 'Moore';
const makeTopo = () => topoName === 'Moore' ? new Moore() : new VonNeumann();
let grid = new Grid2D(width, height, interpreter, makeTopo());

function resizeCanvas(){
  canvas.width = width * cellSize;
  canvas.height = height * cellSize;
}
resizeCanvas();

// ----- Render -----
function draw(){
  ctx.fillStyle = '#0a0e11';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#e8eef2';
  for (let y=0; y<height; y++){
    for (let x=0; x<width; x++){
      const m = (grid as any).cells[y][x];
      if (m && m.state?.alive){ ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize); }
    }
  }
  // light grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  for (let x=0; x<=width; x++){ ctx.beginPath(); ctx.moveTo(x*cellSize+0.5, 0); ctx.lineTo(x*cellSize+0.5, canvas.height); ctx.stroke(); }
  for (let y=0; y<=height; y++){ ctx.beginPath(); ctx.moveTo(0, y*cellSize+0.5); ctx.lineTo(canvas.width, y*cellSize+0.5); ctx.stroke(); }
}

// ----- Simulation loop -----
let playing = false;
let msPerStep = Number(speed.value);
function setSpeedLabel(){ speedLabel.textContent = `${msPerStep} ms/step`; }
setSpeedLabel();

function tick(){ grid.tick(tracer); draw(); }

function loop(){
  if (!playing) return; const start = performance.now();
  tick();
  const elapsed = performance.now() - start;
  const delay = Math.max(0, msPerStep - elapsed);
  setTimeout(loop, delay);
}

// ----- Controls -----
playBtn.onclick = () => {
  playing = !playing; playBtn.textContent = playing ? '⏸ Pause' : '▶︎ Play';
  if (playing) loop();
};
stepBtn.onclick = () => { if (!playing) tick(); };
clearBtn.onclick = () => {
  for (let y=0; y<height; y++) for (let x=0; x<width; x++) (grid as any).cells[y][x] = null;
  draw();
};
speed.oninput = () => { msPerStep = Number(speed.value); setSpeedLabel(); };
cellSizeInput.onchange = () => { cellSize = Math.max(4, Math.min(40, Number(cellSizeInput.value)||16)); resizeCanvas(); draw(); };
resizeBtn.onclick = () => {
  const nw = Math.max(5, Math.min(200, Number(wInput.value)||width));
  const nh = Math.max(5, Math.min(200, Number(hInput.value)||height));
  // snapshot cells
  const copy:(any|null)[][] = [];
  for (let y=0; y<height; y++){ copy[y] = []; for (let x=0; x<width; x++){ const m=(grid as any).cells[y][x]; copy[y][x] = m ? { state:{...m.state}, memory:{...m.memory} } : null; } }
  width=nw; height=nh; grid = new Grid2D(width, height, interpreter, makeTopo());
  for (let y=0; y<Math.min(nh, copy.length); y++) for (let x=0; x<Math.min(nw, copy[0].length); x++){ const c=copy[y][x]; if (c) (grid as any).cells[y][x] = new Monad(c.state, c.memory); }
  resizeCanvas(); draw();
};
topoSelect.onchange = () => {
  topoName = topoSelect.value as any;
  // rebuild grid with same cells
  const copy:(any|null)[][] = [];
  for (let y=0; y<height; y++){ copy[y] = []; for (let x=0; x<width; x++){ const m=(grid as any).cells[y][x]; copy[y][x] = m ? { state:{...m.state}, memory:{...m.memory} } : null; } }
  grid = new Grid2D(width, height, interpreter, makeTopo());
  for (let y=0; y<height; y++) for (let x=0; x<width; x++){ const c=copy[y][x]; if (c) (grid as any).cells[y][x] = new Monad(c.state, c.memory); }
  draw();
};

gliderBtn.onclick = () => {
  const cx = Math.floor(width/2), cy = Math.floor(height/2);
  const set = (x:number,y:number)=> (grid as any).cells[y][x] = new Monad({alive:true});
  set(cx+1,cy); set(cx+2,cy+1); set(cx,cy+2); set(cx+1,cy+2); set(cx+2,cy+2);
  draw();
};
randBtn.onclick = () => {
  const p = 0.22; // alive probability
  for (let y=0; y<height; y++) for (let x=0; x<width; x++) (grid as any).cells[y][x] = Math.random()<p ? new Monad({alive:true}) : null;
  draw();
};

// click to toggle
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / cellSize);
  const y = Math.floor((e.clientY - rect.top) / cellSize);
  if (x<0||y<0||x>=width||y>=height) return;
  const cur = (grid as any).cells[y][x];
  if (cur) {
    cur.state.alive = !cur.state.alive; if (!cur.state.alive) (grid as any).cells[y][x] = null;
  } else {
    (grid as any).cells[y][x] = new Monad({alive:true});
  }
  draw();
});

// export/import (browser, no fs)
function snapshot(){
  return {
    schema: 'mpl-stage-2@1', kind: 'Grid2D',
    width, height, step: (grid as any).stepCount,
    topology: topoName,
    cells: (grid as any).cells.map((row:any[])=> row.map((m:any)=> m? { state:{...m.state}, memory:{...m.memory} } : null))
  };
}
function downloadJSON(obj: any, filename: string){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}
exportBtn.onclick = () => downloadJSON(snapshot(), `mpl-grid-${Date.now()}.json`);

importFile.onchange = async () => {
  const file = importFile.files?.[0]; if (!file) return;
  const text = await file.text();
  const snap = JSON.parse(text);
  if (snap.kind !== 'Grid2D') return alert('Unsupported snapshot kind');
  topoName = (snap.topology === 'VonNeumann') ? 'VonNeumann' : 'Moore';
  width = snap.width; height = snap.height; resizeCanvas(); topoSelect.value = topoName;
  grid = new Grid2D(width, height, interpreter, makeTopo());
  for (let y=0; y<height; y++) for (let x=0; x<width; x++){
    const c = snap.cells[y][x]; if (c) (grid as any).cells[y][x] = new Monad(c.state, c.memory);
  }
  (grid as any).stepCount = snap.step;
  draw();
};

draw();
```

---

## README addendum (2G)

````md
### 2G – Live Browser Visualization

**Start the UI**
```bash
npm i
npm run dev
````

Then open the URL (usually [http://localhost:5173](http://localhost:5173)). Use Play/Pause, Step, Speed, Topology, and click the canvas to toggle cells. Seed a glider or randomize, and Export/Import snapshots as JSON.

This UI uses your existing runtime (2A–2C) and works alongside 2D (affect) and 2E (snapshots). For browser export/import we bundle a small in‑page serializer compatible with the `mpl-stage-2@1` schema.

````



---

# MPL Stage 2H – Toroidal Edges & Affect Heatmap

Stage 2H adds two big upgrades to the browser UI:
1) **Edge modes:** choose between **Clip** (previous behavior) and **Wrap** (toroidal world).
2) **Affect heatmap:** visualize 2D signals (joy, stress, calm, sadness) and adequacy α as colors.

This extends the existing 2G UI and 2D affect. Copy the updated files below.

## Changes overview
- `src/runtime/topology/index.ts` — add a **`Toroidal`** wrapper topology.
- `src/vis/colors.ts` — tiny color utilities + heatmap scale.
- `index.html` — add **Edges** and **Mode** controls, plus a legend.
- `src/vis/web-main.ts` — render either **Alive** cells or a **heatmap** for affect/adequacy; support **Clip/Wrap**.

---

## src/runtime/topology/index.ts (append)
```ts
export type SizeFn = () => { width: number; height: number };

/** Wraps a base topology so neighbor coords wrap around the grid (toroidal). */
export class Toroidal implements Topology {
  base: Topology; size: SizeFn;
  constructor(base: Topology, size: SizeFn){ this.base = base; this.size = size; }
  neighbors(of: Coord): Coord[] {
    const raw = this.base.neighbors(of);
    const { width, height } = this.size();
    const wrap = (v: number, max: number) => ((v % max) + max) % max;
    return raw.map(c => ({ x: wrap(c.x, width), y: wrap(c.y, height) }));
  }
}
````

---

## src/vis/colors.ts (new)

```ts
export function clamp01(x: number){ return x < 0 ? 0 : x > 1 ? 1 : x; }
export function lerp(a: number, b: number, t: number){ return a + (b - a) * t; }

function rgb(r: number, g: number, b: number){ return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`; }

/**
 * Heat color scale 0..1 → dark → blue → yellow → red
 */
export function heatColor(v: number){
  const t = clamp01(v);
  // 3-stop gradient: 0:#0a0e11 → 0.6:#ffd166 → 1:#ef476f (with an early blue tint)
  if (t < 0.33){ // dark → blue
    const k = t / 0.33; return rgb( lerp(10, 42, k), lerp(14, 111, k), lerp(17, 239, k) );
  } else if (t < 0.66){ // blue → yellow
    const k = (t - 0.33) / 0.33; return rgb( lerp(42, 255, k), lerp(111, 209, k), lerp(239, 102, k) );
  } else { // yellow → red
    const k = (t - 0.66) / 0.34; return rgb( lerp(255, 239, k), lerp(209, 71, k), lerp(102, 111, k) );
  }
}
```

---

## index.html (replace with this updated version)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2G/H – Live Grid</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 300px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    label { color:var(--muted); }
    button, select, input[type="number"], input[type="file"] { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    button { cursor:pointer; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; }
    small { color:var(--muted); }
    #legend { width: 100%; height: 10px; background: linear-gradient(90deg,#0a0e11,#2a6fef,#ffd166,#ef476f); border-radius: 4px; border:1px solid #1b2227; }
    .legend-row { display:flex; align-items:center; gap:8px; }
  </style>
</head>
<body>
  <header>
    <h1>MPL Stage 2H – Wrap Edges & Affect Heatmap</h1>
    <small>Play / step / speed · topology & edges · toggle cells · export/import · heatmap</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
        <button id="clear">Clear</button>
      </div>
      <div class="row">
        <label>Speed</label>
        <input id="speed" type="range" min="50" max="800" value="300" />
        <small id="speedLabel"></small>
      </div>
      <div class="row">
        <label>Cell size</label>
        <input id="cellSize" type="number" value="16" min="4" max="40" step="1" />
      </div>
      <div class="row">
        <label>Grid</label>
        <input id="w" type="number" value="40" min="5" max="200" step="1" /> ×
        <input id="h" type="number" value="30" min="5" max="200" step="1" />
        <button id="resize">Resize</button>
      </div>
      <div class="row">
        <label>Topology</label>
        <select id="topo">
          <option>Moore</option>
          <option>VonNeumann</option>
        </select>
        <label>Edges</label>
        <select id="edges">
          <option>Clip</option>
          <option>Wrap</option>
        </select>
      </div>
      <div class="row">
        <label>Mode</label>
        <select id="mode">
          <option>Alive</option>
          <option>Joy</option>
          <option>Stress</option>
          <option>Calm</option>
          <option>Sadness</option>
          <option>Alpha</option>
        </select>
      </div>
      <div class="row legend-row">
        <div id="legend" title="0 → 1"></div>
        <small>0 → 1</small>
      </div>
      <div class="row">
        <button id="glider">Seed Glider</button>
        <button id="random">Randomize</button>
      </div>
      <div class="row">
        <button id="export">Export JSON</button>
        <label for="importFile" class="btn">Import</label>
        <input id="importFile" type="file" accept="application/json" />
      </div>
      <div class="row">
        <small>Tip: click on the canvas to toggle cells.</small>
      </div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="640" height="480"></canvas>
    </section>
  </main>
  <script type="module" src="/src/vis/web-main.ts"></script>
</body>
</html>
```

---

## src/vis/web-main.ts (replace with this updated version)

```ts
import { Grid2D } from '../runtime/grid.js';
import { Interpreter, type Rule } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { Tracer } from '../debug/trace.js';
import { heatColor, clamp01 } from './colors.js';

// ----- DOM -----
const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;
const canvas = $('grid') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;
const playBtn = $('play');
const stepBtn = $('step');
const clearBtn = $('clear');
const speed = $('speed') as HTMLInputElement;
const speedLabel = $('speedLabel');
const cellSizeInput = $('cellSize') as HTMLInputElement;
const wInput = $('w') as HTMLInputElement;
const hInput = $('h') as HTMLInputElement;
const resizeBtn = $('resize');
const topoSelect = $('topo') as HTMLSelectElement;
const edgesSelect = $('edges') as HTMLSelectElement;
const modeSelect = $('mode') as HTMLSelectElement;
const gliderBtn = $('glider');
const randBtn = $('random');
const exportBtn = $('export');
const importFile = $('importFile') as HTMLInputElement;

// ----- Rules (Game of Life) -----
const rules: Rule[] = [
  { kind: 'if', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n < 2 || n > 3) env?.mut?.set('state.alive', false);
    } },
  { kind: 'unless', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n === 3) env?.mut?.set('state.alive', true);
    } },
];

const interpreter = new Interpreter(rules);
let tracer = new Tracer();

// ----- World -----
let cellSize = 16;
let width = 40, height = 30;
let topoName: 'Moore' | 'VonNeumann' = 'Moore';
let edges: 'Clip' | 'Wrap' = 'Clip';

function makeTopo(){
  const base = topoName === 'Moore' ? new Moore() : new VonNeumann();
  return edges === 'Wrap' ? new Toroidal(base, () => ({ width, height })) : base;
}

let grid = new Grid2D(width, height, interpreter, makeTopo());

function resizeCanvas(){
  canvas.width = width * cellSize;
  canvas.height = height * cellSize;
}
resizeCanvas();

// ----- Render -----
function metricValue(m: any, mode: string): number {
  if (!m) return 0;
  if (mode === 'Alive') return m.state?.alive ? 1 : 0;
  const emo = m.memory?.emotion || {};
  if (mode === 'Joy') return clamp01(emo.joy ?? 0);
  if (mode === 'Stress') return clamp01(emo.stress ?? 0);
  if (mode === 'Calm') return clamp01(emo.calm ?? 0);
  if (mode === 'Sadness') return clamp01(emo.sadness ?? 0);
  if (mode === 'Alpha') return clamp01(m.memory?.adequacy?.alpha ?? 0);
  return 0;
}

function draw(){
  ctx.fillStyle = '#0a0e11';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const mode = modeSelect.value;

  for (let y=0; y<height; y++){
    for (let x=0; x<width; x++){
      const m = (grid as any).cells[y][x];
      if (mode === 'Alive'){
        if (m && m.state?.alive){
          ctx.fillStyle = '#e8eef2';
          ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
        }
      } else {
        const v = metricValue(m, mode);
        ctx.fillStyle = heatColor(v);
        ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
      }
    }
  }
  // grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  for (let x=0; x<=width; x++){ ctx.beginPath(); ctx.moveTo(x*cellSize+0.5, 0); ctx.lineTo(x*cellSize+0.5, canvas.height); ctx.stroke(); }
  for (let y=0; y<=height; y++){ ctx.beginPath(); ctx.moveTo(0, y*cellSize+0.5); ctx.lineTo(canvas.width, y*cellSize+0.5); ctx.stroke(); }
}

// ----- Simulation loop -----
let playing = false;
let msPerStep = Number(speed.value);
function setSpeedLabel(){ speedLabel.textContent = `${msPerStep} ms/step`; }
setSpeedLabel();

function tick(){ grid.tick(tracer); draw(); }

function loop(){
  if (!playing) return; const start = performance.now();
  tick();
  const elapsed = performance.now() - start;
  const delay = Math.max(0, msPerStep - elapsed);
  setTimeout(loop, delay);
}

// ----- Controls -----
playBtn.onclick = () => { playing = !playing; playBtn.textContent = playing ? '⏸ Pause' : '▶︎ Play'; if (playing) loop(); };
stepBtn.onclick = () => { if (!playing) tick(); };
clearBtn.onclick = () => { for (let y=0; y<height; y++) for (let x=0; x<width; x++) (grid as any).cells[y][x] = null; draw(); };
speed.oninput = () => { msPerStep = Number(speed.value); setSpeedLabel(); };
cellSizeInput.onchange = () => { cellSize = Math.max(4, Math.min(40, Number(cellSizeInput.value)||16)); resizeCanvas(); draw(); };
resizeBtn.onclick = () => {
  const nw = Math.max(5, Math.min(200, Number(wInput.value)||width));
  const nh = Math.max(5, Math.min(200, Number(hInput.value)||height));
  // snapshot cells
  const copy:(any|null)[][] = [];
  for (let y=0; y<height; y++){ copy[y] = []; for (let x=0; x<width; x++){ const m=(grid as any).cells[y][x]; copy[y][x] = m ? { state:{...m.state}, memory:{...m.memory} } : null; } }
  width=nw; height=nh; grid = new Grid2D(width, height, interpreter, makeTopo());
  for (let y=0; y<Math.min(nh, copy.length); y++) for (let x=0; x<Math.min(nw, copy[0].length); x++){ const c=copy[y][x]; if (c) (grid as any).cells[y][x] = new Monad(c.state, c.memory); }
  resizeCanvas(); draw();
};

topoSelect.onchange = () => { topoName = topoSelect.value as any; grid = new Grid2D(width, height, interpreter, makeTopo()); draw(); };
edgesSelect.onchange = () => { edges = edgesSelect.value as any; grid = new Grid2D(width, height, interpreter, makeTopo()); draw(); };
modeSelect.onchange = () => draw();

gliderBtn.onclick = () => { const cx = Math.floor(width/2), cy = Math.floor(height/2); const set = (x:number,y:number)=> (grid as any).cells[y][x] = new Monad({alive:true}); set(cx+1,cy); set(cx+2,cy+1); set(cx,cy+2); set(cx+1,cy+2); set(cx+2,cy+2); draw(); };
randBtn.onclick = () => { const p = 0.22; for (let y=0; y<height; y++) for (let x=0; x<width; x++) (grid as any).cells[y][x] = Math.random()<p ? new Monad({alive:true}) : null; draw(); };

// click to toggle
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / cellSize);
  const y = Math.floor((e.clientY - rect.top) / cellSize);
  if (x<0||y<0||x>=width||y>=height) return;
  const cur = (grid as any).cells[y][x];
  if (cur) { cur.state.alive = !cur.state.alive; if (!cur.state.alive) (grid as any).cells[y][x] = null; }
  else { (grid as any).cells[y][x] = new Monad({alive:true}); }
  draw();
});

// export/import (browser)
function snapshot(){ return { schema:'mpl-stage-2@1', kind:'Grid2D', width, height, step:(grid as any).stepCount, topology: topoName, cells: (grid as any).cells.map((row:any[])=> row.map((m:any)=> m? { state:{...m.state}, memory:{...m.memory} } : null)) }; }
function downloadJSON(obj: any, filename: string){ const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href); }
exportBtn.onclick = () => downloadJSON(snapshot(), `mpl-grid-${Date.now()}.json`);
importFile.onchange = async () => { const file = importFile.files?.[0]; if (!file) return; const text = await file.text(); const snap = JSON.parse(text); if (snap.kind !== 'Grid2D') return alert('Unsupported snapshot kind'); topoName = (snap.topology === 'VonNeumann') ? 'VonNeumann' : 'Moore'; width = snap.width; height = snap.height; resizeCanvas(); topoSelect.value = topoName; grid = new Grid2D(width, height, interpreter, makeTopo()); for (let y=0; y<height; y++) for (let x=0; x<width; x++){ const c = snap.cells[y][x]; if (c) (grid as any).cells[y][x] = new Monad(c.state, c.memory); } (grid as any).stepCount = snap.step; draw(); };

draw();
```

---

## README addendum (2H)

```md
### 2H – Toroidal Edges & Affect Heatmap

**New controls** in the UI:
- **Edges:** Clip (truncate neighbors at borders) or **Wrap** (toroidal world).
- **Mode:** Alive (binary) or a heatmap for **Joy, Stress, Calm, Sadness, Alpha** (adequacy).

**How it works:**
- `Toroidal` wraps neighbor coordinates modulo width/height and plugs into any base topology.
- Heatmap colors are produced by `heatColor()` (0→1 mapped to dark→blue→yellow→red). Values are read from `memory.emotion.*` or `memory.adequacy.alpha`.

No runtime changes required beyond the new `Toroidal` topology; it composes with your existing engine.
```
