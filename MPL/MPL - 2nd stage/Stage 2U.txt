# MPL – Stage 2U (Compressed Share Links • Chunked Fragments • Optional Gist Upload)

**Goal:** shrink and share bundles reliably, even when URLs have length limits. 2U adds:

* **Gzip compression** of bundles for shorter links (base64url‑encoded),
* **Chunked share links** that can be opened in any order to reassemble a large bundle client‑side,
* **Optional GitHub Gist upload** (with personal token) for a permanent short link fallback.

> Builds on 2T (share/verify/drag‑drop) and 2S (bundles). No backend required.

---

## Directory Tree (updated)

```
MPL-Stage-2/
├─ package.json
├─ tsconfig.json
├─ README.md
├─ src/
│  ├─ runtime/
│  │  ├─ interpreter.ts
│  │  ├─ monad.ts
│  │  ├─ grid.ts
│  │  └─ topology/
│  │     └─ index.ts
│  ├─ debug/
│  │  └─ trace.ts
│  ├─ web/
│  │  ├─ rulespec.ts
│  │  ├─ prng.ts
│  │  ├─ session.ts
│  │  ├─ sweep.ts
│  │  ├─ analytics.ts
│  │  ├─ optimizer.ts
│  │  ├─ sweep2r.ts
│  │  ├─ bundle.ts
│  │  ├─ hash.ts
│  │  ├─ share.ts
│  │  ├─ compress.ts       # NEW: gzip compress/decompress helpers (Web Crypto streams)
│  │  ├─ share2u.ts        # NEW: compressed + chunked share links
│  │  ├─ gist.ts           # NEW: optional GitHub Gist upload
│  │  └─ repro-2u.ts       # NEW: 2U UI logic (compression, chunks, gist)
└─ index-2u.html           # NEW: 2U launcher (compressed links + chunks + gist)
```

Add this script to **package.json**:

```json
{
  "scripts": {
    "dev:2u": "vite --open index-2u.html"
  }
}
```

---

## src/web/compress.ts (NEW — gzip via CompressionStream + base64url)

```ts
// Utilities to compress/decompress JSON using gzip if available.
// Falls back to uncompressed base64url with a "raw:" marker when CompressionStream is not supported.

export function b64urlEncode(bytes: Uint8Array): string {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
}
export function b64urlDecode(s: string): Uint8Array {
  const pad = s.length % 4 ? '='.repeat(4 - (s.length % 4)) : '';
  const b64 = s.replace(/-/g,'+').replace(/_/g,'/') + pad;
  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
  return out;
}

async function streamToArrayBuffer(stream: ReadableStream): Promise<ArrayBuffer> {
  const res = new Response(stream);
  return await res.arrayBuffer();
}

export async function compressJSON(obj: any): Promise<{ enc: string; algo: 'gzip'|'raw' }>{
  const json = JSON.stringify(obj);
  if (typeof CompressionStream !== 'undefined'){
    const cs = new CompressionStream('gzip');
    const writer = cs.writable.getWriter();
    await writer.write(new TextEncoder().encode(json));
    await writer.close();
    const buf = await streamToArrayBuffer(cs.readable);
    return { enc: b64urlEncode(new Uint8Array(buf)), algo: 'gzip' };
  } else {
    // Fallback: store raw JSON as base64url with marker
    return { enc: 'raw:' + b64urlEncode(new TextEncoder().encode(json)), algo: 'raw' };
  }
}

export async function decompressJSON(encoded: string): Promise<any> {
  if (encoded.startsWith('raw:')){
    const bytes = b64urlDecode(encoded.slice(4));
    return JSON.parse(new TextDecoder().decode(bytes));
  }
  if (typeof DecompressionStream !== 'undefined'){
    const ds = new DecompressionStream('gzip');
    const writer = ds.writable.getWriter();
    await writer.write(b64urlDecode(encoded));
    await writer.close();
    const buf = await streamToArrayBuffer(ds.readable);
    return JSON.parse(new TextDecoder().decode(new Uint8Array(buf)));
  }
  // As a last resort, try to parse as raw JSON base64
  try { const txt = new TextDecoder().decode(b64urlDecode(encoded)); return JSON.parse(txt); } catch { throw new Error('Cannot decompress: no DecompressionStream support'); }
}
```

---

## src/web/share2u.ts (NEW — compressed + chunked share links)

```ts
import type { Manifest } from './bundle.js';
import { sha256Hex } from './hash.js';
import { compressJSON, decompressJSON } from './compress.ts';

export type ChunkPlan = { id: string; parts: string[]; sha256: string; algo: 'gzip'|'raw' };

// Split a long string into pieces of at most `maxLen`
export function chunkString(s: string, maxLen: number): string[] {
  const out: string[] = []; for (let i=0;i<s.length;i+=maxLen) out.push(s.slice(i, i+maxLen)); return out;
}

export async function encodeBundle(man: Manifest, maxPerLink = 1800): Promise<ChunkPlan> {
  const { enc, algo } = await compressJSON(man);
  const sha256 = await sha256Hex(JSON.stringify(man));
  const id = (await sha256Hex(enc)).slice(0, 12);
  const parts = chunkString(enc, maxPerLink);
  return { id, parts, sha256, algo };
}

export function singleURL(plan: ChunkPlan): string {
  const base = location.origin + location.pathname.replace(/index-2s\.html|index-2t\.html|index-2u\.html/, 'index-2u.html');
  // If only one part, embed as bundle=
  if (plan.parts.length === 1){
    const hash = `bundle=${plan.parts[0]}&sha256=${plan.sha256}&algo=${plan.algo}`;
    return `${base}#${hash}`;
  }
  // Otherwise, advise using chunked URLs
  const hash = `id=${plan.id}&parts=${plan.parts.length}&sha256=${plan.sha256}&algo=${plan.algo}`;
  return `${base}#${hash}`;
}

export function chunkURLs(plan: ChunkPlan): string[] {
  const base = location.origin + location.pathname.replace(/index-2s\.html|index-2t\.html|index-2u\.html/, 'index-2u.html');
  return plan.parts.map((data, i) => `${base}#id=${plan.id}&parts=${plan.parts.length}&i=${i}&data=${data}`);
}

// Reassembly helpers using URL hash + localStorage cache
const CACHE_KEY = (id: string) => `mpl2u:${id}:`;

export function ingestFromHash(): { status: string; ready?: { enc: string; algo: 'gzip'|'raw'; sha256?: string } } | null {
  if (!location.hash) return null;
  const q = new URLSearchParams(location.hash.slice(1));
  // single payload
  const bundle = q.get('bundle');
  if (bundle){
    const algo = (q.get('algo') as any) || 'gzip';
    const sha256 = q.get('sha256') || undefined;
    return { status: 'single', ready: { enc: bundle, algo, sha256 } };
  }
  // chunked payloads
  const id = q.get('id'); const parts = Number(q.get('parts')||'0');
  if (!id || !parts) return null;
  const i = q.get('i'); const data = q.get('data');
  if (i !== null && data !== null){
    localStorage.setItem(CACHE_KEY(id)+i, data);
  }
  const algo = (q.get('algo') as any) || 'gzip';
  // check completeness
  let ok = true; let enc = '';
  for (let k=0;k<parts;k++){
    const seg = localStorage.getItem(CACHE_KEY(id)+k);
    if (!seg){ ok=false; break; } enc += seg;
  }
  if (ok){
    // cleanup
    for (let k=0;k<parts;k++) localStorage.removeItem(CACHE_KEY(id)+k);
    return { status: 'reassembled', ready: { enc, algo, sha256: q.get('sha256') || undefined } };
  }
  return { status: 'partial' };
}

export async function decodeReady(ready: { enc: string; algo: 'gzip'|'raw' }): Promise<Manifest>{
  const obj = await decompressJSON(ready.enc);
  return obj as Manifest;
}
```

---

## src/web/gist.ts (NEW — optional GitHub Gist upload)

```ts
import type { Manifest } from './bundle.js';

export async function uploadGist(man: Manifest, token: string): Promise<string> {
  const res = await fetch('https://api.github.com/gists', {
    method: 'POST',
    headers: {
      'Accept': 'application/vnd.github+json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      description: 'MPL experiment bundle',
      public: false,
      files: { 'experiment.mplbundle': { content: JSON.stringify(man, null, 2) } }
    })
  });
  if (!res.ok){
    const txt = await res.text();
    throw new Error(`Gist upload failed (${res.status}): ${txt}`);
  }
  const j = await res.json();
  return j.html_url as string; // URL to share
}
```

---

## src/web/repro-2u.ts (NEW — UI for compression, chunking, gist)

```ts
import type { Manifest } from './bundle.js';
import { snapshot as snapCells } from './bundle.js';
import { sha256Hex } from './hash.js';
import { encodeBundle, singleURL, chunkURLs, ingestFromHash, decodeReady } from './share2u.ts';
import { uploadGist } from './gist.js';
import { Grid2D } from '../runtime/grid.js';
import { Interpreter } from '../runtime/interpreter.js';
import { Moore, VonNeumann, Toroidal } from '../runtime/topology/index.js';
import { Monad } from '../runtime/monad.js';
import { rulesFromSpec, parseBS } from './rulespec.js';
import { createRng } from './prng.js';

const $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;
const canvas = $('grid') as HTMLCanvasElement; const ctx = canvas.getContext('2d')!;
const info = $('info'); const status = $('status');
const btnPlay = $('play'); const btnStep = $('step');
const btnMakeLink = $('makeLink'); const btnCopyAll = $('copyAll');
const btnGist = $('gist'); const tokenInput = $('token') as HTMLInputElement;
const maxLen = $('maxLen') as HTMLInputElement; const linksArea = $('links') as HTMLTextAreaElement;

let grid: Grid2D; let topoName: 'Moore'|'VonNeumann'='Moore'; let edges: 'Clip'|'Wrap'='Clip'; let step=0; let playing=false;

function makeTopo(){ const base = topoName==='VonNeumann'? new VonNeumann() : new Moore(); return edges==='Wrap'? new Toroidal(base, ()=>({width:grid.width,height:grid.height})) : base; }
function draw(){ const cell=14; canvas.width=grid.width*cell; canvas.height=grid.height*cell; ctx.fillStyle='#0a0e11'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#e8eef2'; for(let y=0;y<grid.height;y++) for(let x=0;x<grid.width;x++){ const m=(grid as any).cells[y][x]; if(m?.state?.alive) ctx.fillRect(x*cell,y*cell,cell,cell);} }

function describe(m: Manifest){ return `Rule ${m.rule}, seed=${m.seed}, ${m.env.width}x${m.env.height}, ${m.env.topology}/${m.env.edges}, steps=${m.steps}, init=${m.init}`; }

function fromManifest(m: Manifest){
  topoName = m.env.topology; edges = m.env.edges;
  const intr = new Interpreter(rulesFromSpec(parseBS(m.rule)));
  grid = new Grid2D(m.env.width, m.env.height, intr, makeTopo());
  if (m.init==='snapshot' && m.cells){ for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ const c=m.cells[y][x]; if(c) (grid as any).cells[y][x]=new Monad(c.state,c.memory); } }
  else { const rng=createRng(m.seed); const p=m.p ?? 0.22; for(let y=0;y<m.env.height;y++) for(let x=0;x<m.env.width;x++){ (grid as any).cells[y][x] = rng.random()<p? new Monad({alive:true}) : null; } }
  step=0; draw(); info.textContent = describe(m);
}

function toManifest(): Manifest{
  return { schema:'mpl-bundle@1', created:new Date().toISOString(), engine:{version:'2U'}, env:{ width:grid.width, height:grid.height, topology: topoName, edges }, rule:'B3/S23', seed:12345, steps:200, init:'snapshot', cells: snapCells(grid) };
}

function tick(){ grid.tick(); step++; draw(); }
function loop(){ if(!playing) return; const t0=performance.now(); tick(); const dt=Math.max(0, 220-(performance.now()-t0)); setTimeout(loop, dt); }
btnPlay.onclick = ()=> { playing=!playing; btnPlay.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); };
btnStep.onclick = ()=> { if(!playing) tick(); };

btnMakeLink.onclick = async () => {
  linksArea.value = 'Encoding…';
  const man = toManifest();
  const plan = await encodeBundle(man, Math.max(500, Number(maxLen.value)||1800));
  const single = singleURL(plan);
  if (single.length <= (Number(maxLen.value)||1800) + location.origin.length + location.pathname.length){
    linksArea.value = single + '\n';
    status.textContent = `OK: compressed ${plan.algo}; 1 link (len=${single.length})`;
  } else {
    const list = chunkURLs(plan);
    linksArea.value = list.join('\n');
    status.textContent = `Chunked: ${list.length} links; open them in any order to assemble`;
  }
};

btnCopyAll.onclick = async () => { await navigator.clipboard.writeText(linksArea.value); status.textContent = 'Links copied to clipboard'; };

btnGist.onclick = async () => {
  try {
    const man = toManifest();
    if (!tokenInput.value) { status.textContent = 'Provide a GitHub token first'; return; }
    const url = await uploadGist(man, tokenInput.value.trim());
    linksArea.value = url; status.textContent = 'Gist created';
  } catch(e:any){ status.textContent = e.message; }
};

// Auto-hydrate from (single or chunked) hash
(async function initFromHash(){
  const got = ingestFromHash(); if (!got) return;
  if (got.ready){
    try {
      const man = await decodeReady(got.ready);
      fromManifest(man);
      if (got.ready.sha256){
        const actual = await sha256Hex(JSON.stringify(man));
        status.textContent = (got.ready.sha256===actual) ? 'Integrity OK (sha256 match)' : 'WARNING: sha256 mismatch';
      } else {
        status.textContent = got.status === 'reassembled' ? 'Reassembled from chunks' : 'Loaded bundle';
      }
    } catch(e:any){ status.textContent = 'Decode error: '+e.message; }
  } else if (got.status==='partial'){
    status.textContent = 'Chunk stored. Open remaining links to complete.';
  }
})();

// Demo default
fromManifest({ schema:'mpl-bundle@1', created:new Date().toISOString(), engine:{version:'2U'}, env:{width:40,height:30,topology:'Moore',edges:'Clip'}, rule:'B3/S23', seed:12345, steps:200, init:'random', p:0.22 });
```

---

## index-2u.html (NEW — compressed links + chunks + gist UI)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 2U – Compressed & Chunked Share + Gist</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input, textarea { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    textarea { width:100%; min-height: 140px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 2U (Compressed Links • Chunks • Gist)</h1>
    <small>Gzip + base64url • URL chunking • Optional Gist</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <button id="makeLink">Create Share Link(s)</button>
        <label>Max per link</label>
        <input id="maxLen" type="number" value="1800" min="500" max="6000" />
      </div>
      <div class="row">
        <textarea id="links" placeholder="Your share link(s) will appear here…"></textarea>
      </div>
      <div class="row">
        <button id="copyAll">Copy All</button>
      </div>
      <hr />
      <div class="row">
        <input id="token" type="password" placeholder="GitHub token (for Gist upload)" />
        <button id="gist">Upload to Gist</button>
      </div>
      <div class="row"><small id="status"></small></div>
      <div class="row"><small id="info"></small></div>
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
      </div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="560" height="420"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/repro-2u.ts"></script>
</body>
</html>
```

---

## README addendum (2U)

````md
### 2U – Compressed Share Links • Chunked Fragments • Optional Gist Upload

Run the 2U launcher:
```bash
npm i
npm run dev:2u
````

* **Create Share Link(s):** bundles are gzip‑compressed and base64url‑encoded. If the single link exceeds your **Max per link**, you’ll get a list of **chunked links**.
* **Chunked reassembly:** opening any chunk link stores its part locally; once all parts are opened, the app reassembles the bundle automatically.
* **Gist upload (optional):** add a GitHub token and click **Upload to Gist** to get a short, persistent URL.

**Notes**

* Compression uses the browser’s `CompressionStream`/`DecompressionStream` API with a fallback to raw JSON (marked as `raw:`).
* Chunked links are a last‑resort fallback for environments with aggressive URL length limits.
* Keep tokens local; the app never stores them persistently.

```
```
