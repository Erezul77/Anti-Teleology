# MPL Stage 2E – Export / Import Patch

Add **save / load** for complete simulations (including 2C traces and 2D affect stored in memory). This patch introduces a stable JSON snapshot schema with helpers to serialize/deserialize a `Grid2D` world.

## What’s included

* `src/utils/io.ts` — snapshot schema + save/load + `snapshotGrid2D` / `restoreGrid2D`
* `examples/run-2e.ts` — demo that runs, saves to disk, loads back, and continues
* README addendum for 2E usage

> Snapshots include *all* monad `state` and `memory` (so your 2D emotional / adequacy fields are preserved).

---

## src/utils/io.ts

```ts
// Stage 2E – Export / Import helpers for Grid2D
import fs from 'fs';
import path from 'path';
import { Grid2D } from '../runtime/grid.js';
import { Monad } from '../runtime/monad.js';
import type { Interpreter } from '../runtime/interpreter.js';
import { Moore, VonNeumann, type Topology } from '../runtime/topology/index.js';

// ---- Snapshot Schema ----
// Keep this versioned so future changes can migrate cleanly
export type MonadSnapshot = { state: any; memory: any };
export type Grid2DSnapshot = {
  schema: 'mpl-stage-2@1';
  kind: 'Grid2D';
  width: number;
  height: number;
  step: number;           // grid.stepCount
  topology: 'Moore' | 'VonNeumann' | 'Custom';
  cells: (MonadSnapshot | null)[][]; // [y][x]
};

export type Snapshot = Grid2DSnapshot; // for now we only support Grid2D

// ---- Filesystem helpers ----
export function ensureDir(p: string){ fs.mkdirSync(p, { recursive: true }); }
export function saveSnapshot(filePath: string, snap: Snapshot){
  ensureDir(path.dirname(filePath));
  fs.writeFileSync(filePath, JSON.stringify(snap, null, 2), 'utf-8');
}
export function loadSnapshot(filePath: string): Snapshot{
  const raw = fs.readFileSync(filePath, 'utf-8');
  const snap = JSON.parse(raw);
  if (!snap || typeof snap !== 'object') throw new Error('Invalid snapshot: not an object');
  if (snap.schema !== 'mpl-stage-2@1') throw new Error(`Unknown schema: ${snap.schema}`);
  if (snap.kind !== 'Grid2D') throw new Error(`Unsupported kind: ${snap.kind}`);
  return snap as Snapshot;
}

// ---- Grid helpers ----
export function snapshotGrid2D(grid: Grid2D): Grid2DSnapshot{
  const topology = grid.topology instanceof Moore ? 'Moore'
                 : grid.topology instanceof VonNeumann ? 'VonNeumann'
                 : 'Custom';
  const cells = grid.cells.map(row => row.map(m => m ? ({ state: { ...m.state }, memory: { ...m.memory } }) : null));
  return {
    schema: 'mpl-stage-2@1',
    kind: 'Grid2D',
    width: grid.width,
    height: grid.height,
    step: grid.stepCount,
    topology,
    cells,
  };
}

export function restoreGrid2D(snap: Grid2DSnapshot, interpreter: Interpreter, topologyOverride?: Topology): Grid2D{
  let topo: Topology;
  if (topologyOverride) topo = topologyOverride;
  else if (snap.topology === 'Moore') topo = new Moore();
  else if (snap.topology === 'VonNeumann') topo = new VonNeumann();
  else topo = new Moore(); // safe fallback for Custom

  const grid = new Grid2D(snap.width, snap.height, interpreter, topo);
  // place monads
  for (let y = 0; y < snap.height; y++){
    for (let x = 0; x < snap.width; x++){
      const cell = snap.cells[y][x];
      if (cell){ grid.place({ x, y }, new Monad(cell.state, cell.memory)); }
    }
  }
  grid.stepCount = snap.step;
  return grid;
}

// Convenience single-call save/load wrappers
export function exportSimulation(filePath: string, grid: Grid2D){
  const snap = snapshotGrid2D(grid);
  saveSnapshot(filePath, snap);
}
export function importSimulation(filePath: string, interpreter: Interpreter, topologyOverride?: Topology): Grid2D{
  const snap = loadSnapshot(filePath);
  return restoreGrid2D(snap as Grid2DSnapshot, interpreter, topologyOverride);
}
```

---

## examples/run-2e.ts

```ts
import { Interpreter, type Rule } from '../src/runtime/interpreter.js';
import { Grid2D } from '../src/runtime/grid.js';
import { Monad } from '../src/runtime/monad.js';
import { Moore } from '../src/runtime/topology/index.js';
import { Tracer } from '../src/debug/trace.js';
import { exportSimulation, importSimulation } from '../src/utils/io.js';
import fs from 'fs';

// Minimal rules (Life) – compatible with 2C/2D, but no affect here for brevity
const rules: Rule[] = [
  { kind: 'if', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n < 2 || n > 3) env?.mut?.set('state.alive', false);
    } },
  { kind: 'unless', condition: (ctx, env) => !!ctx.state.alive, then: (ctx, env) => {
      const n = env?.countNeighbors(n => !!n.state.alive) ?? 0;
      if (n === 3) env?.mut?.set('state.alive', true);
    } },
];

const interpreter = new Interpreter(rules);
const tracer = new Tracer();

// --- Phase 1: build and run a few ticks ---
const W=10, H=10;
let grid = new Grid2D(W, H, interpreter, new Moore());

// Seed a blinker
const baseMem = { emotion: { joy: 0, sadness: 0, stress: 0, calm: 0 }, adequacy: { alpha: 0.5 } };
grid.place({x:4, y:4}, new Monad({ alive: true },  JSON.parse(JSON.stringify(baseMem))));
grid.place({x:4, y:5}, new Monad({ alive: true },  JSON.parse(JSON.stringify(baseMem))));
grid.place({x:4, y:6}, new Monad({ alive: true },  JSON.parse(JSON.stringify(baseMem))));

for (let i=0; i<3; i++){ grid.tick(tracer); }
console.log('BEFORE SAVE (step=', grid.stepCount, ')');
console.log(grid.toAscii('alive'));

// --- Save ---
const savePath = 'sims/life-step3.json';
fs.mkdirSync('sims', { recursive: true });
exportSimulation(savePath, grid);
console.log('Saved snapshot to', savePath);

// --- Phase 2: Load and continue ---
let grid2 = importSimulation(savePath, interpreter); // topology inferred from snapshot
for (let i=0; i<3; i++){ grid2.tick(tracer); }
console.log('AFTER LOAD+CONTINUE (step=', grid2.stepCount, ')');
console.log(grid2.toAscii('alive'));
```

---

## README addendum (2E)

````md
### 2E – Export / Import

**Save** the current world:
```ts
import { exportSimulation } from './src/utils/io.js';
exportSimulation('sims/world.json', grid);
````

**Load** later and continue:

```ts
import { importSimulation } from './src/utils/io.js';
const grid2 = importSimulation('sims/world.json', interpreter); // infers topology
```

**Run the demo:**

```bash
# from repo root
npx ts-node examples/run-2e.ts
```

**Schema**: `mpl-stage-2@1` – captures `width`, `height`, `step`, `topology`, and every cell’s `{state, memory}` (including 2D emotion/adequacy). If you ever switch to a custom topology, pass a `topologyOverride` to `importSimulation(...)`.

```
```
