# MPL Playground — Stage 4M Patch (Theme System + Dark/High‑Contrast + Presentation Mode)

This patch introduces a **first‑class theming system** (light/dark/high‑contrast, auto), plus a **Presentation Mode** for talks/recordings (fullscreen, larger labels and strokes, minimal chrome). It builds on 4C–4L and stays dependency‑free.

---

## Highlights

* **Theme tokens** piped straight into `CanvasGraph` (bg/grid/edge/node/label/accents).
* **Dark** & **High‑Contrast** palettes, with **Auto** (tracks `prefers-color-scheme`).
* **Accessibility**: WCAG‑friendly contrasts, larger default font in HC, halos tuned for clarity.
* **Presentation Mode**: toggles fullscreen, hides side UI, scales labels/edges, optional dimmed grid.
* **Persistence**: user theme + presentation prefs saved to `localStorage`.
* **Keyboard**: `T` cycles theme (light→dark→hc→auto), `F` toggles fullscreen, `P` toggles presentation.
* **Palette hooks**: quick commands inside the Ctrl/⌘+K palette.

---

## 1) `engine/renderer/canvas/theme.ts` (new) — theme tokens

```ts
// engine/renderer/canvas/theme.ts
export type ThemeId = 'light'|'dark'|'hc';
export type ThemeTokens = {
  id: ThemeId; name: string;
  bg: string; grid: string; edge: string; node: string; nodeSel: string; label: string; accent: string; halo: string;
};

export const Light: ThemeTokens = {
  id:'light', name:'Light',
  bg:'#ffffff', grid:'#f3f4f6', edge:'#d1d5db', node:'#111827', nodeSel:'#6366f1', label:'#374151', accent:'#2563eb', halo:'#60a5fa'
};

export const Dark: ThemeTokens = {
  id:'dark', name:'Dark',
  bg:'#0b0f14', grid:'#111827', edge:'#374151', node:'#e5e7eb', nodeSel:'#93c5fd', label:'#cbd5e1', accent:'#60a5fa', halo:'#38bdf8'
};

export const HighContrast: ThemeTokens = {
  id:'hc', name:'High Contrast',
  bg:'#000000', grid:'#1f2937', edge:'#9ca3af', node:'#ffffff', nodeSel:'#00ff88', label:'#ffffff', accent:'#00e0ff', halo:'#00ffff'
};

export function themeById(id: ThemeId){ return id==='dark' ? Dark : id==='hc' ? HighContrast : Light; }
```

---

## 2) `engine/ui/themeCtx.tsx` (new) — theme/provider + presentation state

```tsx
// engine/ui/themeCtx.tsx
import React from 'react';
import { ThemeId, ThemeTokens, Light, Dark, HighContrast, themeById } from '../renderer/canvas/theme';

export type ThemeState = {
  id: ThemeId | 'auto';
  tokens: ThemeTokens;
  presentation: boolean;
  labelScale: number; // 1.0 default
  strokeScale: number; // 1.0 default
};

const KEY = 'mpl.theme.v1';

function load(): ThemeState {
  try{
    const raw = localStorage.getItem(KEY);
    if (raw){ const s = JSON.parse(raw); return { ...s, tokens: themeById((s.id==='auto'? chooseAuto() : s.id) || 'light') }; }
  }catch{}
  return { id: 'auto', tokens: themeById(chooseAuto()), presentation: false, labelScale: 1, strokeScale: 1 };
}

function chooseAuto(): ThemeId { return matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; }

export const ThemeCtx = React.createContext<{ state: ThemeState; setId:(id: ThemeState['id'])=>void; setPresentation:(on:boolean)=>void; setLabelScale:(n:number)=>void; setStrokeScale:(n:number)=>void }>({
  state: { id:'auto', tokens: Light, presentation:false, labelScale:1, strokeScale:1 }, setId:()=>{}, setPresentation:()=>{}, setLabelScale:()=>{}, setStrokeScale:()=>{}
});

export const ThemeProvider: React.FC<{ children: React.ReactNode }>=({ children })=>{
  const [state, setState] = React.useState<ThemeState>(load());

  // auto follow system
  React.useEffect(()=>{
    if (state.id!=='auto') return;
    const mm = matchMedia('(prefers-color-scheme: dark)');
    const cb = ()=> setState(s=>({ ...s, tokens: themeById(mm.matches? 'dark':'light') }));
    mm.addEventListener('change', cb); return ()=>mm.removeEventListener('change', cb);
  }, [state.id]);

  React.useEffect(()=>{ try{ const { tokens, ...rest } = state; localStorage.setItem(KEY, JSON.stringify(rest)); }catch{} }, [state.id, state.presentation, state.labelScale, state.strokeScale]);

  // reflect on <html> for CSS variables/themes
  React.useEffect(()=>{ const el = document.documentElement; el.dataset.theme = (state.id==='auto' ? state.tokens.id : state.id) as ThemeId; el.classList.toggle('mpl-present', !!state.presentation); }, [state.id, state.tokens.id, state.presentation]);

  const setId = (id: ThemeState['id']) => setState(s => ({ ...s, id, tokens: themeById(id==='auto'? chooseAuto() : id) }));
  const setPresentation = (on:boolean) => setState(s => ({ ...s, presentation: on }));
  const setLabelScale = (n:number) => setState(s => ({ ...s, labelScale: Math.max(0.5, Math.min(2.5, n)) }));
  const setStrokeScale = (n:number) => setState(s => ({ ...s, strokeScale: Math.max(0.5, Math.min(3.0, n)) }));

  return <ThemeCtx.Provider value={{ state, setId, setPresentation, setLabelScale, setStrokeScale }}>{children}</ThemeCtx.Provider>;
};

export function useTheme(){ return React.useContext(ThemeCtx); }
```

---

## 3) `engine/renderer/canvas/CanvasGraph.ts` (update) — apply theme + presentation

```ts
// CanvasGraph.ts — 4M: theming + presentation scaling (snippets)
import type { ThemeTokens } from './theme';

export class CanvasGraph {
  // ...existing fields...
  theme: ThemeTokens = ({
    id:'light', name:'Light',
    bg:'#fff', grid:'#f3f4f6', edge:'#d1d5db', node:'#111827', nodeSel:'#6366f1', label:'#374151', accent:'#2563eb', halo:'#60a5fa'
  } as any);
  presentation = false;
  labelScale = 1; // external multiplier
  strokeScale = 1;

  setTheme(t: ThemeTokens){ this.theme = t; }
  setPresentation(on:boolean){ this.presentation = on; }
  setLabelScale(n:number){ this.labelScale = n; }
  setStrokeScale(n:number){ this.strokeScale = n; }

  private fontPx(base=12){ return (base * this.labelScale * (this.presentation ? 1.25 : 1)); }
  private strokePx(base=1){ return Math.max(1, base * this.strokeScale * (this.presentation ? 1.15 : 1)); }

  draw(){
    const s = this.last; if (!s) return; const ctx = this.ctx; const { width, height } = this.canvas; ctx.save();
    // BG
    ctx.fillStyle = this.theme.bg; ctx.fillRect(0,0,width,height);
    drawGrid(ctx, this.cam, width, height, this.presentation ? 'transparent' : this.theme.grid);

    const P = this.externalPos; const stride = Math.max(1, this.lod.sampleStride|0);

    // Edges
    ctx.lineWidth = this.strokePx(1);
    let drawn = 0, cursor = this.frameEdgeCursor;
    outer: for (const id in s.monads){ const m = s.monads[id]; const a = P?.[id] || m; const nb = m.neighbors||[];
      for (let ei=0; ei<nb.length; ei++){
        const t = nb[ei]; if (id>=t) continue; if ((cursor++ % stride)!==0) continue;
        const b = P?.[t] || s.monads[t]; const A2=worldToScreen(a as any,this.cam), B2=worldToScreen(b as any,this.cam);
        ctx.strokeStyle = this.theme.edge; ctx.globalAlpha = ((a as any).alpha*(b as any).alpha) * 0.95;
        ctx.beginPath(); routeEdge(ctx,A2.x,A2.y,B2.x,B2.y,this.edgeMode,this.curvature,id<t?1:-1); ctx.stroke(); ctx.globalAlpha=1;
        if (++drawn >= this.lod.edgeBudget) break outer;
      }
    }
    this.frameEdgeCursor = cursor;

    // Nodes
    for (const id in s.monads){ const m = s.monads[id]; const p = P?.[id] || m; const scr=worldToScreen(p as any,this.cam); const r = this.getNodeRadius(id);
      ctx.beginPath(); ctx.arc(scr.x, scr.y, r, 0, Math.PI*2); ctx.fillStyle = this.sel===id ? this.theme.nodeSel : this.theme.node; ctx.fill();
    }

    // Labels
    if (this.cam.z >= (this.lod.labelMinZoom || 0)){
      ctx.fillStyle = this.theme.label; ctx.textAlign='center'; ctx.textBaseline='top';
      for (const id in s.monads){ const p=P?.[id]||s.monads[id]; const scr=worldToScreen(p as any, this.cam); const st=this.externalStyle?.[id]; const scale=(st?.labelScale??1)*(this.labelScale); const alpha=(st?.labelAlpha??1)*((p as any).alpha??1);
        ctx.save(); ctx.globalAlpha=alpha; ctx.font = `${this.fontPx(12*scale)}px ui-monospace,monospace`; ctx.fillText(id, scr.x, scr.y + this.getNodeRadius(id) + 2); ctx.restore(); }
    }

    ctx.restore();
  }
}
```

---

## 4) `playground/components/ThemePanel.tsx` (new) — UI for themes + presentation

```tsx
// playground/components/ThemePanel.tsx
import React from 'react';
import { useTheme } from '../../engine/ui/themeCtx';

export const ThemePanel: React.FC = () => {
  const { state, setId, setPresentation, setLabelScale, setStrokeScale } = useTheme();
  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Theme & Presentation</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:10 }}>
        <div className="mpl-row">
          <label>Theme
            <select value={state.id} onChange={e=>setId(e.target.value as any)}>
              <option value="auto">Auto</option>
              <option value="light">Light</option>
              <option value="dark">Dark</option>
              <option value="hc">High‑Contrast</option>
            </select>
          </label>
          <label>Labels <input type="range" min={0.6} max={2.2} step={0.05} value={state.labelScale} onChange={e=>setLabelScale(parseFloat(e.target.value))} /></label>
          <label>Strokes <input type="range" min={0.6} max={3} step={0.05} value={state.strokeScale} onChange={e=>setStrokeScale(parseFloat(e.target.value))} /></label>
        </div>
        <div className="mpl-row">
          <label><input type="checkbox" checked={state.presentation} onChange={e=>setPresentation(e.target.checked)} /> Presentation Mode</label>
          <button className="mpl-btn" onClick={()=>toggleFullscreen()}>{document.fullscreenElement? 'Exit' : 'Enter'} Fullscreen</button>
        </div>
        <div className="mpl-dim">Hotkeys: <kbd>T</kbd> cycle theme • <kbd>P</kbd> presentation • <kbd>F</kbd> fullscreen</div>
      </div>
    </div>
  );
};

function toggleFullscreen(){ const el = document.fullscreenElement ? document : document.documentElement; (el as any).fullscreenElement ? (document as any).exitFullscreen?.() : (document.documentElement as any).requestFullscreen?.(); }
```

---

## 5) `playground/components/CanvasPanel.tsx` (update) — wire provider + hotkeys

```tsx
// playground/components/CanvasPanel.tsx — 4M wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { ThemeProvider, useTheme } from '../../engine/ui/themeCtx';
import { ThemePanel } from './ThemePanel';

export const CanvasPanelWithTheme: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= (props) => <ThemeProvider><InnerCanvasPanel {...props} /></ThemeProvider>;

const InnerCanvasPanel: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= ({ timeline, index, onIndex }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(timeline[Math.max(0, Math.min(index, timeline.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, timeline]);
  const { state, setId, setPresentation } = useTheme();
  const canvasRef = React.useRef<any>(null);

  // push theme + presentation to graph on each frame/toggle
  React.useEffect(() => { const g = (canvasRef.current as any)?._graph; if (!g) return; g.setTheme(state.tokens); g.setLabelScale(state.labelScale); g.setStrokeScale(state.strokeScale); g.setPresentation(state.presentation); g.draw(); }, [state.tokens.id, state.labelScale, state.strokeScale, state.presentation, slim.tick]);

  // hotkeys
  React.useEffect(() => { const onKey = (e: KeyboardEvent) => {
    if (e.key==='p' || e.key==='P'){ setPresentation(p=>!p as any); }
    if (e.key==='f' || e.key==='F'){ e.preventDefault(); toggleFullscreen(); }
    if (e.key==='t' || e.key==='T'){
      const order: any[] = ['light','dark','hc','auto']; const cur = state.id; const idx = Math.max(0, order.indexOf(cur)); setId(order[(idx+1)%order.length]);
    }
  }; window.addEventListener('keydown', onKey); return () => window.removeEventListener('keydown', onKey); }, [state.id]);

  return (
    <div className="mpl-grid">
      <div className="mpl-main">
        {/* existing top rows: heat, scrubber, quick switch, etc. */}
        <GraphCanvas ref={canvasRef} snapshot={slim} /* other props as before */ />
      </div>
      <aside className="mpl-side">
        <ThemePanel />
        {/* existing side panels remain below */}
      </aside>
    </div>
  );
};

function toggleFullscreen(){ const el = document.fullscreenElement ? document : document.documentElement; (el as any).fullscreenElement ? (document as any).exitFullscreen?.() : (document.documentElement as any).requestFullscreen?.(); }
```

> Replace prior `CanvasPanel` export with `CanvasPanelWithTheme` (or rename routes accordingly).

---

## 6) `playground/components/GraphCanvas.tsx` (update) — pass theme props (no API break)

```tsx
// GraphCanvas.tsx — 4M: expose imperative handle for theme already handled in CanvasPanel
import React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';
import { CanvasGraph } from '../../engine/renderer/canvas/CanvasGraph';

export const GraphCanvas = forwardRef<HTMLCanvasElement, any>(function GraphCanvas(props, ref){
  const { snapshot } = props; const el = useRef<HTMLCanvasElement>(null); const graphRef = useRef<CanvasGraph|null>(null);
  useEffect(()=>{ const c = el.current!; const g = new CanvasGraph(c); graphRef.current = g; const ro=new ResizeObserver(()=>{ const r=c.getBoundingClientRect(); g.resize(r.width|0, r.height|0); g.draw(); }); ro.observe(c.parentElement!); return ()=>ro.disconnect(); }, []);
  useEffect(()=>{ const g=graphRef.current; if (!g) return; if (snapshot) g.setSnapshot(snapshot); g.draw(); }, [snapshot?.tick]);
  useImperativeHandle(ref, () => ({ _graph: graphRef.current, get canvas(){ return el.current; } }) as any);
  return <canvas ref={el} style={{ width:'100%', height: 480, display:'block', border:'1px solid var(--mpl-border)', borderRadius: 10, background:'var(--mpl-surface)' }} />;
});
```

---

## 7) Global CSS variables — `playground/styles/debugger.css` (additions)

```css
/* Stage 4M — theme variables + presentation tweaks */
:root{
  --mpl-bg: #ffffff; --mpl-surface: #ffffff; --mpl-border: #e5e7eb; --mpl-text: #111827; --mpl-dim:#6b7280;
}
:root[data-theme='dark']{
  --mpl-bg: #0b0f14; --mpl-surface: #0b0f14; --mpl-border: #1f2937; --mpl-text: #e5e7eb; --mpl-dim:#9ca3af;
}
:root[data-theme='hc']{
  --mpl-bg: #000000; --mpl-surface: #000000; --mpl-border: #374151; --mpl-text: #ffffff; --mpl-dim:#d1d5db;
}

body{ background: var(--mpl-bg); color: var(--mpl-text); }
.mpl-card{ background: var(--mpl-surface); border-color: var(--mpl-border); }
.mpl-card-h{ border-bottom-color: var(--mpl-border); }
.mpl-card-f{ border-top-color: var(--mpl-border); }
.mpl-dim{ color: var(--mpl-dim); }

/* Presentation: hide sidebar, expand main, mute grid via CanvasGraph call */
.mpl-present .mpl-side{ display:none; }
.mpl-present .mpl-grid{ grid-template-columns: 1fr !important; }
```

---

## 8) Palette entries — hook into Ctrl/⌘+K (optional snippet)

```tsx
// In your palette items builder (from 4L), append:
items.push({ id:'theme-light', label:'Theme: Light', run: () => setId('light') });
items.push({ id:'theme-dark', label:'Theme: Dark', run: () => setId('dark') });
items.push({ id:'theme-hc', label:'Theme: High‑Contrast', run: () => setId('hc') });
items.push({ id:'theme-auto', label:'Theme: Auto (system)', run: () => setId('auto') });
items.push({ id:'present', label: state.presentation? 'Exit Presentation' : 'Enter Presentation', run: () => setPresentation(!state.presentation) });
items.push({ id:'fullscreen', label: document.fullscreenElement? 'Exit Fullscreen' : 'Enter Fullscreen', run: () => toggleFullscreen() });
```

---

## 9) Example — `playground/pages/DebugExample4M.tsx`

```tsx
// playground/pages/DebugExample4M.tsx
import React, { useMemo } from 'react';
import { DebuggerPanel } from '../components/DebuggerPanel';
import { ExecutionSnapshot } from '../../engine/debugger/graphTypes';

function ex(): ExecutionSnapshot[]{
  const ids = Array.from({length: 48}, (_,i)=>`N${i}`);
  const monads = ids.map((id,i)=>({ id, neighbors: [], x: Math.cos(i*.3)*200, y: Math.sin(i*.3)*200 }));
  for (let i=0;i<ids.length;i++) for (let j=i+1;j<ids.length;j++) if (Math.random()<0.05){ monads[i].neighbors.push(ids[j]); monads[j].neighbors.push(ids[i]); }
  return [{ tick:0, monads, rulesFired: ['Seed'] } as any];
}

export default function DebugExample4M(){
  const history = useMemo(ex, []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4M — Theme System + Presentation Mode</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Try switching themes in the panel or press <kbd>T</kbd>. Toggle presentation (<kbd>P</kbd>) + fullscreen (<kbd>F</kbd>).</p>
    </div>
  );
}
```

---

## 10) Notes

* **Grid dimming** in Presentation Mode is enforced in `CanvasGraph.draw()` with `transparent` grid ink.
* **Contrast**: The HC palette targets \~7:1 on text against bg; adjust tokens to meet your spec.
* **Persistence & Auto**: When in auto, we still persist the choice `auto` and react to OS changes via `matchMedia`.
* **Inter‑module**: Bookmarks/share links (4K) don’t encode theme; if desired, add `themeId` + presentation flags to `ViewState`.
* **Print**: If you plan PDF export via print, HC theme + Presentation produce the clearest output.

---

## 11) Changelog — Stage 4M

* New: `renderer/canvas/theme.ts` (tokens/presets), `ui/themeCtx.tsx` (provider)
* Updated: `CanvasGraph.ts` (theme + presentation scaling)
* New UI: `ThemePanel.tsx` (controls)
* Updated: `CanvasPanel.tsx` (wrap in provider; hotkeys)
* CSS: theme variables and presentation layout

```
```
