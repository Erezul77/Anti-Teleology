# MPL Playground — Stage 4X Patch (Performance Passes + Frame‑Budget Autotuner)

This patch delivers end‑to‑end performance tooling and an **autotuner** that keeps frame time on budget by adapting layout, rendering, ingest, and plugins in real time. It also adds several micro‑optimizations to the canvas renderer (batching, culling, caching) and a live HUD.

Builds on 4C–4W. No external deps.

---

## Highlights

* **Perf meters**: lightweight `mark()`/`end()` counters with rolling percentiles and per‑subsystem timing.
* **Autotuner**: targets a frame budget (e.g., 16.7ms) with hysteresis; adjusts **layout iterations**, **edge cap**, **label rate**, **plugin draw‑ops cap**, and **ingest fps**.
* **Renderer passes**: edge **batch stroke**, **viewport + length culling**, **sprite node cache**, **label throttling**.
* **Backpressure hooks**: feed pressure to 4R LiveIngest and 4U PluginManager.
* **HUD**: stacked bar of the last frame + p95; traffic‑light status; knobs overview.
* **Panel**: Auto/Manual, targets (60/30), floor/ceil per knob, and sticky overrides.

---

## 1) `engine/core/perf/ring.ts` — tiny rolling stats

```ts
// engine/core/perf/ring.ts — Stage 4X
export class Ring {
  buf: number[]; i=0; filled=false;
  constructor(public n=120){ this.buf=new Array(n).fill(0); }
  push(x:number){ this.buf[this.i++]=x; if(this.i>=this.n){ this.i=0; this.filled=true; } }
  values(){ return this.filled? this.buf.slice(): this.buf.slice(0,this.i); }
  mean(){ const v=this.values(); if(!v.length) return 0; return v.reduce((a,b)=>a+b,0)/v.length; }
  p(q:number){ const v=this.values().slice().sort((a,b)=>a-b); if(!v.length) return 0; const k=Math.min(v.length-1, Math.floor(q*(v.length-1))); return v[k]; }
}
```

---

## 2) `engine/core/perf/meter.ts` — per‑subsystem meters

```ts
// engine/core/perf/meter.ts — Stage 4X
import { Ring } from './ring';
export type MeterSample = { name:string; ms:number };
export class Meter {
  private t0: Record<string, number> = {};
  rings: Record<string, Ring> = {};
  total = new Ring(240);
  mark(name:string){ this.t0[name]=performance.now(); }
  end(name:string){ const t=this.t0[name]; if(t==null) return 0; const ms=performance.now()-t; (this.rings[name] ||= new Ring(120)).push(ms); return ms; }
  pushTotal(ms:number){ this.total.push(ms); }
  read(){ const out:Record<string,{mean:number;p95:number}>={}; for(const k in this.rings){ const r=this.rings[k]; out[k]={ mean:+r.mean().toFixed(2), p95:+r.p(0.95).toFixed(2) }; } return { total:{ mean:+this.total.mean().toFixed(2), p95:+this.total.p(0.95).toFixed(2) }, parts: out }; }
}
```

---

## 3) `engine/renderer/budget.ts` — frame‑budget autotuner

```ts
// engine/renderer/budget.ts — Stage 4X
export type Knobs = { layoutIters:number; edgeCap:number; labelRate:number; pluginOpsCap:number; ingestFps:number };
export type BudgetCfg = { targetMs:number; hiSlack:number; loSlack:number; hysteresisUp:number; hysteresisDown:number; floors:Partial<Knobs>; ceils:Partial<Knobs> };
export type BudgetProbe = { frameMs:number; parts:Record<string,number>; backlog?:number };

export class FrameBudget {
  knobs: Knobs = { layoutIters:6, edgeCap: 25000, labelRate:1, pluginOpsCap:5000, ingestFps:30 };
  private scoreUp=0; private scoreDown=0; constructor(public cfg: BudgetCfg){ }
  update(probe: BudgetProbe){
    const { frameMs } = probe; const { targetMs, hiSlack, loSlack, hysteresisUp, hysteresisDown } = this.cfg;
    if (frameMs > targetMs + hiSlack) { this.scoreDown++; this.scoreUp=Math.max(0,this.scoreUp-1); if (this.scoreDown>=hysteresisDown) { this.degrade(); this.scoreDown=0; } }
    else if (frameMs < targetMs - loSlack) { this.scoreUp++; this.scoreDown=Math.max(0,this.scoreDown-1); if (this.scoreUp>=hysteresisUp) { this.upgrade(); this.scoreUp=0; } }
  }
  private clamp(){ const f=this.cfg.floors, c=this.cfg.ceils; const k=this.knobs; k.layoutIters=cl(k.layoutIters,f.layoutIters??1,c.layoutIters??16); k.edgeCap=cl(k.edgeCap,f.edgeCap??5_000,c.edgeCap??150_000); k.labelRate=cl(k.labelRate,f.labelRate??0,c.labelRate??1); k.pluginOpsCap=cl(k.pluginOpsCap,f.pluginOpsCap??500,c.pluginOpsCap??20_000); k.ingestFps=cl(k.ingestFps,f.ingestFps??10,c.ingestFps??60); }
  private degrade(){ // step down quality progressively
    const k=this.knobs; if (k.layoutIters>4) k.layoutIters-=1; else if (k.edgeCap>20000) k.edgeCap=Math.floor(k.edgeCap*0.85); else if (k.labelRate>0.5) k.labelRate=+(k.labelRate-0.1).toFixed(2); else if (k.pluginOpsCap>1500) k.pluginOpsCap=Math.floor(k.pluginOpsCap*0.8); else if (k.ingestFps>15) k.ingestFps-=3; this.clamp(); }
  private upgrade(){ // step up cautiously
    const k=this.knobs; if (k.ingestFps<45) k.ingestFps+=2; else if (k.pluginOpsCap<8000) k.pluginOpsCap=Math.floor(k.pluginOpsCap*1.1); else if (k.labelRate<1) k.labelRate=+(Math.min(1,k.labelRate+0.1)).toFixed(2) as any; else if (k.edgeCap<120_000) k.edgeCap=Math.floor(k.edgeCap*1.12); else if (k.layoutIters<10) k.layoutIters+=1; this.clamp(); }
}
function cl(x:number,a:number,b:number){ return Math.max(a, Math.min(b, x)); }
```

---

## 4) `engine/renderer/canvas/batch.ts` — batched edges & culling

```ts
// engine/renderer/canvas/batch.ts — Stage 4X
export type Seg = [number,number,number,number];
export function cullSegs(segs:Seg[], w:number,h:number, lenMin=2){
  const out:Seg[]=[]; for(const s of segs){ const [x1,y1,x2,y2]=s; const L=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2); if(L<lenMin*lenMin) continue; if ((x1<0&&x2<0)||(y1<0&&y2<0)||(x1>w&&x2>w)||(y1>h&&y2>h)) continue; out.push(s); } return out;
}
export function batchStroke(ctx:CanvasRenderingContext2D, segs:Seg[], width=1, color='#94a3b8'){ if(!segs.length) return; ctx.save(); ctx.lineWidth=width; ctx.strokeStyle=color; ctx.beginPath(); for(const s of segs){ ctx.moveTo(s[0],s[1]); ctx.lineTo(s[2],s[3]); } ctx.stroke(); ctx.restore(); }
```

---

## 5) `engine/renderer/canvas/sprites.ts` — node sprite cache

```ts
// engine/renderer/canvas/sprites.ts — Stage 4X
export function makeDot(radius=3, color='#111827'){ const c=document.createElement('canvas'); const d=radius*2+2; c.width=c.height=d; const ctx=c.getContext('2d')!; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(d/2,d/2,radius,0,6.283); ctx.fill(); return c; }
```

---

## 6) `engine/renderer/canvas/CanvasGraph.ts` (update) — integrate passes

```ts
// CanvasGraph.ts — 4X excerpts
import { Meter } from '../../core/perf/meter';
import { FrameBudget } from '../budget';
import { batchStroke, cullSegs } from './batch';
import { makeDot } from './sprites';

export class CanvasGraph {
  // ...existing fields...
  meter = new Meter();
  budget = new FrameBudget({ targetMs:16.7, hiSlack:2.5, loSlack:3.0, hysteresisUp:12, hysteresisDown:6, floors:{ layoutIters:3, edgeCap:8000, labelRate:0.3, pluginOpsCap:1000, ingestFps:12 }, ceils:{ layoutIters:12, edgeCap:120000, labelRate:1, pluginOpsCap:10000, ingestFps:60 } });
  dot = makeDot(3);
  _labelStride = 1; // labelRate mapping

  draw(){ const t0=performance.now();
    const { w,h } = this.size();
    // edges → segments (screen space)
    this.meter.mark('edges');
    const segs:any[]=[]; let drawnEdges=0; const cap=this.budget.knobs.edgeCap; const ids=this.nodeIds; for(const id of ids){ const a=this.nodes[id]; const A=this.worldToScreen(a); for(const bId of a.neighbors){ if(id>=bId) continue; const b=this.nodes[bId]; if(!b) continue; const B=this.worldToScreen(b); segs.push([A.x,A.y,B.x,B.y]); if(++drawnEdges>=cap) break; } if(drawnEdges>=cap) break; }
    const segs2=cullSegs(segs,w,h,1.5); batchStroke(this.ctx,segs2,this.edgeWidth(),'#94a3b8');
    this.meter.end('edges');

    // nodes (sprite blit)
    this.meter.mark('nodes'); const r=this.nodeRadius(); for(const id of ids){ const p=this.worldToScreen(this.nodes[id]); this.ctx.drawImage(this.dot, p.x-(this.dot.width>>1), p.y-(this.dot.height>>1)); }
    this.meter.end('nodes');

    // labels (throttled by labelRate)
    this.meter.mark('labels'); const stride = Math.max(1, Math.round(1/(this.budget.knobs.labelRate||0.0001))); if (stride!==this._labelStride) this._labelStride=stride; this.ctx.font=`${Math.round(11*this.camScale())}px ui-sans-serif, system-ui`; this.ctx.fillStyle='#111827'; this.ctx.textBaseline='middle'; let i=0; for(const id of ids){ if ((i++%this._labelStride)!==0) continue; const n=this.nodes[id]; if(!n.label) continue; const P=this.worldToScreen(n); this.ctx.fillText(n.label, P.x+6, P.y); }
    this.meter.end('labels');

    // plugins — respect budget cap
    this.meter.mark('plugins');
    const bundle=this.pluginOps||{}; for(const pid in bundle){ const ops=(bundle[pid]||[]).slice(0, this.budget.knobs.pluginOpsCap); for(const op of ops){ this.replayOp(op); } }
    this.meter.end('plugins');

    // total + autotune
    const ms=performance.now()-t0; this.meter.pushTotal(ms); this.budget.update({ frameMs: ms, parts: {} });
  }
}
```

---

## 7) `engine/stream/ingest.ts` (update) — adaptive fps under pressure

```ts
// LiveIngest — 4X addition (excerpt)
get autotuneFps(){ return this.cfg.fpsCap; }
set autotuneFps(v:number){ this.cfg.fpsCap = Math.max(8, Math.min(60, Math.round(v))); }
```

---

## 8) `engine/plugins/manager.ts` (update) — dynamic draw‑ops cap

```ts
// PluginManager — 4X addition (excerpt)
setOpsCap(cap:number){ for(const p of this.plugs.values()){ p.lastOps = (p.lastOps||[]).slice(0, cap); } }
```

---

## 9) `engine/renderer/layout/incremental.ts` (update) — knobbed iters

```ts
// stepLayout — 4X hook (excerpt)
export function stepLayout(state: LayState, added: string[], removed: string[], iters=8){ /* unchanged body */ }
// Call sites pass iters = budget.knobs.layoutIters
```

---

## 10) `playground/components/PerfHUD.tsx` — live meters + status

```tsx
// playground/components/PerfHUD.tsx
import React from 'react';

export const PerfHUD: React.FC<{ read:()=>{total:{mean:number;p95:number}; parts:Record<string,{mean:number;p95:number}>}; knobs:{[k:string]:any}; status:'ok'|'warn'|'hot' }>
= ({ read, knobs, status }) => {
  const r = read();
  return (
    <div className={`mpl-hud ${status}`}>
      <div className="mpl-hud-row"><strong>frame</strong><span>{r.total.mean}ms</span><span>p95 {r.total.p95}ms</span></div>
      <div className="mpl-hud-row small">
        {Object.entries(r.parts).map(([k,v])=> (<span key={k}>{k} {v.mean}ms</span>))}
      </div>
      <div className="mpl-hud-row small">
        {Object.entries(knobs).map(([k,v])=> (<span key={k}>{k}:{String(v)}</span>))}
      </div>
    </div>
  );
};
```

---

## 11) `playground/components/AutoTunePanel.tsx` — control center

```tsx
// playground/components/AutoTunePanel.tsx
import React from 'react';

export const AutoTunePanel: React.FC<{
  getKnobs:()=>any; setKnobs:(k:any)=>void; getTarget:()=>number; setTarget:(ms:number)=>void; getMode:()=>('auto'|'manual'); setMode:(m:'auto'|'manual')=>void; onApply?:()=>void;
}>
= ({ getKnobs, setKnobs, getTarget, setTarget, getMode, setMode, onApply }) => {
  const [mode,setM] = React.useState(getMode());
  const [target,setT] = React.useState(getTarget());
  const [k,setK] = React.useState(getKnobs());
  function apply(){ setMode(mode); setTarget(target); setKnobs(k); onApply?.(); }
  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Performance</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <label>Mode <select value={mode} onChange={e=>{ setM(e.target.value as any); }}><option>auto</option><option>manual</option></select></label>
          <label>Target <select value={target} onChange={e=>setT(+e.target.value)}><option value={16.7}>60 fps (16.7ms)</option><option value={33.3}>30 fps (33.3ms)</option></select></label>
          <button className="mpl-btn" onClick={apply}>Apply</button>
        </div>
        <details>
          <summary>Knobs</summary>
          {Object.keys(k).map(key=> (
            <label key={key} className="mpl-row">{key}<input type={typeof k[key]==='number'? 'number':'text'} value={k[key]} onChange={e=>setK({...k, [key]: +e.target.value})} style={{ width:100 }} /></label>
          ))}
        </details>
      </div>
    </div>
  );
};
```

---

## 12) `playground/components/CanvasPanel.tsx` — wire HUD + tuner

```tsx
// CanvasPanel.tsx — 4X wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { PerfHUD } from './PerfHUD';
import { AutoTunePanel } from './AutoTunePanel';

export const CanvasPanel: React.FC<{ history: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= ({ history, index, onIndex }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(history[Math.max(0, Math.min(index, history.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, history]);
  const canvasRef = React.useRef<any>(null);
  const [status,setStatus] = React.useState<'ok'|'warn'|'hot'>('ok');

  React.useEffect(()=>{
    const g=(canvasRef.current as any)?._graph; if(!g) return; const id = setInterval(()=>{
      const m=g.meter.read(); const ms=m.total.mean; const tgt=g.budget.cfg.targetMs; setStatus(ms>tgt+4? 'hot' : ms>tgt+1.5? 'warn':'ok');
      // push knobs to subsystems
      g.setPluginOpsCap?.(g.budget.knobs.pluginOpsCap); g.setIngestFps?.(g.budget.knobs.ingestFps); g.setLayoutIters?.(g.budget.knobs.layoutIters);
    }, 400); return ()=>clearInterval(id);
  }, [canvasRef.current]);

  function getKnobs(){ const g=(canvasRef.current as any)?._graph; return g? { ...g.budget.knobs }: { layoutIters:6, edgeCap:25000, labelRate:1, pluginOpsCap:5000, ingestFps:30 }; }
  function setKnobs(k:any){ const g=(canvasRef.current as any)?._graph; if(!g) return; g.budget.knobs={ ...g.budget.knobs, ...k }; }
  function getTarget(){ const g=(canvasRef.current as any)?._graph; return g? g.budget.cfg.targetMs : 16.7; }
  function setTarget(ms:number){ const g=(canvasRef.current as any)?._graph; if(!g) return; g.budget.cfg.targetMs=ms; }
  function getMode(){ return 'auto'; }
  function setMode(_m:any){ /* manual mode hook if needed */ }

  return (
    <div className="mpl-grid" style={{ position:'relative' }}>
      <div className="mpl-main">
        <div style={{ position:'relative' }}>
          <GraphCanvas ref={canvasRef} snapshot={slim} />
          <PerfHUD read={()=> (canvasRef.current as any)?._graph?.meter.read() } knobs={getKnobs()} status={status} />
        </div>
      </div>
      <aside className="mpl-side">
        <AutoTunePanel getKnobs={getKnobs} setKnobs={setKnobs} getTarget={getTarget} setTarget={setTarget} getMode={getMode} setMode={setMode} />
      </aside>
    </div>
  );
};
```

---

## 13) Styles — `playground/styles/debugger.css` (additions)

```css
/* Stage 4X — perf HUD + panel */
.mpl-hud { position:absolute; right:12px; top:12px; background:rgba(255,255,255,0.9); border:1px solid var(--mpl-border); border-radius:12px; padding:8px 10px; display:grid; gap:6px; min-width:200px; }
.mpl-hud.hot { box-shadow:0 0 0 2px #fecaca inset; }
.mpl-hud.warn { box-shadow:0 0 0 2px #fde68a inset; }
.mpl-hud .mpl-hud-row { display:flex; justify-content:space-between; gap:8px; align-items:center; }
.mpl-hud .mpl-hud-row.small { font-size:12px; color:#374151; flex-wrap:wrap; }
```

---

## 14) Example — `playground/pages/DebugExample4X.tsx`

```tsx
// playground/pages/DebugExample4X.tsx
import React, { useMemo } from 'react';
import { DebuggerPanel } from '../components/DebuggerPanel';
import { ExecutionSnapshot } from '../../engine/debugger/graphTypes';

function makeHistory(): ExecutionSnapshot[]{
  const ids = Array.from({length: 500}, (_,i)=> 'N'+i);
  const monads = ids.map((id,i)=>({ id, neighbors: [] as string[], x: Math.cos(i*.09)*300 + (Math.random()-0.5)*6, y: Math.sin(i*.09)*300 + (Math.random()-0.5)*6 }));
  for (let i=0;i<ids.length;i++) for (let j=i+1;j<ids.length;j++) if (Math.random()<0.01){ monads[i].neighbors.push(ids[j]); monads[j].neighbors.push(ids[i]); }
  return [{ tick:0, monads, rulesFired:['Seed'] } as any];
}

export default function DebugExample4X(){
  const history = useMemo(makeHistory, []);
  return (
    <div style={{ padding:24 }}>
      <h1>Stage 4X — Performance & Autotuner</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Watch the HUD as you pan/zoom. The autotuner adapts edge cap, labels, layout iters, plugin ops, and ingest fps to stay on budget.</p>
    </div>
  );
}
```

---

## 15) Notes

* **Hysteresis**: `hysteresisDown` is smaller than `hysteresisUp` to react fast to overload and recover cautiously.
* **Edge cap strategy**: We cap per frame, not globally; edges eventually cycle across frames through camera movement or time.
* **Label rate**: Convert `labelRate∈[0..1]` to a stride. For stability, the stride changes only when the rounded value changes.
* **Sprites**: The dot sprite skips thousands of `arc()` calls; consider caching multiple radii if you support dynamic sizing.
* **Budget propagation**: Canvas → PluginManager via `setOpsCap`, Canvas → LiveIngest via `autotuneFps` setter (see 7), Canvas → layout via `layoutIters` param.
* **Future**: Switch to WebGL for line instancing if needed; the batch pass mirrors the API.

---

## 16) Changelog — Stage 4X

* New: `engine/core/perf/{ring,meter}.ts`
* New: `engine/renderer/{budget.ts}`
* New: `engine/renderer/canvas/{batch.ts,sprites.ts}`
* Updated: `CanvasGraph.ts` (meters, autotuner, batching, culling, sprite nodes, label throttling)
* Updated: `stream/ingest.ts` (adaptive fps)
* Updated: `plugins/manager.ts` (ops cap setter)
* Updated: `incremental.ts` (iters knob)
* New UI: `PerfHUD.tsx`, `AutoTunePanel.tsx`
* Updated: `CanvasPanel.tsx` (wire HUD + tuner)
* Styles: HUD

```
```
