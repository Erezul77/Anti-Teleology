# MPL Playground — Stage 4D Patch (Barnes–Hut / Grid Repulsion for Big Graphs)

This patch scales the 4B/4C canvas engine to thousands of nodes using two interchangeable repulsion strategies:

* **Barnes–Hut (quadtree)** — O(n log n) with opening angle `theta`.
* **Uniform Grid** — O(n) expected for local interactions with a tunable cell size.

Everything is browser‑local and dependency‑free. You can switch strategies at runtime.

---

## Highlights

* Pluggable **repulsion modes**: `naive` (4B), `grid`, and `barnes`.
* Tunables: **theta** (Barnes–Hut), **cellSize** (Grid), global **repulsion/spring/damping** from 4B.
* Auto‑seed & sticky positions preserved; integrates with interpolation and playback from 4B/4C.
* Lightweight perf HUD: nodes, edges, last repulsion ms.

---

## 1) `engine/renderer/layout/gridRepulsion.ts` (new)

```ts
// engine/renderer/layout/gridRepulsion.ts
// Stage 4D — Uniform grid for near‑field repulsion

import type { SnapshotSlim } from "../../core/perf/timelineDelta";
import type { ForceParams, ForceState } from "./force";

export interface GridParams { cellSize: number; radiusCells: number } // interact with cell and neighbors within radius
export const DefaultGrid: GridParams = { cellSize: 120, radiusCells: 1 };

export function stepLayoutGrid(state: ForceState, snap: SnapshotSlim, params: ForceParams, grid: GridParams = DefaultGrid, dt = 1){
  const ids = Object.keys(state.pos); const n = ids.length; if (!n) return;
  const { repulsion, spring, rest, damping, maxStep } = params;
  const { cellSize, radiusCells } = grid;

  // Build grid buckets
  const buckets = new Map<string, string[]>();
  function key(ix: number, iy: number){ return ix+","+iy; }
  for (const id of ids){ const p = state.pos[id]; const ix = Math.floor(p.x / cellSize), iy = Math.floor(p.y / cellSize); const k = key(ix,iy); const b = buckets.get(k); if (b) b.push(id); else buckets.set(k, [id]); }

  // Repulsion within neighborhood
  for (const id of ids){
    const a = state.pos[id]; if (a.pinned) continue;
    const ix = Math.floor(a.x / cellSize), iy = Math.floor(a.y / cellSize);
    for (let dx=-radiusCells; dx<=radiusCells; dx++){
      for (let dy=-radiusCells; dy<=radiusCells; dy++){
        const bkt = buckets.get(key(ix+dx, iy+dy)); if (!bkt) continue;
        for (const j of bkt){ if (j===id) continue; const b = state.pos[j]; if (b.pinned) continue; let rx = a.x - b.x, ry = a.y - b.y; let d2 = rx*rx + ry*ry; if (d2 < 1) d2 = 1; const cut = (cellSize*radiusCells*1.5); if (d2 > cut*cut) continue; const f = repulsion / d2; const invd = 1 / Math.sqrt(d2); rx *= invd; ry *= invd; a.vx += rx * f * dt; a.vy += ry * f * dt; }
      }
    }
  }

  // Springs along edges
  for (const id in snap.monads){ const m = snap.monads[id]; const A = state.pos[id]; if (!A) continue; for (const t of (m.neighbors||[])){ const B = state.pos[t]; if (!B) continue; let dx = A.x - B.x, dy = A.y - B.y; const d = Math.max(1, Math.hypot(dx,dy)); const k = spring * (d - rest); const nx = dx/d, ny=dy/d; if (!A.pinned){ A.vx -= nx * k * dt; A.vy -= ny * k * dt; } if (!B.pinned){ B.vx += nx * k * dt; B.vy += ny * k * dt; } } }

  // Integrate
  for (const id of ids){ const p = state.pos[id]; if (p.pinned){ p.vx=p.vy=0; continue; } p.vx *= damping; p.vy *= damping; let dx = p.vx * dt, dy = p.vy * dt; const mag = Math.hypot(dx,dy); if (mag>params.maxStep){ const s = params.maxStep/Math.max(1e-6,mag); dx*=s; dy*=s; } p.x += dx; p.y += dy; }
}
```

---

## 2) `engine/renderer/layout/barnesHut.ts` (new)

```ts
// engine/renderer/layout/barnesHut.ts
// Stage 4D — Quadtree Barnes–Hut repulsion

import type { SnapshotSlim } from "../../core/perf/timelineDelta";
import type { ForceParams, ForceState } from "./force";

export interface BHParams { theta: number; softening: number; worldPad: number }
export const DefaultBH: BHParams = { theta: 0.9, softening: 2.0, worldPad: 40 };

interface Node { x: number; y: number; w: number; mass: number; cx: number; cy: number; p?: { id: string; x:number; y:number }; q?: [Node,Node,Node,Node] }

function makeNode(x:number,y:number,w:number): Node { return { x, y, w, mass: 0, cx: 0, cy: 0 }; }

function insert(nd: Node, id: string, x: number, y: number){
  if (!nd.q && !nd.p){ nd.p = { id, x, y }; nd.mass = 1; nd.cx = x; nd.cy = y; return; }
  if (!nd.q){ // subdivide
    nd.q = [ makeNode(nd.x, nd.y, nd.w/2), makeNode(nd.x+nd.w/2, nd.y, nd.w/2), makeNode(nd.x, nd.y+nd.w/2, nd.w/2), makeNode(nd.x+nd.w/2, nd.y+nd.w/2, nd.w/2) ];
    if (nd.p){ const p = nd.p; nd.p = undefined; place(nd, p.id, p.x, p.y); }
  }
  place(nd, id, x, y);
}

function place(nd: Node, id: string, x: number, y: number){ const midx = nd.x + nd.w/2, midy = nd.y + nd.w/2; const idx = (y>midy?2:0) + (x>midx?1:0); const child = nd.q![idx]; insert(child, id, x, y); nd.mass += 1; nd.cx += x; nd.cy += y; }

function finalize(nd: Node){ if (nd.q){ nd.mass = 0; nd.cx = 0; nd.cy = 0; for (const c of nd.q){ finalize(c); nd.mass += c.mass; nd.cx += c.cx; nd.cy += c.cy; } } }

function worldBounds(state: ForceState, pad: number){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for (const id in state.pos){ const p = state.pos[id]; if (p.x<minX) minX=p.x; if (p.y<minY) minY=p.y; if (p.x>maxX) maxX=p.x; if (p.y>maxY) maxY=p.y; } const w = Math.max(2, Math.max(maxX-minX, maxY-minY) + pad*2); const x = minX - pad; const y = minY - pad; return { x, y, w };
}

export function stepLayoutBarnes(state: ForceState, snap: SnapshotSlim, params: ForceParams, bh: BHParams = DefaultBH, dt = 1){
  const ids = Object.keys(state.pos); const n = ids.length; if (!n) return; const { repulsion, spring, rest, damping, maxStep } = params;
  // Build quadtree over current positions
  const bounds = worldBounds(state, bh.worldPad); const root = makeNode(bounds.x, bounds.y, bounds.w); for (const id of ids){ const p = state.pos[id]; insert(root, id, p.x, p.y); } finalize(root);

  // Repulsion via tree walk
  for (const id of ids){ const a = state.pos[id]; if (a.pinned) continue; let fx=0, fy=0; walkRepel(root, id, a.x, a.y, bh, repulsion, (dx,dy,f)=>{ fx += dx*f; fy += dy*f; }); a.vx += fx * dt; a.vy += fy * dt; }

  // Springs (same as other modes)
  for (const id in snap.monads){ const m = snap.monads[id]; const A = state.pos[id]; if (!A) continue; for (const t of (m.neighbors||[])){ const B = state.pos[t]; if (!B) continue; let dx = A.x - B.x, dy = A.y - B.y; const d = Math.max(1, Math.hypot(dx,dy)); const k = spring * (d - rest); const nx = dx/d, ny=dy/d; if (!A.pinned){ A.vx -= nx * k * dt; A.vy -= ny * k * dt; } if (!B.pinned){ B.vx += nx * k * dt; B.vy += ny * k * dt; } } }

  // Integrate
  for (const id of ids){ const p = state.pos[id]; if (p.pinned){ p.vx=p.vy=0; continue; } p.vx *= damping; p.vy *= damping; let dx = p.vx * dt, dy = p.vy * dt; const mag = Math.hypot(dx,dy); if (mag>maxStep){ const s = maxStep/Math.max(1e-6,mag); dx*=s; dy*=s; } p.x += dx; p.y += dy; }
}

function walkRepel(nd: Node, id: string, x: number, y: number, bh: BHParams, repulsion: number, emit: (nx:number,ny:number,f:number)=>void){
  const dx = (nd.cx/Math.max(1, nd.mass)) - x, dy = (nd.cy/Math.max(1, nd.mass)) - y; const d = Math.sqrt(dx*dx + dy*dy) + bh.softening; if (!nd.q){ // leaf
    if (nd.p && nd.p.id !== id){ const f = repulsion / (d*d); const nx = dx/d, ny = dy/d; emit(nx, ny, f); } return; }
  const s_over_d = nd.w / d; if (s_over_d < bh.theta){ const f = (repulsion * nd.mass) / (d*d); const nx = dx/d, ny = dy/d; emit(nx, ny, f); return; } else { for (const c of nd.q!) walkRepel(c, id, x, y, bh, repulsion, emit); }
}
```

---

## 3) `playground/components/GraphCanvas.tsx` (update) — selectable repulsion modes + perf HUD

```tsx
// playground/components/GraphCanvas.tsx (4C → 4D)
import React, { useEffect, useRef, useState } from 'react';
import { CanvasGraph } from '../../engine/renderer/canvas/CanvasGraph';
import { SnapshotSlim } from '../../engine/core/perf/timelineDelta';
import { ForceState, DefaultForce, ensureState, seedFromSnapshot, pinAt, unpin } from '../../engine/renderer/layout/force';
import { stepLayoutGrid, DefaultGrid, GridParams } from '../../engine/renderer/layout/gridRepulsion';
import { stepLayoutBarnes, DefaultBH, BHParams } from '../../engine/renderer/layout/barnesHut';
import { lerpPositions, BlendPos } from '../../engine/renderer/anim/transition';

export type LayoutMode = 'naive'|'grid'|'barnes';

export const GraphCanvas: React.FC<{
  snapshot: SnapshotSlim | null; hotRule?: string | null; onPick?: (id: string|null) => void;
  physics?: boolean; physicsStrength?: number; blendT?: number; style?: Record<string, any>; prevStyle?: Record<string, any>;
  edgeMode?: 'straight'|'arc'|'quad'; curvA?: number; curvB?: number;
  layoutMode?: LayoutMode; gridParams?: Partial<GridParams>; bhParams?: Partial<BHParams>; onPerf?: (ms:number)=>void;
}>
= ({ snapshot, hotRule=null, onPick, physics=true, physicsStrength=1, blendT=1, style, prevStyle, edgeMode='arc', curvA=0.12, curvB=0.28, layoutMode='grid', gridParams={}, bhParams={}, onPerf }) => {
  const ref = useRef<HTMLCanvasElement>(null); const graphRef = useRef<CanvasGraph | null>(null);
  const [force] = useState<ForceState>({ pos: {} }); const [drag, setDrag] = useState<{ id: string; offX:number; offY:number }|null>(null);

  // init
  useEffect(() => { const c = ref.current!; const g = new CanvasGraph(c); g.setEdgeMode(edgeMode); graphRef.current = g; const ro = new ResizeObserver(()=>{ const r = c.getBoundingClientRect(); g.resize(r.width|0, r.height|0); g.draw(); }); ro.observe(c.parentElement!); return () => ro.disconnect(); }, []);

  // snapshot
  useEffect(() => { const g = graphRef.current; if (!g || !snapshot) return; ensureState(force, snapshot); if (!g.prevPos) seedFromSnapshot(force, snapshot); g.setSnapshot(snapshot as any); g.setHotRule(hotRule || null); g.setEdgeMode(edgeMode); g.draw(); }, [snapshot?.tick, hotRule, edgeMode]);

  // RAF loop (with timed repulsion step)
  useEffect(() => { let raf=0; const g = graphRef.current!; let last = performance.now();
    function frame(ts:number){ const dt = Math.min(1/30, (ts-last)/1000); last = ts; if (physics && snapshot){ const t0 = performance.now(); const scale = physicsStrength; const FP = { ...DefaultForce, spring: DefaultForce.spring*scale, repulsion: DefaultForce.repulsion*scale };
        if (layoutMode==='barnes') stepLayoutBarnes(force, snapshot, FP, { ...DefaultBH, ...bhParams }, dt*60);
        else if (layoutMode==='grid') stepLayoutGrid(force, snapshot, FP, { ...DefaultGrid, ...gridParams }, dt*60);
        else { // naive fallback: borrow 4B repulsion via grid with large radius
          stepLayoutGrid(force, snapshot, FP, { cellSize: 1e6, radiusCells: 1 }, dt*60);
        }
        onPerf?.(performance.now() - t0);
      }
      const pos: Record<string, BlendPos> = {}; for (const id in force.pos) pos[id] = { x: force.pos[id].x, y: force.pos[id].y, alpha: 1 };
      const t = Math.max(0, Math.min(1, blendT)); g.setExternalPositions(g.prevPos ? lerpPositions(g.prevPos as any, pos, t) : pos);
      const curv = (1-t) * (curvA||0) + t * (curvB||0); g.setCurvature(curv); if (style){ const S = prevStyle || style; const M: any = {}; for (const id in style){ const a:any=S[id]||style[id]; const b:any=style[id]; M[id] = { r: a.r + (b.r-a.r)*t, labelScale: a.labelScale + (b.labelScale-a.labelScale)*t, labelAlpha: a.labelAlpha + (b.labelAlpha-a.labelAlpha)*t }; } g.setStyleOverrides(M); }
      g.draw(); raf = requestAnimationFrame(frame); }
    raf = requestAnimationFrame(frame); return () => cancelAnimationFrame(raf); }, [snapshot?.tick, physics, physicsStrength, blendT, style, prevStyle, curvA, curvB, layoutMode, gridParams?.cellSize, gridParams?.radiusCells, bhParams?.theta, bhParams?.softening]);

  // drag-pin
  useEffect(() => { const c = ref.current!; const g = graphRef.current!; const md = (e:MouseEvent)=>{ const hit = g.hitNode(...relative(c,e)); if (!hit) return; const p = g.getScreenPos(hit); setDrag({ id: hit, offX: p.x - e.clientX, offY: p.y - e.clientY }); pinAt(force, hit, force.pos[hit]?.x||0, force.pos[hit]?.y||0); onPick?.(hit); };
    const mm = (e:MouseEvent)=>{ if (!drag) return; const world = g.screenToWorld(e.clientX + drag.offX, e.clientY + drag.offY); pinAt(force, drag.id, world.x, world.y); };
    const mu = ()=>setDrag(null); const dbl=(e:MouseEvent)=>{ const hit = g.hitNode(...relative(c,e)); if (hit) unpin(force, hit); };
    c.addEventListener('mousedown', md); window.addEventListener('mousemove', mm); window.addEventListener('mouseup', mu); c.addEventListener('dblclick', dbl); return ()=>{ c.removeEventListener('mousedown', md); window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); c.removeEventListener('dblclick', dbl); }; }, [snapshot?.tick, drag?.id]);

  return <canvas ref={ref} style={{ width:'100%', height: 480, display:'block', border:'1px solid #e5e7eb', borderRadius: 10 }} />;
};

function relative(c: HTMLCanvasElement, e: MouseEvent){ const r = c.getBoundingClientRect(); return [e.clientX - r.left, e.clientY - r.top] as [number, number]; }
```

---

## 4) `playground/components/CanvasPanel.tsx` (update) — layout controls + perf HUD

```tsx
// playground/components/CanvasPanel.tsx (4C → 4D)
import React from 'react';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { GraphCanvas } from './GraphCanvas';
import { CanvasPlaybackPanel } from './CanvasPlaybackPanel';
import { PlayheadScrubber } from './PlayheadScrubber';
import { styleForSnapshot, DefaultStyle } from '../../engine/renderer/style/nodeStyler';
import { ease } from '../../engine/renderer/anim/transition';

export const CanvasPanel: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void; hotRule?: string|null }>
= ({ timeline, index, onIndex, hotRule=null }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(timeline[Math.max(0, Math.min(index, timeline.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, timeline]);

  const [playing, setPlaying] = React.useState(false);
  const [speed, setSpeed] = React.useState(1);
  const [blendMs, setBlendMs] = React.useState(240);
  const [phys, setPhys] = React.useState(1);
  const [blendT, setBlendT] = React.useState(1);
  const [edgeMode, setEdgeMode] = React.useState<'straight'|'arc'|'quad'>('arc');
  const [curvA, setCurvA] = React.useState(0.10); const [curvB, setCurvB] = React.useState(0.28);
  const [layoutMode, setLayoutMode] = React.useState<'naive'|'grid'|'barnes'>('barnes');
  const [cellSize, setCellSize] = React.useState(140);
  const [radiusCells, setRadiusCells] = React.useState(1);
  const [theta, setTheta] = React.useState(0.9);
  const [softening, setSoftening] = React.useState(2.0);
  const [lastMs, setLastMs] = React.useState(0);

  const lastIdx = React.useRef(index);
  const animStart = React.useRef<number>(0);

  const styleNow = React.useMemo(() => styleForSnapshot(slim, DefaultStyle), [slim.tick]);
  const stylePrev = React.useMemo(() => { const prevIdx = Math.max(0, Math.min(timeline.length-1, index-1)); const sPrev = ensurePositions(toSlim(timeline[prevIdx] || { tick: prevIdx, monads: [], rulesFired: [] } as any)); return styleForSnapshot(sPrev, DefaultStyle); }, [index, timeline]);

  // Playback
  React.useEffect(() => { if (!playing) return; let raf = 0; function step(){ onIndex?.(i => Math.min(timeline.length-1, (typeof i==='number'?i:i)+Math.max(1, Math.round(speed))) as any); raf = requestAnimationFrame(step); } raf = requestAnimationFrame(step); return () => cancelAnimationFrame(raf); }, [playing, speed, timeline.length]);
  React.useEffect(() => { if (index !== lastIdx.current){ animStart.current = performance.now(); lastIdx.current = index; setBlendT(0); } }, [index]);
  React.useEffect(() => { if (blendMs<=0){ setBlendT(1); return; } let raf=0; function frame(){ const t = Math.min(1, (performance.now()-animStart.current)/Math.max(1, blendMs)); setBlendT(t); if (t<1) raf=requestAnimationFrame(frame); } raf=requestAnimationFrame(frame); return () => cancelAnimationFrame(raf); }, [index, blendMs]);

  const activity = React.useMemo(() => timeline.map(s => (s.rulesFired||[]).length), [timeline]);

  return (
    <div className="mpl-canvas">
      <CanvasPlaybackPanel playing={playing} onToggle={()=>setPlaying(p=>!p)} speed={speed} setSpeed={setSpeed} blendMs={blendMs} setBlendMs={setBlendMs} phys={phys} setPhys={setPhys} />
      <div className="mpl-row">
        <label>Layout
          <select value={layoutMode} onChange={e=>setLayoutMode(e.target.value as any)}>
            <option value="grid">grid</option>
            <option value="barnes">barnes</option>
            <option value="naive">naive</option>
          </select>
        </label>
        {layoutMode==='grid' && (<>
          <label>cell<input type="number" step={10} value={cellSize} onChange={e=>setCellSize(parseInt(e.target.value)||80)} style={{ width: 80 }} /></label>
          <label>radius<input type="number" step={1} value={radiusCells} onChange={e=>setRadiusCells(parseInt(e.target.value)||1)} style={{ width: 80 }} /></label>
        </>)}
        {layoutMode==='barnes' && (<>
          <label>theta<input type="number" step={0.05} value={theta} onChange={e=>setTheta(parseFloat(e.target.value)||0.8)} style={{ width: 80 }} /></label>
          <label>soften<input type="number" step={0.1} value={softening} onChange={e=>setSoftening(parseFloat(e.target.value)||1.0)} style={{ width: 80 }} /></label>
        </>)}
        <label>Edges
          <select value={edgeMode} onChange={e=>setEdgeMode(e.target.value as any)}>
            <option value="straight">straight</option>
            <option value="arc">arc</option>
            <option value="quad">quad</option>
          </select>
        </label>
        <label>Curv A<input type="number" step={0.02} value={curvA} onChange={e=>setCurvA(parseFloat(e.target.value)||0} style={{ width: 80 }} /></label>
        <label>Curv B<input type="number" step={0.02} value={curvB} onChange={e=>setCurvB(parseFloat(e.target.value)||0} style={{ width: 80 }} /></label>
        <div className="mpl-dim">perf: {lastMs.toFixed(2)} ms • nodes {Object.keys(slim.monads).length}</div>
      </div>

      <PlayheadScrubber length={timeline.length} index={index} setIndex={i=>onIndex?.(i)} activity={activity} />

      <GraphCanvas
        snapshot={slim}
        hotRule={hotRule}
        physics={true}
        physicsStrength={phys}
        blendT={blendT}
        style={styleNow as any}
        prevStyle={stylePrev as any}
        edgeMode={edgeMode}
        curvA={curvA}
        curvB={curvB}
        layoutMode={layoutMode}
        gridParams={{ cellSize, radiusCells }}
        bhParams={{ theta, softening }}
        onPerf={setLastMs}
      />

      <div className="mpl-small mpl-dim">Tick {slim.tick} • {Object.keys(slim.monads).length} monads</div>
    </div>
  );
};
```

---

## 5) `playground/styles/debugger.css` (additions)

```css
/* Stage 4D — Layout perf HUD tweaks */
.mpl-row .mpl-dim { margin-left: auto; }
```

---

## 6) Example — `playground/pages/DebugExample4D.tsx`

```tsx
// playground/pages/DebugExample4D.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

function randomGraph(n=800, p=0.004){
  const ids = Array.from({length:n}, (_,i)=>String(i));
  const monads = ids.map((id,i)=>({ id, neighbors: [] as string[], x: (Math.random()-0.5)*800, y: (Math.random()-0.5)*800 }));
  for (let i=0;i<n;i++) for (let j=i+1;j<n;j++) if (Math.random()<p){ monads[i].neighbors.push(String(j)); monads[j].neighbors.push(String(i)); }
  return { tick: 0, monads, rulesFired: [] } as unknown as ExecutionSnapshot;
}

export default function DebugExample4D() {
  const history: ExecutionSnapshot[] = useMemo(() => {
    // single tick for perf demo; duplicate with minor jitters for 3 ticks
    const base = randomGraph(1000, 0.003);
    const jitter = (s: ExecutionSnapshot, t: number) => ({
      tick: t, monads: s.monads.map(m => ({ ...m, x: (m as any).x + (Math.random()-0.5)*10, y: (m as any).y + (Math.random()-0.5)*10 })), rulesFired: []
    } as ExecutionSnapshot);
    return [ base, jitter(base,1), jitter(base,2) ];
  }, []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4D — Barnes–Hut / Grid Repulsion for Big Graphs</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 7) Notes & Tips

* **When to use what**

  * `grid` works great up to a few thousand nodes when graphs are fairly uniform.
  * `barnes` shines for larger or clustered graphs; tune **theta** (0.7–1.2 typical) and **softening** to avoid jitter.
* **Auto mode**: you can trivially auto‑switch by node count (e.g., `naive < 300`, `grid < 2500`, else `barnes`). The panel leaves full control to you.
* **Stability**: positions are maintained across ticks via `ForceState`; new nodes inherit snapshot positions.
* **Future 4E idea**: move repulsion to a **Web Worker** and double‑buffer positions for even higher FPS.

---

## 8) Changelog — Stage 4D

* New engine: `layout/gridRepulsion.ts`, `layout/barnesHut.ts`.
* Updated UI: `GraphCanvas.tsx` (repulsion modes + perf timing), `CanvasPanel.tsx` (layout controls + perf HUD).
* CSS: small HUD tweak.

```
```
