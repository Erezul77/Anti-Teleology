# MPL Playground — Stage 4V Patch (Collab: Presence, Multi‑Cursor, Comments & Timeline Reviews)

This patch adds real‑time collaboration to the MPL Playground: **presence & ghost cursors**, **multi‑cursor selections**, **comment threads** (anchored to nodes/edges/areas or timeline ticks), and **timeline reviews** with approve/changes flows. Zero external deps; a tiny WS protocol powers sync. Everything works offline with an op queue.

Builds on 4C–4U.

---

## Highlights

* **Presence**: participants list, color chips, idle/active, per‑user pointers on canvas
* **Multi‑cursor**: remote **selections** on nodes/edges, text cursors in notes (per‑item locks with lease)
* **Comments**: threads with replies, mentions, reactions, resolve/reopen, filters (mine/unresolved/anchor)
* **Anchors**: `node:{id}`, `edge:{a,b}`, `area:{x,y,w,h}`, `tick:{n}` (timeline)
* **Reviews**: open a review on a tick or range; collect threads; mark **Approved** or **Changes requested**
* **Offline**: queue ops, lamport clocks, rebase on reconnect; conflict = forked thread + toast
* **Security**: room roles (viewer/editor/mod), ephemeral token; no PII stored in pack/share by default

---

## 1) `engine/collab/types.ts` — protocol + models

```ts
// engine/collab/types.ts — Stage 4V
export type User = { id:string; name:string; color:string; avatar?:string|null; lastSeen:number; role:'viewer'|'editor'|'mod' };
export type Presence = { id:string; xy?:{x:number;y:number}; sel?:{ nodes:string[]; edges:string[] }; typing?:{ noteId:string; pos:number }|null; idle?:boolean };

export type Anchor =
  | { k:'node'; id:string }
  | { k:'edge'; a:string; b:string }
  | { k:'area'; x:number; y:number; w:number; h:number }
  | { k:'tick'; n:number };

export type Comment = { id:string; author:string; createdAt:number; body:string; edits?:Array<{ at:number; body:string }>; reactions?:Record<string, string[]> };
export type Thread = { id:string; anchor: Anchor; open:boolean; comments: Comment[]; assignees?:string[]; tags?:string[] };

export type ReviewState = 'open'|'approved'|'changes';
export type Review = { id:string; title:string; range:{ from:number; to:number }|{ at:number }; state: ReviewState; threads:string[]; createdBy:string; createdAt:number };

export type Op =
  | { t:'join'; user: User }
  | { t:'presence'; p: Presence }
  | { t:'thread:new'; thread: Thread }
  | { t:'thread:update'; id:string; patch: Partial<Thread> }
  | { t:'comment:add'; threadId:string; comment: Comment }
  | { t:'comment:edit'; threadId:string; commentId:string; body:string }
  | { t:'comment:react'; threadId:string; commentId:string; emoji:string; userId:string }
  | { t:'review:new'; rev: Review }
  | { t:'review:update'; id:string; patch: Partial<Review> }
  | { t:'lock:acquire'; noteId:string; leaseMs:number }
  | { t:'lock:release'; noteId:string }
  | { t:'ack'; id:string; at:number };

export type Envelope = { id:string; ts:number; from:string; room:string; op: Op; lamport:number };
export type Snapshot = { users:Record<string,User>; presence:Record<string,Presence>; threads:Record<string,Thread>; reviews:Record<string,Review>; lamport:number };
```

---

## 2) `engine/collab/client.ts` — tiny WS client with op queue

```ts
// engine/collab/client.ts — Stage 4V
import type { Envelope, Op, Snapshot, Presence, User } from './types';

export class CollabClient {
  private ws?: WebSocket; private url=''; private room=''; private me:User|null=null;
  private lamport=1; private queue: Envelope[]=[]; private inflight = new Map<string, Envelope>();
  private snap: Snapshot = { users:{}, presence:{}, threads:{}, reviews:{}, lamport:1 };
  private listeners: Array<(s:Snapshot)=>void> = [];
  constructor(private onStatus:(s:'connecting'|'open'|'closed'|'error')=>void){ }

  connect(url:string, room:string, me:User){ this.url=url; this.room=room; this.me=me; this.onStatus('connecting'); try{ this.ws = new WebSocket(url); this.ws.onopen = ()=>{ this.onStatus('open'); this.send({ t:'join', user: me }); this.flush(); };
    this.ws.onmessage = (ev)=>{ const env = JSON.parse(String(ev.data)) as Envelope; this.onEnvelope(env); };
    this.ws.onclose = ()=>{ this.onStatus('closed'); setTimeout(()=>this.reconnect(), 1000+Math.random()*1000); };
    this.ws.onerror = ()=>this.onStatus('error'); } catch { this.onStatus('error'); }
  }
  disconnect(){ try{ this.ws?.close(); }catch{} }
  on(fn:(s:Snapshot)=>void){ this.listeners.push(fn); fn(this.snap); return ()=>{ this.listeners = this.listeners.filter(x=>x!==fn); }; }
  private emit(){ for (const fn of this.listeners) fn(this.snap); }

  private nextLamport(remote:number){ this.lamport = Math.max(this.lamport+1, remote+1); return this.lamport; }

  send(op: Op){ const env: Envelope = { id: Math.random().toString(36).slice(2,8), ts: Date.now(), from: this.me!.id, room: this.room, op, lamport: this.nextLamport(this.snap.lamport) }; this.queue.push(env); this.flush(); }
  private flush(){ if (!this.ws || this.ws.readyState!==1) return; while (this.queue.length){ const e=this.queue.shift()!; this.ws.send(JSON.stringify(e)); this.inflight.set(e.id, e); } }

  private onEnvelope(env: Envelope){ // apply
    this.snap.lamport = this.nextLamport(env.lamport);
    const op = env.op as Op; switch(op.t){
      case 'join': this.snap.users[op.user.id]=op.user; break;
      case 'presence': this.snap.presence[op.p.id] = op.p; break;
      case 'thread:new': this.snap.threads[op.thread.id] = op.thread; break;
      case 'thread:update': Object.assign(this.snap.threads[op.id], op.patch); break;
      case 'comment:add': this.snap.threads[op.threadId]?.comments.push(op.comment); break;
      case 'comment:edit': { const t=this.snap.threads[op.threadId]; const c=t?.comments.find(x=>x.id===op.commentId); if(c){ (c.edits||(c.edits=[])).push({ at: Date.now(), body: c.body }); c.body = op.body; } break; }
      case 'comment:react': { const t=this.snap.threads[op.threadId]; const c=t?.comments.find(x=>x.id===op.commentId); if(c){ const k=op.emoji; c.reactions=c.reactions||{}; const arr=c.reactions[k]||[]; if(!arr.includes(op.userId)) arr.push(op.userId); c.reactions[k]=arr; } break; }
      case 'review:new': this.snap.reviews[op.rev.id]=op.rev; break;
      case 'review:update': Object.assign(this.snap.reviews[op.id], op.patch); break;
      case 'ack': this.inflight.delete(op.id); break;
    }
    this.emit();
  }
}
```

---

## 3) `engine/collab/server-stub.md` — trivial WS room (reference)

```txt
// Minimal reference server (Node, pseudo‑code)
ws.on('connection', (sock)=>{
  const room = new URL(sock.url).searchParams.get('room')||'default';
  const peers = rooms[room] ||= new Set(); peers.add(sock);
  sock.on('message', (data)=>{ const env = JSON.parse(data); // validate/auth here
    // broadcast + ack
    for (const peer of peers) peer.send(JSON.stringify(env));
    sock.send(JSON.stringify({ id: env.id, ts: Date.now(), from:'server', room, lamport: env.lamport, op:{ t:'ack', id: env.id, at: Date.now() } }));
  });
  sock.on('close', ()=> peers.delete(sock));
});
```

---

## 4) `playground/components/PresenceBar.tsx` — avatars + status

```tsx
// playground/components/PresenceBar.tsx
import React from 'react';
import type { Snapshot, User } from '../../engine/collab/types';

export const PresenceBar: React.FC<{ snap: Snapshot }>=({ snap })=>{
  const users = Object.values(snap.users);
  return (
    <div className="mpl-pres">
      {users.map(u=> (
        <div key={u.id} className="mpl-pres-u" title={`${u.name} (${u.role})`}>
          <span className="mpl-dot" style={{ background:u.color }} />
          <span>{u.name}</span>
        </div>
      ))}
    </div>
  );
};
```

---

## 5) `playground/components/GhostCursors.tsx` — canvas overlay for pointers + selections

```tsx
// playground/components/GhostCursors.tsx
import React from 'react';
import type { Snapshot } from '../../engine/collab/types';

export const GhostCursors: React.FC<{ snap: Snapshot; worldToScreen:(x:number,y:number)=>{x:number;y:number} }>
= ({ snap, worldToScreen }) => {
  const pres = Object.values(snap.presence);
  return (
    <svg className="mpl-ghosts" style={{ position:'absolute', inset:0, pointerEvents:'none' }}>
      {pres.map(p=>{
        if (!p.xy) return null; const P = worldToScreen(p.xy.x, p.xy.y); return (
          <g key={p.id} transform={`translate(${P.x},${P.y})`}>
            <circle r={6} fill="white" stroke="#111827" />
            <text y={-10} textAnchor="middle" fontSize={11} fill="#111827">{p.id}</text>
          </g>
        );
      })}
    </svg>
  );
};
```

---

## 6) `playground/components/CommentsPanel.tsx` — threads UI

```tsx
// playground/components/CommentsPanel.tsx
import React from 'react';
import type { Snapshot, Thread, Comment, Anchor } from '../../engine/collab/types';

export const CommentsPanel: React.FC<{
  snap: any; // Snapshot
  onNew: (anchor: Anchor, body:string)=>void;
  onReply: (threadId:string, body:string)=>void;
  onResolve: (threadId:string, open:boolean)=>void;
}>
= ({ snap, onNew, onReply, onResolve }) => {
  const threads: Thread[] = Object.values(snap.threads);
  const [filter, setFilter] = React.useState<'all'|'open'|'mine'>('open');
  const me = Object.values(snap.users)[0]?.id;
  const shown = threads.filter(t=> filter==='all' ? true : filter==='open' ? t.open : (t.assignees||[]).includes(me));

  const [body, setBody] = React.useState('');
  const [anchor, setAnchor] = React.useState<Anchor>({ k:'tick', n: snap.lamport||0 });

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Comments</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <select value={filter} onChange={e=>setFilter(e.target.value as any)}>
            <option value="open">Open</option>
            <option value="mine">Assigned to me</option>
            <option value="all">All</option>
          </select>
        </div>

        <details>
          <summary>New thread</summary>
          <div className="mpl-col" style={{ gap:8 }}>
            <label>Anchor
              <select value={anchor.k} onChange={e=>setAnchor({ k:e.target.value as any, n:(snap.lastTick||0) })}>
                <option value="tick">Timeline tick</option>
                <option value="area">Screen area</option>
              </select>
            </label>
            <textarea rows={3} placeholder="Write a comment…" value={body} onChange={e=>setBody(e.target.value)} />
            <button className="mpl-btn" onClick={()=>{ if(body.trim()) onNew(anchor, body), setBody(''); }}>Create thread</button>
          </div>
        </details>

        <div className="mpl-list-b">
          {shown.map(t => (
            <div key={t.id} className="mpl-thread">
              <div className="mpl-row">
                <strong>#{t.id.slice(0,6)}</strong>
                <span className={`mpl-chip ${t.open?'open':'resolved'}`}>{t.open?'Open':'Resolved'}</span>
              </div>
              <div className="mpl-comments">
                {t.comments.map(c => (
                  <div key={c.id} className="mpl-comment"><div className="mpl-dim">{new Date(c.createdAt).toLocaleString()}</div><div>{c.body}</div></div>
                ))}
              </div>
              <div className="mpl-row">
                <button className="mpl-btn" onClick={()=>onResolve(t.id, !t.open)}>{t.open?'Resolve':'Reopen'}</button>
                <button className="mpl-btn" onClick={()=>{ const r=prompt('Reply:'); if(r) onReply(t.id, r); }}>Reply</button>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

---

## 7) `playground/components/ReviewPanel.tsx` — timeline reviews

```tsx
// playground/components/ReviewPanel.tsx
import React from 'react';
import type { Snapshot, ReviewState } from '../../engine/collab/types';

export const ReviewPanel: React.FC<{
  snap:any; onNew:(title:string, at:number)=>void; onSet:(id:string, s:ReviewState)=>void;
}>
= ({ snap, onNew, onSet }) =>{
  const [title, setTitle] = React.useState('Review');
  const [at, setAt] = React.useState(0);
  const reviews = Object.values(snap.reviews||{});
  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Reviews</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <input value={title} onChange={e=>setTitle(e.target.value)} placeholder="Title" />
          <input type="number" value={at} onChange={e=>setAt(+e.target.value)} style={{ width:100 }} />
          <button className="mpl-btn" onClick={()=>onNew(title, at)}>Open review</button>
        </div>
        <div className="mpl-list-b">
          {reviews.map((r:any)=> (
            <div key={r.id} className="mpl-review">
              <strong>{r.title}</strong>
              <span className={`mpl-chip ${r.state}`}>{r.state}</span>
              <button className="mpl-btn" onClick={()=>onSet(r.id, 'approved')}>Approve</button>
              <button className="mpl-btn" onClick={()=>onSet(r.id, 'changes')}>Request changes</button>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

---

## 8) `playground/components/CollabPanel.tsx` — connect & wire ops

```tsx
// playground/components/CollabPanel.tsx
import React from 'react';
import { CollabClient } from '../../engine/collab/client';
import type { Anchor, Comment, Presence, ReviewState, Thread, User } from '../../engine/collab/types';

export const CollabPanel: React.FC<{ worldToScreen:(x:number,y:number)=>{x:number;y:number}; onSnap:(s:any)=>void }>
= ({ worldToScreen, onSnap }) => {
  const [url,setUrl] = React.useState('wss://example.collab/ws');
  const [room,setRoom] = React.useState('mpl-demo');
  const [me] = React.useState<User>({ id: 'me-'+Math.random().toString(36).slice(2,5), name:'You', color:'#10b981', lastSeen: Date.now(), role:'editor' });
  const [status, setStatus] = React.useState<'connecting'|'open'|'closed'|'error'>('closed');
  const [snap, setSnap] = React.useState<any>({ users:{}, presence:{}, threads:{}, reviews:{} });
  const ref = React.useRef<CollabClient|null>(null);

  function connect(){ const c = new CollabClient(setStatus); ref.current = c; c.on(setSnap); c.connect(url, room, me); }
  function disconnect(){ ref.current?.disconnect(); }

  // presence heartbeat (pointer movement from canvas)
  React.useEffect(()=>{ const onMove=(e:MouseEvent)=>{ const x=(e as any).mplX||0, y=(e as any).mplY||0; ref.current?.send({ t:'presence', p:{ id: me.id, xy:{x,y} } }); }; window.addEventListener('mpl:worldpointer', onMove as any); return ()=>window.removeEventListener('mpl:worldpointer', onMove as any); }, []);

  function newThread(anchor: Anchor, body:string){ const thread: Thread = { id: Math.random().toString(36).slice(2,8), anchor, open:true, comments:[{ id: Math.random().toString(36).slice(2,8), author: me.id, createdAt: Date.now(), body }], assignees:[] } as any; ref.current?.send({ t:'thread:new', thread }); }
  function reply(threadId:string, body:string){ const c: Comment = { id: Math.random().toString(36).slice(2,8), author: me.id, createdAt: Date.now(), body }; ref.current?.send({ t:'comment:add', threadId, comment: c }); }
  function resolve(threadId:string, open:boolean){ ref.current?.send({ t:'thread:update', id: threadId, patch:{ open } }); }
  function openReview(title:string, at:number){ ref.current?.send({ t:'review:new', rev:{ id: Math.random().toString(36).slice(2,8), title, range:{ at }, state:'open', threads:[], createdBy: me.id, createdAt: Date.now() } }); }
  function setReview(id:string, s:ReviewState){ ref.current?.send({ t:'review:update', id, patch:{ state: s } }); }

  React.useEffect(()=>{ onSnap(snap); }, [snap]);

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Collab</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <input value={url} onChange={e=>setUrl(e.target.value)} placeholder="wss://…" style={{ flex:1 }} />
          <input value={room} onChange={e=>setRoom(e.target.value)} style={{ width:140 }} />
          <button className="mpl-btn" onClick={connect}>Connect</button>
          <button className="mpl-btn" onClick={disconnect}>Disconnect</button>
          <span className={`mpl-chip ${status}`}>{status}</span>
        </div>
        <div className="mpl-dim">Connected as <code>{me.name}</code> ({me.id}). Movements broadcast as world‑space pointer events.</div>
      </div>
    </div>
  );
};
```

---

## 9) `playground/components/CanvasPanel.tsx` — wire collab overlays

```tsx
// CanvasPanel.tsx — 4V wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { CollabPanel } from './CollabPanel';
import { PresenceBar } from './PresenceBar';
import { GhostCursors } from './GhostCursors';

export const CanvasPanel: React.FC<{ history: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= ({ history, index, onIndex }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(history[Math.max(0, Math.min(index, history.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, history]);
  const canvasRef = React.useRef<any>(null);
  const [collabSnap, setCollabSnap] = React.useState<any>({ users:{}, presence:{}, threads:{}, reviews:{} });

  function worldToScreen(x:number,y:number){ const g=(canvasRef.current as any)?._graph; return g? g.worldToScreen({x,y}) : { x, y }; }
  React.useEffect(()=>{ const onMove=(e:MouseEvent)=>{ const g=(canvasRef.current as any)?._graph; if(!g) return; const w=g.screenToWorld({ x:e.clientX, y:e.clientY }); (e as any).mplX=w.x; (e as any).mplY=w.y; window.dispatchEvent(new CustomEvent('mpl:worldpointer', { detail:w }) as any); }; const el=(canvasRef.current as any)?.canvas; el?.addEventListener('mousemove', onMove); return ()=>el?.removeEventListener('mousemove', onMove); }, []);

  return (
    <div className="mpl-grid" style={{ position:'relative' }}>
      <div className="mpl-main">
        <div style={{ position:'relative' }}>
          <GraphCanvas ref={canvasRef} snapshot={slim} />
          <GhostCursors snap={collabSnap} worldToScreen={worldToScreen} />
        </div>
      </div>
      <aside className="mpl-side">
        <PresenceBar snap={collabSnap} />
        <CollabPanel worldToScreen={worldToScreen} onSnap={setCollabSnap} />
      </aside>
    </div>
  );
};
```

---

## 10) Styles — `playground/styles/debugger.css` (additions)

```css
/* Stage 4V — collab */
.mpl-pres { display:flex; gap:8px; align-items:center; padding:6px 0; border-bottom:1px dashed var(--mpl-border); }
.mpl-pres-u { display:flex; gap:6px; align-items:center; padding:4px 8px; border:1px solid var(--mpl-border); border-radius:999px; background:#fff; }
.mpl-thread { padding:8px; border:1px solid var(--mpl-border); border-radius:8px; display:grid; gap:6px; }
.mpl-comments { display:grid; gap:6px; }
.mpl-comment { background:#f8fafc; border:1px solid #e5e7eb; border-radius:8px; padding:6px 8px; }
.mpl-review { display:grid; grid-template-columns:1fr auto auto; gap:8px; align-items:center; padding:8px 0; border-bottom:1px dashed var(--mpl-border); }
.mpl-chip.open { background:#dcfce7; }
.mpl-chip.resolved { background:#e5e7eb; }
.mpl-chip.approved { background:#dbeafe; }
.mpl-chip.changes { background:#fee2e2; }
```

---

## 11) Example — `playground/pages/DebugExample4V.tsx`

```tsx
// playground/pages/DebugExample4V.tsx
import React, { useMemo, useState } from 'react';
import { DebuggerPanel } from '../components/DebuggerPanel';
import { ExecutionSnapshot } from '../../engine/debugger/graphTypes';

function makeHistory(): ExecutionSnapshot[] { const ids=Array.from({length:120},(_,i)=>`N${i}`); const monads=ids.map((id,i)=>({ id, neighbors:[], x:Math.cos(i*.2)*200+(Math.random()-0.5)*10, y:Math.sin(i*.2)*200+(Math.random()-0.5)*10 })); for(let i=0;i<ids.length;i++) for(let j=i+1;j<ids.length;j++) if(Math.random()<0.03){ monads[i].neighbors.push(ids[j]); monads[j].neighbors.push(ids[i]); } return [{ tick:0, monads, rulesFired:['Seed'] } as any]; }

export default function DebugExample4V(){
  const history = useMemo(makeHistory, []);
  return (
    <div style={{ padding:24 }}>
      <h1>Stage 4V — Collab: Presence, Multi‑Cursor, Comments & Timeline Reviews</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Open Collab; connect to a room in two tabs to see ghost cursors and shared comments in real time.</p>
    </div>
  );
}
```

---

## 12) Notes

* **Locks vs CRDT**: Notes editing uses **lease locks** (optimistic). For true concurrent text, swap to a CRDT (y‑like) behind the same op names.
* **Mentions**: Parse `@name` in comment text; surface in PresenceBar (ping) and AlertTray (4P).
* **Privacy**: Packs (4T) omit collab logs/users by default; toggle if needed for audits.
* **Replays**: Reviews can snapshot comment threads into a Share Pack for async review.
* **Auth**: Add JWT on `?token=` to the WS URL and have the server validate roles.

---

## 13) Changelog — Stage 4V

* New: `engine/collab/types.ts`, `engine/collab/client.ts`
* Docs: `engine/collab/server-stub.md`
* New UI: `PresenceBar.tsx`, `GhostCursors.tsx`, `CommentsPanel.tsx`, `ReviewPanel.tsx`, `CollabPanel.tsx`
* Updated: `CanvasPanel.tsx` (wire collab overlays)
* Styles: presence chips, threads, reviews

```
```
