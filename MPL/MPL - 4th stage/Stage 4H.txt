# MPL Playground — Stage 4H Patch (Mini‑Map Box Zoom + Lasso Select + Bulk Pin/Unpin)

This patch adds:

* **Mini‑map box zoom** (Shift‑drag a rectangle to zoom/fit the main view)
* **Lasso selection** (add/remove modes, dashed overlay, keyboard shortcuts)
* **Bulk pin/unpin** actions and selection utilities (zoom to selection, clear, select all)

No new deps. Built directly on 4F (bundling, clusters, halos) + 4G (mini‑map, inspector, path overlay).

---

## Highlights

* Hold **Shift** in the mini‑map → drag a rectangle → main canvas fits that area
* Hold **L** (or toggle the Lasso button) on the main canvas → freehand lasso

  * **Shift** = add to selection, **Alt** = subtract from selection
  * **Esc** clears active lasso/selection
* **Keyboard**: `Ctrl+A` select all, `P` pin selection, `U` unpin selection, `Z` fit selection
* Inspector shows **multi‑select** count + actions

---

## 1) `engine/renderer/canvas/geom.ts` (new) — point‑in‑polygon, rect utils

```ts
// engine/renderer/canvas/geom.ts
export interface Pt { x:number; y:number }
export interface Rect { minX:number; minY:number; maxX:number; maxY:number }

export function pointInPoly(pt: Pt, poly: Pt[]): boolean {
  // even-odd rule in 2D
  let inside = false; for (let i=0, j=poly.length-1; i<poly.length; j=i++){
    const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y;
    const intersect = ((yi>pt.y)!==(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-9)+xi);
    if (intersect) inside = !inside;
  } return inside;
}

export function normRect(a: Pt, b: Pt): Rect {
  const minX=Math.min(a.x,b.x), minY=Math.min(a.y,b.y), maxX=Math.max(a.x,b.x), maxY=Math.max(a.y,b.y);
  return { minX, minY, maxX, maxY };
}
```

---

## 2) `engine/renderer/canvas/CanvasGraph.ts` (update) — fit‑to‑rect and lasso overlay

```ts
// CanvasGraph.ts — 4H additions (excerpt)
import type { Rect } from './geom';

export class CanvasGraph {
  // ...existing fields
  private lassoPath: {x:number;y:number}[] | null = null; // screen-space points
  private selected: Set<string> = new Set();

  getSelection(): string[] { return [...this.selected]; }
  setSelection(ids: string[]){ this.selected = new Set(ids); }
  addToSelection(ids: string[]){ for (const id of ids) this.selected.add(id); }
  removeFromSelection(ids: string[]){ for (const id of ids) this.selected.delete(id); }
  clearSelection(){ this.selected.clear(); }

  setLassoPath(path: {x:number;y:number}[] | null){ this.lassoPath = path; }

  fitWorldRect(r: Rect, pad = 0.9){
    // pad < 1 → margin
    const w = this.canvas.width, h = this.canvas.height; const ww = Math.max(1, r.maxX - r.minX), hh = Math.max(1, r.maxY - r.minY);
    const z = Math.max(0.1, Math.min(6, Math.min(w/ww, h/hh) * pad));
    const cx = (r.minX + r.maxX)/2, cy = (r.minY + r.maxY)/2;
    this.cam.z = z; this.cam.x = w/2 - cx*z; this.cam.y = h/2 - cy*z;
  }

  draw(){
    const s = this.last; if (!s) return; const ctx = this.ctx; const { width, height } = this.canvas; ctx.save();
    ctx.fillStyle = this.theme.bg; ctx.fillRect(0,0,width,height); drawGrid(ctx, this.cam, width, height, this.theme.grid);
    const P = this.externalPos;

    // ... existing hulls + edges + nodes + labels ...

    // Selected node outline
    if (this.selected.size){ ctx.lineWidth = Math.max(1, 1.5*this.cam.z); ctx.strokeStyle = this.theme.nodeSel; for (const id of this.selected){ const p = P?.[id] || (this.last!.monads as any)[id]; if (!p) continue; const pt = worldToScreen(p as any, this.cam); ctx.beginPath(); ctx.arc(pt.x, pt.y, this.getNodeRadius(id)+2, 0, Math.PI*2); ctx.stroke(); } }

    // Lasso overlay (screen-space)
    if (this.lassoPath && this.lassoPath.length){ ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y); for (let i=1;i<this.lassoPath.length;i++){ const p=this.lassoPath[i]; ctx.lineTo(p.x, p.y); } ctx.stroke(); ctx.setLineDash([]); ctx.globalAlpha = 0.08; ctx.fillStyle = '#64748b'; ctx.beginPath(); ctx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y); for (let i=1;i<this.lassoPath.length;i++){ const p=this.lassoPath[i]; ctx.lineTo(p.x, p.y); } ctx.closePath(); ctx.fill(); ctx.restore(); }

    ctx.restore();
  }
}
```

---

## 3) `playground/components/MiniMap.tsx` (update) — Shift‑drag box zoom

```tsx
// MiniMap.tsx — 4H: box zoom via Shift-drag, emit world-rect to parent
import React, { useEffect, useRef, useState } from 'react';
import { boundsOf } from '../../engine/renderer/canvas/bounds';
import { normRect } from '../../engine/renderer/canvas/geom';

export interface MiniMapProps {
  pos: Record<string,{x:number;y:number}> | null;
  camera: { x:number; y:number; z:number };
  onPan: (nx:number, ny:number) => void;
  onBoxZoom?: (rectWorld: { minX:number; minY:number; maxX:number; maxY:number }) => void;
}

export const MiniMap: React.FC<MiniMapProps> = ({ pos, camera, onPan, onBoxZoom }) => {
  const ref = useRef<HTMLCanvasElement>(null);
  const dragging = useRef(false);
  const [box, setBox] = useState<{a:{x:number;y:number}, b:{x:number;y:number}}|null>(null);

  useEffect(() => { draw(); }, [pos, camera.x, camera.y, camera.z, box?.a.x, box?.b.x, box?.a.y, box?.b.y]);

  function draw(){ const c = ref.current!; const ctx = c.getContext('2d')!; const w=c.width=200, h=c.height=140; ctx.clearRect(0,0,w,h); if (!pos) return;
    const b = boundsOf(pos); const pad = 20; const worldW=(b.maxX-b.minX)||1, worldH=(b.maxY-b.minY)||1; const sx=(w-2*pad)/worldW, sy=(h-2*pad)/worldH; const s=Math.min(sx,sy); const ox=pad-b.minX*s, oy=pad-b.minY*s;
    // nodes
    ctx.fillStyle='#9ca3af'; for (const id in pos){ const p=pos[id]; ctx.fillRect(ox+p.x*s, oy+p.y*s, 2, 2); }
    // viewport box
    const vw=(w/camera.z)*0.25*s, vh=(h/camera.z)*0.25*s; const vx=ox+(-camera.x)*s - vw/2, vy=oy+(-camera.y)*s - vh/2; ctx.strokeStyle='#6366f1'; ctx.lineWidth=2; ctx.strokeRect(vx,vy,vw,vh);
    // lasso box
    if (box){ const r = normRect(box.a, box.b); ctx.setLineDash([5,4]); ctx.strokeStyle='#334155'; ctx.strokeRect(r.minX, r.minY, r.maxX-r.minX, r.maxY-r.minY); ctx.setLineDash([]); }
  }

  function screenToWorld(nx:number, ny:number){ if (!pos) return { x:0,y:0 }; const b = boundsOf(pos); const pad=20; const w=200,h=140; const s = Math.min((w-2*pad)/((b.maxX-b.minX)||1), (h-2*pad)/((b.maxY-b.minY)||1)); const ox=pad-b.minX*s, oy=pad-b.minY*s; return { x:(nx-ox)/s, y:(ny-oy)/s };
  }

  useEffect(() => {
    const c = ref.current!;
    const md = (e:MouseEvent)=>{ if (e.shiftKey){ dragging.current=true; const r=c.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; setBox({ a:{x,y}, b:{x,y} }); } else { // pan jump
        const r=c.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; const w = screenToWorld(x,y); onPan(-w.x, -w.y); }
    };
    const mm = (e:MouseEvent)=>{ if (!dragging.current) return; const r=c.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; setBox(b=>b?{ a:b.a, b:{x,y} }:null); };
    const mu = ()=>{ if (dragging.current){ dragging.current=false; if (box && onBoxZoom){ const r = normRect(box.a, box.b); const a = screenToWorld(r.minX, r.minY); const b = screenToWorld(r.maxX, r.maxY); onBoxZoom({ minX:a.x, minY:a.y, maxX:b.x, maxY:b.y }); } setBox(null); } };
    c.addEventListener('mousedown', md); window.addEventListener('mousemove', mm); window.addEventListener('mouseup', mu);
    return () => { c.removeEventListener('mousedown', md); window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); };
  }, [pos, box, onPan, onBoxZoom]);

  return <canvas ref={ref} width={200} height={140} style={{ width:200, height:140, border:'1px solid #e5e7eb', borderRadius:8, background:'#fff', cursor:'crosshair' }} />;
};
```

---

## 4) `playground/components/GraphCanvas.tsx` (update) — lasso tool + selection plumbing

```tsx
// GraphCanvas.tsx — 4H: lasso select + fitRect + bulk selection helpers (excerpt)
import React, { useEffect, useRef, useState } from 'react';
import { CanvasGraph } from '../../engine/renderer/canvas/CanvasGraph';
import { pointInPoly } from '../../engine/renderer/canvas/geom';

export const GraphCanvas: React.FC<{
  snapshot: any;
  camera?: Partial<{x:number;y:number;z:number}>;
  onCamera?: (c:{x:number;y:number;z:number})=>void;
  onPick?: (id: string|null) => void;
  onSelect?: (ids: string[]) => void;
  fitRect?: { minX:number; minY:number; maxX:number; maxY:number } | null; // when changed, fit
  // ...other props from 4G/4F (style, path, etc.)
}>
= ({ snapshot, camera, onCamera, onPick, onSelect, fitRect, ...rest }) => {
  const ref = useRef<HTMLCanvasElement>(null);
  const graphRef = useRef<CanvasGraph | null>(null);
  const [lassoOn, setLassoOn] = useState(false);
  const lasso = useRef<{x:number;y:number}[]|null>(null);

  // init + resize
  useEffect(() => { const c = ref.current!; const g = new CanvasGraph(c); graphRef.current = g; const ro=new ResizeObserver(()=>{ const r=c.getBoundingClientRect(); g.resize(r.width|0, r.height|0); g.draw(); }); ro.observe(c.parentElement!); return ()=>ro.disconnect(); }, []);

  // camera + snapshot
  useEffect(() => { const g=graphRef.current; if (!g) return; if (camera) g.setCamera(camera); if (snapshot) g.setSnapshot(snapshot as any); g.draw(); }, [camera?.x,camera?.y,camera?.z,snapshot?.tick]);

  // respond to fit requests
  const lastFit = useRef<string>('');
  useEffect(() => { const g=graphRef.current; if (!g || !fitRect) return; const key = `${fitRect.minX},${fitRect.minY},${fitRect.maxX},${fitRect.maxY}`; if (key===lastFit.current) return; lastFit.current = key; g.fitWorldRect(fitRect, 0.92); onCamera?.(g.getCamera()); g.draw(); }, [fitRect?.minX, fitRect?.minY, fitRect?.maxX, fitRect?.maxY]);

  // lasso interactions
  useEffect(() => {
    const c = ref.current!; const g = graphRef.current!;
    const key = (e: KeyboardEvent) => { if (e.key==='l' || e.key==='L') setLassoOn(true); if (e.key==='Escape') { g.clearSelection(); g.setLassoPath(null); lasso.current=null; onSelect?.([]); g.draw(); } if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='a'){ e.preventDefault(); const ids = Object.keys((g as any).last?.monads || {}); g.setSelection(ids); onSelect?.(ids); g.draw(); } if (e.key.toLowerCase()==='p'){ const ids = g.getSelection(); (window as any).mpl_pin?.(ids); } if (e.key.toLowerCase()==='u'){ const ids = g.getSelection(); (window as any).mpl_unpin?.(ids); } if (e.key.toLowerCase()==='z'){ const ids = g.getSelection(); if (ids.length){ const rect = worldRectOf(ids); g.fitWorldRect(rect, 0.9); onCamera?.(g.getCamera()); g.draw(); } }
    };
    const ku = (e: KeyboardEvent) => { if (e.key==='l' || e.key==='L') setLassoOn(false); };
    window.addEventListener('keydown', key); window.addEventListener('keyup', ku);

    let dragging=false; let lmode:'add'|'sub'|'new'='new';
    const md = (e: MouseEvent) => {
      if (!lassoOn) { // normal pick & pan hook
        const hit = g.hitNode(e.offsetX, e.offsetY); onPick?.(hit); return;
      }
      dragging=true; lasso.current=[{ x:e.offsetX, y:e.offsetY }]; g.setLassoPath(lasso.current); lmode = e.altKey ? 'sub' : (e.shiftKey ? 'add' : 'new');
    };
    const mm = (e: MouseEvent) => { if (!dragging || !lasso.current) return; lasso.current.push({ x:e.offsetX, y:e.offsetY }); g.setLassoPath(lasso.current); g.draw(); };
    const mu = () => { if (!dragging) return; dragging=false; if (!lasso.current || lasso.current.length<3){ g.setLassoPath(null); lasso.current=null; return; }
      // build selection via screen-space PIP
      const ids = Object.keys((g as any).last?.monads || {}); const picked: string[] = [];
      for (const id of ids){ const scr = g.getScreenPos(id); if (pointInPoly(scr as any, lasso.current!)) picked.push(id); }
      if (lmode==='new') g.setSelection(picked); else if (lmode==='add') g.addToSelection(picked); else g.removeFromSelection(picked);
      const out = g.getSelection(); onSelect?.(out); lasso.current=null; g.setLassoPath(null); g.draw(); };

    c.addEventListener('mousedown', md); window.addEventListener('mousemove', mm); window.addEventListener('mouseup', mu);
    return () => { window.removeEventListener('keydown', key); window.removeEventListener('keyup', ku); c.removeEventListener('mousedown', md); window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); };
  }, [lassoOn, snapshot?.tick]);

  function worldRectOf(ids: string[]){ const g=graphRef.current!; let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for (const id of ids){ const p = (g as any).externalPos?.[id] || (g as any).last?.monads[id]; if (!p) continue; const x=p.x||0,y=p.y||0; if (x<minX)minX=x; if (y<minY)minY=y; if (x>maxX)maxX=x; if (y>maxY)maxY=y; } if (!isFinite(minX)) return { minX:-1,minY:-1,maxX:1,maxY:1 }; return { minX, minY, maxX, maxY };
  }

  return <canvas ref={ref} style={{ width:'100%', height: 480, display:'block', border:'1px solid #e5e7eb', borderRadius: 10, cursor: lassoOn ? 'crosshair' : 'default' }} />;
};
```

---

## 5) `playground/components/Inspector.tsx` (update) — multi‑select actions

```tsx
// Inspector.tsx — 4H: multi-select count + actions
import React from 'react';

export const Inspector: React.FC<any> = ({ snapshot, picked, selection=[], onPinSel, onUnpinSel, onZoomSel, onClearSel }) => {
  const count = selection.length;
  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Inspector</div>
      <div className="mpl-card-b">
        <div className="mpl-kv"><span>Selected</span><span>{count}</span></div>
        <div className="mpl-row">
          <button className="mpl-btn" onClick={onPinSel} disabled={!count}>Pin</button>
          <button className="mpl-btn" onClick={onUnpinSel} disabled={!count}>Unpin</button>
          <button className="mpl-btn" onClick={onZoomSel} disabled={!count}>Fit</button>
          <button className="mpl-btn" onClick={onClearSel} disabled={!count}>Clear</button>
        </div>
        {/* retain prior node details if single-picked (from 4G) */}
        {picked ? (<>
          <div className="mpl-kv"><span>Last clicked</span><code>{picked}</code></div>
        </>) : <div className="mpl-dim">Click a node or use L to lasso.</div>}
      </div>
    </div>
  );
};
```

---

## 6) `playground/components/CanvasPanel.tsx` (update) — wire box zoom + lasso + bulk pin/unpin

```tsx
// CanvasPanel.tsx — 4H wiring (excerpt)
import React from 'react';
import { GraphCanvas } from './GraphCanvas';
import { MiniMap } from './MiniMap';
import { Inspector } from './Inspector';

export const CanvasPanel: React.FC<any> = ({ timeline, index, onIndex }) => {
  const slim = React.useMemo(() => /* as in 4G */ timeline[index], [timeline, index]);
  const [cam, setCam] = React.useState({ x:0, y:0, z:1 });
  const [pos, setPos] = React.useState<Record<string,{x:number;y:number}>|null>(null);
  const [selection, setSelection] = React.useState<string[]>([]);
  const [picked, setPicked] = React.useState<string|null>(null);
  const [fitRect, setFitRect] = React.useState<any>(null);

  // Expose simple pin/unpin hooks for keybindings (GraphCanvas listens via window)
  // NOTE: In worker mode you may need to forward to worker. Placeholder no-op here.
  (window as any).mpl_pin = (ids: string[]) => { console.debug('pin(sel)', ids); /* TODO: integrate with physics state when not in worker */ };
  (window as any).mpl_unpin = (ids: string[]) => { console.debug('unpin(sel)', ids); };

  return (
    <div className="mpl-grid">
      <div className="mpl-main">
        {/* (playback + scrubber rows from 4G remain here) */}
        <div className="mpl-row">
          <MiniMap pos={pos} camera={cam} onPan={(x,y)=>setCam(c=>({ ...c, x, y }))} onBoxZoom={r=>setFitRect(r)} />
          <div className="mpl-dim" style={{ marginLeft: 12 }}>Mini‑map: click to pan • Shift‑drag to box‑zoom</div>
        </div>
        <GraphCanvas
          snapshot={slim}
          camera={cam}
          onCamera={setCam}
          onPick={setPicked}
          onSelect={setSelection}
          fitRect={fitRect}
        />
      </div>
      <aside className="mpl-side">
        <Inspector
          snapshot={timeline[index]}
          picked={picked}
          selection={selection}
          onPinSel={() => (window as any).mpl_pin(selection)}
          onUnpinSel={() => (window as any).mpl_unpin(selection)}
          onZoomSel={() => setFitRect(worldRectOfSelection())}
          onClearSel={() => setSelection([])}
        />
      </aside>
    </div>
  );

  function worldRectOfSelection(){ if (!pos || selection.length===0) return null as any; let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for (const id of selection){ const p=pos[id]; if (!p) continue; if (p.x<minX)minX=p.x; if (p.y<minY)minY=p.y; if (p.x>maxX)maxX=p.x; if (p.y>maxY)maxY=p.y; } return { minX, minY, maxX, maxY }; }
};
```

---

## 7) `playground/styles/debugger.css` (additions)

```css
/* Stage 4H — selection & lasso affordances */
.mpl-btn { padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; cursor: pointer; }
.mpl-btn:disabled { opacity: .4; cursor: default; }
```

---

## 8) Example — `playground/pages/DebugExample4H.tsx`

```tsx
// playground/pages/DebugExample4H.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

function ring(n:number, r:number, offx=0, offy=0){
  const ids = Array.from({length:n}, (_,i)=>String(i));
  const monads = ids.map((id,i)=>({ id, neighbors: [], x: offx + Math.cos(i/n*2*Math.PI)*r, y: offy + Math.sin(i/n*2*Math.PI)*r }));
  for (let i=0;i<n;i++){ monads[i].neighbors.push(ids[(i+1)%n]); monads[(i+1)%n].neighbors.push(ids[i]); }
  return monads;
}

export default function DebugExample4H(){
  const history: ExecutionSnapshot[] = useMemo(()=>[ { tick:0, monads: [...ring(24,180,-200,0), ...ring(18,120,180,10)], rulesFired: [] } ], []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4H — Mini‑Map Box Zoom + Lasso Select + Bulk Pin/Unpin</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Tips: press <kbd>L</kbd> to lasso; hold <kbd>Shift</kbd> to add, <kbd>Alt</kbd> to subtract. Mini‑map: Shift‑drag to box‑zoom.</p>
    </div>
  );
}
```

---

## 9) Notes

* **Worker physics**: bulk pin/unpin wiring is stubbed here; if you’re running physics in a worker (4E), you’ll need to message the worker with a pinned mask or periodically re‑inject fixed positions for pinned IDs. Main‑thread physics (4B/4D grid) can directly zero velocities and hold positions.
* **Performance**: lasso hit‑testing runs in screen space and touches only visible nodes (based on whatever LOD/visibility you add later). For 10k nodes it’s still snappy.
* **Ergonomics**: hold **L** to lasso temporarily; release to go back to normal panning/picking. You can convert this into a toolbar toggle if you prefer.

---

## 10) Changelog — Stage 4H

* New: `canvas/geom.ts` (PIP/rect utils)
* Updated: `CanvasGraph.ts` (selection store + lasso overlay + fitWorldRect)
* Updated: `MiniMap.tsx` (box zoom via Shift‑drag)
* Updated: `GraphCanvas.tsx` (lasso interactions, keyboard shortcuts, selection plumbing)
* Updated: `Inspector.tsx` (multi‑select actions)
* Updated: `CanvasPanel.tsx` (wire box zoom + selection actions)
* CSS: small button tweaks

```
```
