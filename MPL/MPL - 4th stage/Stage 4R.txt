# MPL Playground — Stage 4R Patch (Streaming Ingest + Backpressure + Incremental Layout)

This patch adds **live streaming ingest**, **backpressure controls**, and an **incremental layout** loop that updates positions smoothly as the graph changes — all on top of 4C–4Q.

No external deps.

---

## Highlights

* **Live ingest** from WebSocket / SSE / pasted NDJSON with a tiny event schema.
* **Backpressure**: FPS cap, coalescing buffer, max history window, and drop/merge policies.
* **Incremental layout**: warm‑start new nodes near neighbors, remove stale nodes, advance a few iterations per frame (worker or main thread).
* **Live mode UI**: connect/disconnect, pause/resume, follow‑tail, catch‑up, backlog meter & staleness indicator.
* **Interop**: live snapshots feed all existing tooling (heat lanes, overlays, search, live filters, alerts, capture, watchdogs).

---

## 1) `engine/stream/types.ts` (new) — event schema

```ts
// engine/stream/types.ts — Stage 4R
export type EpochMs = number;

export type Evt =
  | { t:'node_add'; id:string; x?:number; y?:number; label?:string }
  | { t:'node_del'; id:string }
  | { t:'edge_add'; a:string; b:string }
  | { t:'edge_del'; a:string; b:string }
  | { t:'node_patch'; id:string; label?:string; pin?:boolean }
  | { t:'rule'; id:string }
  | { t:'barrier'; ts: EpochMs }      // flush hint
  | { t:'heartbeat'; ts: EpochMs }    // source is alive
  | { t:'snapshot'; /* full replace */ nodes:Array<{id:string;x:number;y:number;label?:string;neighbors?:string[]}>; rules?:string[] };

export type GraphState = {
  nodes: Record<string, { id:string; x:number; y:number; label?:string; neighbors:Set<string> }>;
  rules: string[];             // last tick rules
  ts: EpochMs;                 // last source timestamp seen
};

export function emptyState(): GraphState { return { nodes: {}, rules: [], ts: Date.now() }; }
```

---

## 2) `engine/stream/ingest.ts` (new) — coalescing buffer → snapshots

```ts
// engine/stream/ingest.ts — Stage 4R
import type { Evt, GraphState } from './types';
import { emptyState } from './types';

export type IngestCfg = {
  fpsCap?: number;           // max flush rate (e.g., 30)
  maxHistory?: number;       // how many snapshots to keep in the ring
  policy?: 'coalesce'|'drop';// when producer is faster than consumer
  onSnapshot: (snap: GraphState) => void; // called on each flush
};

export class LiveIngest {
  private cfg: Required<Pick<IngestCfg,'fpsCap'|'maxHistory'|'policy'>>;
  private state: GraphState = emptyState();
  private queue: Evt[] = [];
  private raf: number|undefined;
  private lastFlush = 0;
  private running = false;
  private dropped = 0;
  constructor(private hooks: IngestCfg){
    this.cfg = { fpsCap: hooks.fpsCap ?? 30, maxHistory: hooks.maxHistory ?? 600, policy: hooks.policy ?? 'coalesce' };
  }
  push(evt: Evt){
    if (!this.running) this.start();
    // bound the queue to avoid runaway memory
    if (this.queue.length > this.cfg.maxHistory && this.cfg.policy==='drop'){ this.queue.length = Math.floor(this.cfg.maxHistory*0.7); this.dropped++; }
    this.queue.push(evt);
  }
  start(){ if (this.running) return; this.running = true; const loop = (ts:number)=>{ this.raf = requestAnimationFrame(loop); const minDt = 1000/Math.max(1,this.cfg.fpsCap); if (ts - this.lastFlush < minDt) return; this.lastFlush = ts; this.flush(); }; this.raf = requestAnimationFrame(loop); }
  stop(){ this.running=false; if (this.raf) cancelAnimationFrame(this.raf); }
  get backlog(){ return this.queue.length; }
  get droppedCount(){ return this.dropped; }

  private flush(){ if (!this.queue.length) return; let hadBarrier=false; while (this.queue.length){ const e = this.queue.shift()!; this.apply(e); if (e.t==='barrier') { hadBarrier=true; break; } }
    // emit snapshot
    const copy: GraphState = { ts: this.state.ts, rules: [...this.state.rules], nodes: {} } as any;
    for (const id in this.state.nodes){ const n = this.state.nodes[id]; copy.nodes[id] = { id, x:n.x, y:n.y, label:n.label, neighbors: new Set(n.neighbors) } as any; }
    this.hooks.onSnapshot(copy);
  }

  private apply(e: Evt){
    switch(e.t){
      case 'node_add': { const n = this.state.nodes[e.id] || { id:e.id, x:e.x??0, y:e.y??0, label:e.label, neighbors:new Set<string>() }; n.x = e.x??n.x; n.y = e.y??n.y; if (e.label) n.label=e.label; this.state.nodes[e.id] = n; break; }
      case 'node_del': { delete this.state.nodes[e.id]; for (const id in this.state.nodes) this.state.nodes[id].neighbors.delete(e.id); break; }
      case 'edge_add': { const A=this.state.nodes[e.a], B=this.state.nodes[e.b]; if (A&&B){ A.neighbors.add(e.b); B.neighbors.add(e.a); } break; }
      case 'edge_del': { const A=this.state.nodes[e.a], B=this.state.nodes[e.b]; if (A&&B){ A.neighbors.delete(e.b); B.neighbors.delete(e.a); } break; }
      case 'node_patch': { const n=this.state.nodes[e.id]; if (n){ if (e.label!=null) n.label=e.label; } break; }
      case 'rule': { this.state.rules.push(e.id); if (this.state.rules.length>16) this.state.rules.shift(); break; }
      case 'heartbeat': { this.state.ts = e.ts; break; }
      case 'barrier': { this.state.ts = e.ts; break; }
      case 'snapshot': {
        // full replace
        const ns: GraphState = emptyState();
        for (const m of e.nodes){ ns.nodes[m.id] = { id:m.id, x:m.x, y:m.y, label:m.label, neighbors:new Set(m.neighbors||[]) }; }
        ns.rules = e.rules||[]; ns.ts = Date.now(); this.state = ns; break; }
    }
  }
}
```

---

## 3) `engine/stream/sources.ts` (new) — WS/SSE/NDJSON helpers

```ts
// engine/stream/sources.ts — Stage 4R
import type { Evt } from './types';

export function connectWebSocket(url: string, onEvt: (e:Evt)=>void, onStatus:(s:string)=>void){
  try{ const ws = new WebSocket(url); ws.onopen=()=>onStatus('open'); ws.onclose=()=>onStatus('closed'); ws.onerror=()=>onStatus('error'); ws.onmessage=(ev)=>{ try{ const o = JSON.parse(String(ev.data)); if (Array.isArray(o)) o.forEach(x=>onEvt(x)); else onEvt(o); }catch{} }; return ()=>ws.close(); } catch { onStatus('error'); return ()=>{}; }
}

export function connectSSE(url: string, onEvt:(e:Evt)=>void, onStatus:(s:string)=>void){
  try{ const es = new EventSource(url); es.onopen=()=>onStatus('open'); es.onerror=()=>onStatus('error'); es.onmessage=(ev)=>{ try{ const o = JSON.parse(ev.data); if (Array.isArray(o)) o.forEach(x=>onEvt(x)); else onEvt(o); }catch{} }; return ()=>es.close(); } catch { onStatus('error'); return ()=>{}; }
}

export function parseNdjson(text: string, onEvt:(e:Evt)=>void){ for (const line of text.split(/\r?\n/)){ const s=line.trim(); if(!s) continue; try{ const o=JSON.parse(s); if (Array.isArray(o)) o.forEach(onEvt); else onEvt(o); }catch{} }
}
```

---

## 4) `engine/renderer/layout/incremental.ts` (new) — light incremental forces

```ts
// engine/renderer/layout/incremental.ts — Stage 4R
export type LayNode = { id:string; x:number; y:number; neighbors:Set<string> };
export type LayState = { nodes: Record<string, LayNode> };

export function stepLayout(state: LayState, added: string[], removed: string[], iters=8){
  // initialize new nodes near their neighbors (or origin)
  for (const id of added){ const n = state.nodes[id]; if (!n) continue; const nb = [...n.neighbors]; if (nb.length){ let cx=0,cy=0; for (const t of nb){ const m=state.nodes[t]; if (m){ cx+=m.x; cy+=m.y; } } cx/=nb.length; cy/=nb.length; const jitter=6; n.x=cx+(Math.random()-0.5)*jitter; n.y=cy+(Math.random()-0.5)*jitter; } }
  // drop removed handled by caller (we assume they’re gone)

  // small-force iterations (Fruchterman‑Reingold–ish)
  const ids = Object.keys(state.nodes);
  const k = 22; const kk = k*k; const alpha = 0.04;
  for (let it=0; it<iters; it++){
    const dx: Record<string,number> = {}; const dy: Record<string,number> = {};
    // repulsion (sampled)
    for (let i=0;i<ids.length;i++){
      const a = state.nodes[ids[i]]; let fx=0, fy=0;
      for (let j=i+1;j<ids.length;j+=Math.ceil(ids.length/800)){ // sample for O(n log n) feel
        const b = state.nodes[ids[j]]; const dxab=a.x-b.x, dyab=a.y-b.y; const dist2 = dxab*dxab+dyab*dyab+0.01; const f = kk/dist2; fx += (dxab/Math.sqrt(dist2))*f; fy += (dyab/Math.sqrt(dist2))*f;
        dx[ids[j]] = (dx[ids[j]]||0) - (dxab/Math.sqrt(dist2))*f; dy[ids[j]] = (dy[ids[j]]||0) - (dyab/Math.sqrt(dist2))*f;
      }
      dx[a.id] = (dx[a.id]||0) + fx; dy[a.id] = (dy[a.id]||0) + fy;
    }
    // attraction (edges)
    for (const id of ids){ const a=state.nodes[id]; for (const t of a.neighbors){ if (id>=t) continue; const b=state.nodes[t]; if (!b) continue; const dxab=a.x-b.x, dyab=a.y-b.y; const dist = Math.sqrt(dxab*dxab+dyab*dyab)+0.01; const f = (dist*dist)/k; const fx = -(dxab/dist)*f, fy=-(dyab/dist)*f; dx[a.id]=(dx[a.id]||0)+fx; dy[a.id]=(dy[a.id]||0)+fy; dx[b.id]=(dx[b.id]||0)-fx; dy[b.id]=(dy[b.id]||0)-fy; }
    }
    // integrate
    for (const id of ids){ const n = state.nodes[id]; n.x += (dx[id]||0)*alpha; n.y += (dy[id]||0)*alpha; }
  }
}
```

---

## 5) `playground/components/LivePanel.tsx` (new) — connect & control

```tsx
// playground/components/LivePanel.tsx
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { LiveIngest } from '../../engine/stream/ingest';
import { connectWebSocket, connectSSE, parseNdjson } from '../../engine/stream/sources';
import type { Evt, GraphState } from '../../engine/stream/types';
import { stepLayout } from '../../engine/renderer/layout/incremental';

export const LivePanel: React.FC<{ onSnapshot: (snap: ExecutionSnapshot)=>void; onReplaceHistory?: (snaps: ExecutionSnapshot[])=>void }>
= ({ onSnapshot, onReplaceHistory }) => {
  const [url, setUrl] = React.useState('ws://localhost:8080');
  const [status, setStatus] = React.useState<'idle'|'open'|'closed'|'error'|'paused'>('idle');
  const [follow, setFollow] = React.useState(true);
  const [buf, setBuf] = React.useState(0);
  const [dropped, setDropped] = React.useState(0);
  const ingestRef = React.useRef<LiveIngest|null>(null);
  const stateRef = React.useRef<GraphState|null>(null);
  const unsubRef = React.useRef<(()=>void)|null>(null);
  const tickRef = React.useRef(0);

  function ensureIngest(){ if (ingestRef.current) return ingestRef.current; const ingest = new LiveIngest({ fpsCap: 30, maxHistory: 1200, policy: 'coalesce', onSnapshot: flush }); ingestRef.current = ingest; return ingest; }

  function flush(gs: GraphState){
    stateRef.current = gs; setBuf(ingestRef.current?.backlog||0); setDropped(ingestRef.current?.droppedCount||0);
    // build slim ExecutionSnapshot
    const monads: any[] = []; const ids = Object.keys(gs.nodes);
    for (const id of ids){ const n=gs.nodes[id]; monads.push({ id, neighbors: Array.from(n.neighbors), x:n.x, y:n.y, label:n.label }); }
    // incremental layout step
    const layState = { nodes: Object.fromEntries(monads.map(m=>[m.id,{ id:m.id, x:m.x, y:m.y, neighbors:new Set(m.neighbors) }])) };
    const added = []; const removed = [];// (could diff vs previous)
    stepLayout(layState as any, added, removed, 6);
    for (const m of monads){ const s = layState.nodes[m.id]; m.x = s.x; m.y = s.y; }
    const snap = { tick: tickRef.current++, monads, rulesFired: gs.rules } as any;
    onSnapshot(snap);
  }

  function connect(kind:'ws'|'sse'){
    const ingest = ensureIngest();
    const onEvt = (e:Evt)=> ingest.push(e);
    const onStatus = (s:string)=> setStatus((s as any) || 'error');
    unsubRef.current?.();
    unsubRef.current = (kind==='ws'? connectWebSocket(url, onEvt, onStatus) : connectSSE(url, onEvt, onStatus));
  }

  function stop(){ unsubRef.current?.(); unsubRef.current=null; setStatus('closed'); }

  function pasteNdjson(){ const text = prompt('Paste NDJSON lines (each line = JSON event)…'); if (!text) return; ensureIngest(); parseNdjson(text, (e)=> ingestRef.current!.push(e)); setStatus('open'); }

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Live Stream</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <input value={url} onChange={e=>setUrl(e.target.value)} placeholder="ws:// or https:// (SSE)" style={{ flex:1, padding:6, border:'1px solid var(--mpl-border)', borderRadius:8 }} />
          <button className="mpl-btn" onClick={()=>connect('ws')}>WS</button>
          <button className="mpl-btn" onClick={()=>connect('sse')}>SSE</button>
          <button className="mpl-btn" onClick={stop}>Disconnect</button>
          <button className="mpl-btn" onClick={pasteNdjson}>Paste</button>
        </div>
        <div className="mpl-row">
          <span className={`mpl-chip ${status}`}>Status: {status}</span>
          <span className="mpl-chip">Backlog {buf}</span>
          <span className="mpl-chip">Dropped {dropped}</span>
          <label><input type="checkbox" checked={follow} onChange={e=>setFollow(e.target.checked)} /> Follow live</label>
        </div>
        <div className="mpl-dim">Event schema: <code>node_add/id</code>, <code>edge_add/a,b</code>, <code>node_del</code>, <code>edge_del</code>, <code>node_patch</code>, <code>rule</code>, <code>barrier</code>, <code>heartbeat</code>, <code>snapshot</code>.</div>
      </div>
    </div>
  );
};
```

---

## 6) `playground/components/CanvasPanel.tsx` (update) — live integration

```tsx
// CanvasPanel.tsx — 4R wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { LivePanel } from './LivePanel';

export const CanvasPanel: React.FC<{ history: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void; onReplaceTimeline?: (t:ExecutionSnapshot[])=>void }>
= ({ history, index, onIndex, onReplaceTimeline }) => {
  const [live, setLive] = React.useState(true);
  const [tail, setTail] = React.useState(history.length-1);
  const slim = React.useMemo(() => ensurePositions(toSlim(history[Math.max(0, Math.min(index, history.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, history]);
  const canvasRef = React.useRef<any>(null);

  function onSnap(s: ExecutionSnapshot){ onReplaceTimeline?.([...history, s].slice(-1200)); if (live) onIndex?.(history.length); setTail(history.length); }

  return (
    <div className="mpl-grid">
      <div className="mpl-main">
        <div className="mpl-livebar">
          <span className={`mpl-dot ${index>=tail?'on':'lag'}`} />
          <span className="mpl-dim">{index>=tail? 'LIVE' : `LIVE (−${tail-index})`}</span>
          {index<tail && <button className="mpl-btn" onClick={()=>onIndex?.(tail)}>Catch up</button>}
          <label style={{ marginLeft:'auto' }}><input type="checkbox" checked={live} onChange={e=>setLive(e.target.checked)} /> Follow tail</label>
        </div>
        <GraphCanvas ref={canvasRef} snapshot={slim} />
      </div>
      <aside className="mpl-side">
        <LivePanel onSnapshot={onSnap} onReplaceHistory={(t)=>onReplaceTimeline?.(t)} />
      </aside>
    </div>
  );
};
```

---

## 7) Styles — `playground/styles/debugger.css` (additions)

```css
/* Stage 4R — live bar */
.mpl-livebar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
.mpl-dot { width:10px; height:10px; border-radius:999px; background:#9ca3af; display:inline-block; }
.mpl-dot.on { background:#22c55e; box-shadow: 0 0 12px rgba(34,197,94,.7); }
.mpl-dot.lag { background:#f59e0b; box-shadow: 0 0 12px rgba(245,158,11,.6); }
.mpl-chip.open{ background:#dcfce7; }
.mpl-chip.closed{ background:#fee2e2; }
.mpl-chip.error{ background:#fee2e2; border-color:#fecaca; }
```

---

## 8) Example — `playground/pages/DebugExample4R.tsx` (local generator)

```tsx
// playground/pages/DebugExample4R.tsx
import React, { useEffect, useRef, useState } from 'react';
import { DebuggerPanel } from '../components/DebuggerPanel';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import type { Evt } from '../../engine/stream/types';
import { LiveIngest } from '../../engine/stream/ingest';

export default function DebugExample4R(){
  const [history, setHistory] = useState<ExecutionSnapshot[]>([]);
  const [index, setIndex] = useState(0);
  const ingestRef = useRef<LiveIngest|null>(null);

  useEffect(()=>{
    const ingest = new LiveIngest({ fpsCap: 24, onSnapshot: (gs)=>{
      const monads:any[]=[]; for (const id in gs.nodes){ const n=gs.nodes[id]; monads.push({ id, x:n.x, y:n.y, neighbors:[...n.neighbors] }); }
      const snap = { tick: history.length, monads, rulesFired: gs.rules } as any;
      setHistory(h => [...h, snap].slice(-600)); setIndex(i=>Math.max(i, history.length));
    }}); ingestRef.current = ingest;

    // local generator — emits a rolling hairball
    let t=0; const ids = Array.from({length:160}, (_,i)=>'N'+i);
    for (const id of ids) ingest.push({ t:'node_add', id, x: (Math.random()-0.5)*120, y:(Math.random()-0.5)*120 });
    const tick = () => {
      for (let k=0;k<80;k++){ const a = ids[(Math.random()*ids.length)|0], b = ids[(Math.random()*ids.length)|0]; if (a===b) continue; if (Math.random()<0.5) ingest.push({ t:'edge_add', a,b }); else ingest.push({ t:'edge_del', a,b }); }
      if (Math.random()<0.5) ingest.push({ t:'rule', id: ['Bridge','PromotePath','Seed'][(Math.random()*3)|0] });
      ingest.push({ t:'barrier', ts: Date.now() });
      if (t++<240) setTimeout(tick, 50); // ~20 fps source
    };
    tick();

    return ()=> ingest.stop();
  }, []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4R — Streaming Ingest + Backpressure + Incremental Layout</h1>
      <DebuggerPanel history={history} index={index} onIndex={setIndex} onReplaceTimeline={setHistory} />
      <p className="mpl-dim">This page simulates a fast producer with coalescing backpressure and a lightweight incremental layout.</p>
    </div>
  );
}
```

---

## 9) Producer quickstart (example payloads)

```json
{"t":"node_add","id":"A","x":0,"y":0,"label":"alpha"}
{"t":"node_add","id":"B"}
{"t":"edge_add","a":"A","b":"B"}
{"t":"rule","id":"Bridge"}
{"t":"barrier","ts":1724750000000}
```

> Send lines as NDJSON, WebSocket messages, or SSE `data:` blobs.

---

## 10) Notes

* **Source pacing**: `barrier` acts as a natural frame marker; without it, the ingestor coalesces events up to the FPS cap.
* **Layout cost**: `stepLayout` runs \~6 iters/frame; increase for nicer motion or reduce for scale. For huge graphs, move it into your worker and call per‑flush.
* **Warm start**: When diffing with a previous layout, seed `added`/`removed` arrays for better stability (hooks provided).
* **History cap**: The example keeps the last \~1200 snapshots; tune or switch to sparse keyframes if you don’t need every frame.
* **Interop**: Alerts (4P) and heat lanes (4K) work since we emit `rulesFired` and advance `tick` each flush.
* **Reliability**: Heartbeats can drive a “stale” badge if no `barrier` within N ms. The Live bar shows lag and a Catch‑up affordance.

---

## 11) Changelog — Stage 4R

* New: `engine/stream/types.ts`, `engine/stream/ingest.ts`, `engine/stream/sources.ts`
* New: `engine/renderer/layout/incremental.ts`
* New UI: `LivePanel.tsx`
* Updated: `CanvasPanel.tsx` (live bar + follow tail)
* Styles: live status chips & dot indicators

```
```
