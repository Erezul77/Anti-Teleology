# MPL Playground — Stage 4N Patch (Annotations + Callouts + Guided Tours)

This patch layers **authoring + storytelling** tools on top of 4C–4M:

* **Annotations**: sticky notes, callouts, and regions anchored to nodes, edges, or world points
* **Callouts**: auto‑tailed bubbles that follow their anchors as the layout animates
* **Guided Tours**: sequenced steps that pan/zoom, spotlight targets, and show narration

No external deps. All state is serializable, shareable, and persisted locally.

---

## Highlights

* Anchors: **node**, **edge(a↔b)**, or **world(x,y)**
* Formats: **Note** (no tail), **Callout** (bubble + tail), **Region** (rounded rect spotlight)
* Authoring: click **Add** then choose a target; drag callouts; edit Markdown body
* Tours: stepper UI (prev/next/play), **spotlight dimming**, optional **auto‑advance** delay
* Persistence: `localStorage` autosave + **.mpl-annot.json** export/import
* Share: `#tour=<base64url>` encodes a single tour for quick sharing

---

## 1) `engine/ui/annotations.ts` (new) — model + storage + encoding

```ts
// engine/ui/annotations.ts — Stage 4N
export type Anchor =
  | { type:'node'; id:string }
  | { type:'edge'; a:string; b:string }
  | { type:'world'; x:number; y:number };

export type AnnotKind = 'note'|'callout'|'region';

export interface Annotation {
  id: string;
  kind: AnnotKind;
  anchor: Anchor;
  title?: string;
  md?: string;             // Markdown body (lightweight — render as plain HTML)
  color?: string;          // accent (css color)
  dx?: number; dy?: number;// screen offset for label bubble (px)
  w?: number; h?: number;  // region size (for kind==='region', world units)
}

export interface TourStep {
  id: string;              // stable step id
  annotId?: string;        // link to an annotation to show
  focus?: { x:number; y:number; r:number }; // optional world spotlight circle
  panTo?: boolean;         // pan camera to anchor or focus
  zoom?: number | null;    // set camera z
  note?: string;           // narration md (in addition to annotation md)
  waitMs?: number;         // autoplay delay per step
}

export interface Tour { id: string; name: string; steps: TourStep[] }
export interface AnnotState { annots: Annotation[]; tours: Tour[] }

const KEY = 'mpl.annots.v1';

export function loadAnnots(): AnnotState { try { const raw = localStorage.getItem(KEY); return raw? JSON.parse(raw) : { annots:[], tours:[] }; } catch { return { annots:[], tours:[] }; } }
export function saveAnnots(s: AnnotState){ try { localStorage.setItem(KEY, JSON.stringify(s)); } catch {} }

export function downloadAnnots(s: AnnotState){ const blob = new Blob([JSON.stringify(s,null,2)], { type:'application/json' }); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='annotations.mpl-annot.json'; a.click(); URL.revokeObjectURL(a.href); }
export async function openAnnots(): Promise<AnnotState|null>{ return new Promise(res=>{ const i=document.createElement('input'); i.type='file'; i.accept='.json,application/json'; i.onchange=()=>{ const f=i.files?.[0]; if(!f) return res(null); const r=new FileReader(); r.onload=()=>{ try{ res(JSON.parse(String(r.result))); }catch{ res(null); } }; r.readAsText(f); }; i.click(); }); }

// share encoding for a single tour
export function encodeTour(t: Tour){ const j=JSON.stringify(t); const b=btoa(unescape(encodeURIComponent(j))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); return b; }
export function decodeTour(s: string): Tour|null { try{ const b=s.replace(/-/g,'+').replace(/_/g,'/'); const pad=b.length%4? '='.repeat(4-(b.length%4)) : ''; const j=decodeURIComponent(escape(atob(b+pad))); return JSON.parse(j); }catch{ return null; } }

export function genId(prefix='a'){ return prefix + Math.random().toString(36).slice(2,8); }
```

---

## 2) `engine/renderer/canvas/AnnotLayer.tsx` (new) — SVG overlay for callouts/regions

```tsx
// engine/renderer/canvas/AnnotLayer.tsx — Stage 4N
import React from 'react';
import type { Annotation } from '../../ui/annotations';

export interface AnnotLayerProps {
  annots: Annotation[];
  pos: Record<string,{x:number;y:number}>;       // live positions from GraphCanvas
  camera: { x:number;y:number;z:number };        // camera from GraphCanvas
  onMove?: (id:string, dx:number, dy:number)=>void; // screen offset drag
}

function worldToScreen(wx:number, wy:number, cam:{x:number;y:number;z:number}){ return { x: wx*cam.z + cam.x + 0, y: wy*cam.z + cam.y + 0 } }

export const AnnotLayer: React.FC<AnnotLayerProps> = ({ annots, pos, camera, onMove }) => {
  const [drag, setDrag] = React.useState<{ id:string; ox:number; oy:number; sx:number; sy:number }|null>(null);
  const ref = React.useRef<SVGSVGElement>(null);

  const items = annots.map(a => {
    let x=0,y=0;
    if (a.anchor.type==='node'){ const p = pos[a.anchor.id]; if (p){ const s=worldToScreen(p.x,p.y,camera); x=s.x; y=s.y; } }
    else if (a.anchor.type==='edge'){ const A=pos[a.anchor.a], B=pos[a.anchor.b]; if (A&&B){ const sA=worldToScreen(A.x,A.y,camera), sB=worldToScreen(B.x,B.y,camera); x=(sA.x+sB.x)/2; y=(sA.y+sB.y)/2; } }
    else { const s=worldToScreen(a.anchor.x,a.anchor.y,camera); x=s.x; y=s.y; }
    const dx=a.dx||0, dy=a.dy||0; return { a, sx:x+dx, sy:y+dy, tx:x, ty:y };
  });

  function onMouseDown(e: React.MouseEvent, id:string){ const box = ref.current!.getBoundingClientRect(); setDrag({ id, ox: e.clientX - box.left, oy: e.clientY - box.top, sx: e.clientX, sy: e.clientY }); }
  React.useEffect(() => { const up = ()=> setDrag(null); const move = (e:MouseEvent)=>{ if(!drag) return; const box=ref.current!.getBoundingClientRect(); const cx=e.clientX-box.left, cy=e.clientY-box.top; onMove?.(drag.id, cx-(drag.ox), cy-(drag.oy)); }; window.addEventListener('mouseup',up); window.addEventListener('mousemove',move); return ()=>{ window.removeEventListener('mouseup',up); window.removeEventListener('mousemove',move); } }, [drag]);

  return (
    <svg ref={ref} className="mpl-annot-layer" style={{ position:'absolute', inset:0, pointerEvents:'none' }}>
      {/* callouts */}
      {items.filter(it=>it.a.kind!=='region').map(({ a, sx, sy, tx, ty }) => (
        <g key={a.id} transform={`translate(${sx},${sy})`} style={{ pointerEvents:'auto' }}>
          {/* tail */}
          {a.kind==='callout' && (<line x1={0} y1={0} x2={tx-sx} y2={ty-sy} stroke={a.color||'#111'} strokeOpacity={0.6} strokeWidth={2} />)}
          <foreignObject x={-140} y={-70} width={280} height={120} onMouseDown={(e)=>onMouseDown(e, a.id)}>
            <div className="mpl-callout" style={{ borderColor:a.color || '#e5e7eb' }}>
              {a.title ? <div className="mpl-callout-h">{a.title}</div> : null}
              {a.md ? <div className="mpl-callout-b" dangerouslySetInnerHTML={{ __html: renderMarkdown(a.md) }} /> : null}
            </div>
          </foreignObject>
        </g>
      ))}
      {/* regions */}
      {items.filter(it=>it.a.kind==='region').map(({ a, tx, ty }) => (
        <g key={a.id}>
          <rect x={tx-(a.w||100)/2*camera.z+camera.x} y={ty-(a.h||60)/2*camera.z+camera.y} width={(a.w||100)*camera.z} height={(a.h||60)*camera.z} rx={8} ry={8} fill={(a.color||'#f59e0b')} fillOpacity={0.08} stroke={a.color||'#f59e0b'} strokeOpacity={0.4} />
        </g>
      ))}
    </svg>
  );
};

function renderMarkdown(md?: string){ if(!md) return ''; // very light md (bold/italic/code/links)
  let html = md
    .replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>')
    .replace(/\*(.*?)\*/g,'<em>$1</em>')
    .replace(/`([^`]+)`/g,'<code>$1</code>')
    .replace(/\[(.*?)\]\((.*?)\)/g,'<a href="$2" target="_blank" rel="noreferrer">$1<\/a>');
  html = html.replace(/\n/g,'<br/>');
  return html;
}
```

---

## 3) `playground/components/AnnotPanel.tsx` (new) — create/edit annotations

```tsx
// playground/components/AnnotPanel.tsx — Stage 4N
import React from 'react';
import type { Annotation, Anchor, AnnotState } from '../../engine/ui/annotations';
import { genId, loadAnnots, saveAnnots, downloadAnnots, openAnnots } from '../../engine/ui/annotations';

export const AnnotPanel: React.FC<{
  onCreateAnchor: (mode: 'node'|'edge'|'world') => Promise<Anchor|null>; // implemented by CanvasPanel
  state: AnnotState; setState: (s: AnnotState)=>void;
}>
= ({ onCreateAnchor, state, setState }) => {
  const [kind, setKind] = React.useState<'note'|'callout'|'region'>('callout');
  const [title, setTitle] = React.useState('');
  const [md, setMd] = React.useState('');
  const [color, setColor] = React.useState('#6366f1');

  function add(a: Anchor){ const ann: Annotation = { id: genId('ann_'), kind, anchor:a, title, md, color, dx:0, dy:0, w:180, h:100 }; const s={ ...state, annots:[ann, ...state.annots] }; setState(s); saveAnnots(s); setTitle(''); setMd(''); }

  async function create(mode:'node'|'edge'|'world'){ const a = await onCreateAnchor(mode); if (a) add(a); }

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Annotations</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <label>Kind <select value={kind} onChange={e=>setKind(e.target.value as any)}><option>callout</option><option>note</option><option>region</option></select></label>
          <label>Color <input type="color" value={color} onChange={e=>setColor(e.target.value)} /></label>
        </div>
        <input placeholder="Title" value={title} onChange={e=>setTitle(e.target.value)} />
        <textarea placeholder="Markdown body…" rows={4} value={md} onChange={e=>setMd(e.target.value)} />
        <div className="mpl-row">
          <button className="mpl-btn" onClick={()=>create('node')}>Add on Node</button>
          <button className="mpl-btn" onClick={()=>create('world')}>Add at Point</button>
          {/* edge authoring can be added later */}
          <button className="mpl-btn" onClick={()=>{ const s=loadAnnots(); setState(s); }}>Reload</button>
          <button className="mpl-btn" onClick={()=>downloadAnnots(state)}>Export</button>
          <button className="mpl-btn" onClick={async()=>{ const s = await openAnnots(); if(s){ setState(s); saveAnnots(s); } }}>Import</button>
        </div>
        <div className="mpl-list-b">
          {state.annots.map(a => (
            <div key={a.id} className="mpl-annot-item">
              <span className="mpl-chip" style={{ background:a.color }}>{a.kind}</span>
              <strong>{a.title||'(untitled)'}</strong>
              <span className="mpl-dim">{a.anchor.type}</span>
              <button className="mpl-btn" onClick={()=>{ const s={ ...state, annots: state.annots.filter(x=>x.id!==a.id) }; setState(s); saveAnnots(s); }}>Delete</button>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

---

## 4) `playground/components/TourPlayer.tsx` (new) — guided tours

```tsx
// playground/components/TourPlayer.tsx — Stage 4N
import React from 'react';
import type { Tour, AnnotState } from '../../engine/ui/annotations';
import { encodeTour, decodeTour, saveAnnots } from '../../engine/ui/annotations';

export const TourPlayer: React.FC<{
  state: AnnotState; setState: (s: AnnotState)=>void;
  goCamera: (x:number,y:number,z?:number|null)=>void;   // camera controls from CanvasPanel
  focus: (x:number,y:number,r:number)=>void;            // set spotlight (overlay)
}>
= ({ state, setState, goCamera, focus }) => {
  const [idx, setIdx] = React.useState(0);            // selected tour index
  const [step, setStep] = React.useState(0);
  const tours = state.tours;
  const cur = tours[idx];
  const playingRef = React.useRef(false);

  React.useEffect(() => { const h = () => { const m=/#tour=([^&]+)/.exec(location.hash); if(!m) return; const t = decodeTour(m[1]); if(!t) return; setState(s=>({ ...s, tours:[t, ...s.tours] })); }; h(); window.addEventListener('hashchange',h); return ()=>window.removeEventListener('hashchange',h); }, []);

  function runStep(){ if(!cur) return; const st = cur.steps[step]; if(!st) return;
    if (st.zoom!=null) goCamera(NaN, NaN, st.zoom); // preserve x/y
    if (st.focus){ focus(st.focus.x, st.focus.y, st.focus.r); if (st.panTo) goCamera(-st.focus.x, -st.focus.y, null); }
    // if linked to an annotation, we could scroll it into view; here overlay handles visibility
  }

  React.useEffect(() => { runStep(); }, [idx, step, cur?.id]);

  React.useEffect(() => { let tid:any; if (playingRef.current && cur){ const st=cur.steps[step]; const wait=st?.waitMs ?? 1800; tid = setTimeout(()=>{ setStep(s => (s+1) % cur.steps.length); }, wait); } return ()=>clearTimeout(tid); }, [step, cur?.id, playingRef.current]);

  if (!tours.length) return (
    <div className="mpl-card"><div className="mpl-card-h">Tours</div><div className="mpl-card-b mpl-dim">No tours yet — create annotations and assemble a tour.</div></div>
  );

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Tours</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <select value={idx} onChange={e=>{ setIdx(parseInt(e.target.value)); setStep(0); }}>
          {tours.map((t,i)=><option key={t.id} value={i}>{t.name}</option>)}
        </select>
        <div className="mpl-row">
          <button className="mpl-btn" onClick={()=>setStep(s=>Math.max(0,s-1))}>Back</button>
          <div className="mpl-chip">{step+1}/{cur.steps.length}</div>
          <button className="mpl-btn" onClick={()=>setStep(s=>(s+1)%cur.steps.length)}>Next</button>
          <button className="mpl-btn" onClick={()=>{ playingRef.current=!playingRef.current; }}>{playingRef.current? 'Pause':'Play'}</button>
          <button className="mpl-btn" onClick={()=>{ const url = location.origin+location.pathname + '#tour=' + encodeTour(cur); navigator.clipboard.writeText(url); }}>Copy Share Link</button>
        </div>
      </div>
    </div>
  );
};
```

---

## 5) `playground/components/SpotlightOverlay.tsx` (new) — dim background, spotlight focus

```tsx
// playground/components/SpotlightOverlay.tsx — Stage 4N
import React from 'react';

export const SpotlightOverlay: React.FC<{ focus: { x:number;y:number;r:number } | null; camera:{x:number;y:number;z:number} }>
= ({ focus, camera }) => {
  if (!focus) return null;
  const cx = focus.x*camera.z + camera.x; const cy = focus.y*camera.z + camera.y; const r = focus.r*camera.z;
  const path = `M0,0 H10000 V10000 H0 Z M${cx},${cy} m-${r},0 a ${r},${r} 0 1,0 ${r*2},0 a ${r},${r} 0 1,0 -${r*2},0`;
  return (
    <svg className="mpl-spot" style={{ position:'absolute', inset:0, pointerEvents:'none' }}>
      <path d={path} fill="rgba(0,0,0,0.5)" fillRule="evenodd" />
    </svg>
  );
};
```

---

## 6) `playground/components/CanvasPanel.tsx` (update) — wire overlay, authoring, tours

```tsx
// CanvasPanel.tsx — Stage 4N wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { AnnotLayer } from '../../engine/renderer/canvas/AnnotLayer';
import { AnnotPanel } from './AnnotPanel';
import { TourPlayer } from './TourPlayer';
import { SpotlightOverlay } from './SpotlightOverlay';
import type { AnnotState, Anchor } from '../../engine/ui/annotations';
import { loadAnnots, saveAnnots } from '../../engine/ui/annotations';

export const CanvasPanel: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= ({ timeline, index, onIndex }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(timeline[Math.max(0, Math.min(index, timeline.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, timeline]);

  const [camera, setCamera] = React.useState({ x:0,y:0,z:1 });
  const [pos, setPos] = React.useState<Record<string,{x:number;y:number}>>({});
  const [state, setState] = React.useState<AnnotState>(()=>loadAnnots());
  const [focus, setFocus] = React.useState<{x:number;y:number;r:number}|null>(null);

  // helper to move callouts
  function moveAnnot(id:string, dx:number, dy:number){ setState(s=>{ const ann = s.annots.find(a=>a.id===id); if(ann){ ann.dx=(dx|0); ann.dy=(dy|0); const ns={ ...s }; saveAnnots(ns); return ns; } return s; }); }

  // authoring: resolve an anchor by mode
  async function onCreateAnchor(mode:'node'|'edge'|'world'): Promise<Anchor|null>{
    if (mode==='node'){
      const id = await pickNodeOnce(); return id? { type:'node', id } : null;
    } else if (mode==='world'){
      const p = await pickPointOnce(); return p? { type:'world', x: p.x, y: p.y } : null;
    } else { return null; }
  }

  function pickNodeOnce(): Promise<string|null>{ return new Promise(res => {
    const onPick = (id:string|null)=>{ res(id); cleanup(); };
    window.addEventListener('mpl_pick', (e:any)=> onPick(e.detail));
    function cleanup(){ window.removeEventListener('mpl_pick', (e:any)=> onPick(e.detail)); }
  }); }

  function pickPointOnce(): Promise<{x:number;y:number}|null>{ return new Promise(res => {
    const el = document.querySelector('canvas'); if(!el) return res(null);
    const on = (e:MouseEvent)=>{ const rect=(el as HTMLCanvasElement).getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top; const x=(sx-camera.x)/camera.z, y=(sy-camera.y)/camera.z; res({ x,y }); cleanup(); };
    el.addEventListener('click', on, { once:true }); function cleanup(){ el.removeEventListener('click', on as any); }
  }); }

  // expose a custom pick event from GraphCanvas (hook into its onPick)
  const onPick = (id:string|null) => { const ev = new CustomEvent('mpl_pick', { detail:id }); window.dispatchEvent(ev); };

  // spotlight focus helper for TourPlayer
  function setSpot(x:number,y:number,r:number){ setFocus({ x,y,r }); setTimeout(()=> setFocus(null), 50); /* keep last set; overlay reads live camera */ }

  // camera go (used by tours): NaN preserves
  function goCamera(nx:number, ny:number, z?:number|null){ setCamera(c=>({ x: isNaN(nx)? c.x : nx, y: isNaN(ny)? c.y : ny, z: z==null? c.z : z })); }

  return (
    <div className="mpl-grid" style={{ position:'relative' }}>
      <div className="mpl-main">
        <div style={{ position:'relative' }}>
          <GraphCanvas snapshot={slim} camera={camera} onCamera={setCamera} onPositions={setPos} onPick={onPick} />
          <SpotlightOverlay focus={focus} camera={camera} />
          <AnnotLayer annots={state.annots} pos={pos} camera={camera} onMove={moveAnnot} />
        </div>
      </div>
      <aside className="mpl-side">
        <AnnotPanel onCreateAnchor={onCreateAnchor} state={state} setState={(s)=>{ setState(s); saveAnnots(s); }} />
        <TourPlayer state={state} setState={(s)=>{ setState(s); saveAnnots(s); }} goCamera={goCamera} focus={setSpot} />
      </aside>
    </div>
  );
};
```

---

## 7) Styles — `playground/styles/debugger.css` (additions)

```css
/* Stage 4N — annotations & tours */
.mpl-callout { background: var(--mpl-surface); border: 1px solid var(--mpl-border); border-radius: 10px; box-shadow: 0 4px 18px rgba(0,0,0,.08); padding: 8px 10px; max-height: 110px; overflow: auto; }
.mpl-callout-h { font-weight: 600; margin-bottom: 4px; }
.mpl-callout-b { font-size: 12px; color: var(--mpl-text); }
.mpl-annot-item { display: grid; grid-template-columns: auto 1fr auto auto; gap: 8px; align-items: center; padding: 6px 0; border-bottom: 1px dashed var(--mpl-border); }
.mpl-annot-layer { mix-blend-mode: normal; }
.mpl-spot { pointer-events: none; }
```

---

## 8) Example — `playground/pages/DebugExample4N.tsx`

```tsx
// playground/pages/DebugExample4N.tsx
import React, { useMemo } from 'react';
import { DebuggerPanel } from '../components/DebuggerPanel';
import { ExecutionSnapshot } from '../../engine/debugger/graphTypes';

function ex(): ExecutionSnapshot[]{
  const ids = ['A','B','C','D','E'];
  const monads = [
    { id:'A', neighbors:['B','C'], x:-120, y:0 },
    { id:'B', neighbors:['A','D'], x:0, y:-60 },
    { id:'C', neighbors:['A','E'], x:0, y:60 },
    { id:'D', neighbors:['B'], x:120, y:-60 },
    { id:'E', neighbors:['C'], x:120, y:60 },
  ];
  return [{ tick:0, monads, rulesFired:['Seed'] } as any];
}

export default function DebugExample4N(){
  const history = useMemo(ex, []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4N — Annotations + Callouts + Guided Tours</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Use the Annotations panel to add callouts (attach to a node or point). Create a Tour and copy a share link.</p>
    </div>
  );
}
```

---

## 9) Notes

* **Edge anchors**: the UI stubs are ready — to support edge picking, reuse your edge hit‑testing from the renderer (or compute nearest edge in screen space during authoring mode).
* **Markdown**: a tiny renderer is included for safety; swap for a full parser if desired.
* **Z‑order**: annotations render in an absolutely‑positioned SVG above the canvas, so they remain crisp while panning/zooming.
* **Tours & Presentation (4M)**: combine by enabling Presentation Mode before playing a tour for a clean look.
* **URL sharing**: tours shared via `#tour=...` don’t include the underlying dataset — recipients need the same timeline loaded.

---

## 10) Changelog — Stage 4N

* New: `engine/ui/annotations.ts` (model + storage + share encoding)
* New: `engine/renderer/canvas/AnnotLayer.tsx` (SVG overlay)
* New UI: `AnnotPanel.tsx`, `TourPlayer.tsx`, `SpotlightOverlay.tsx`
* Updated: `CanvasPanel.tsx` (wire annotations & tours)
* Styles: callouts, list items, spotlight overlay

```
```
