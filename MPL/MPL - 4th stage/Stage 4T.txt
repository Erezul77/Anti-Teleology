# MPL Playground — Stage 4T Patch (Scene Export: PNG/SVG/PDF + Share Packs)

This patch adds **first‑class export** of the current scene to **PNG**, **SVG**, and **PDF** (print‑friendly) plus **Share Packs** (portable .mpack bundles) that capture the scene + local tooling state (annotations, saved searches, baselines, settings). Zero external deps.

Builds on 4C–4S.

---

## Highlights

* Export controls: **size presets**, **scale multiplier**, **transparent/background color**, **include annotations/tours**, **watermark**.
* **PNG**: crisp raster at arbitrary resolution.
* **SVG**: vector export (nodes/edges/labels/annotations) with embedded stylesheet.
* **PDF**: simple, 1‑page print layout using the browser print pipeline (works everywhere without libs).
* **Share Pack (.mpack)**: one file containing snapshot(s) + local config (4N/4P/4S/4M); **import** restores.

---

## 1) `engine/renderer/export.ts` — bounds + PNG/SVG helpers

```ts
// engine/renderer/export.ts — Stage 4T
import type { SnapshotSlim } from '../core/perf/timelineDelta';

export type ExportOpts = {
  width: number; height: number; scale?: number; background?: 'transparent'|string; // css color
  showGrid?: boolean; showLabels?: boolean; showAnnotations?: boolean; watermark?: string|null;
  nodesRadius?: number; edgeWidth?: number; font?: string; // style knobs
};

export function worldBounds(s: SnapshotSlim){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for (const id in s.monads){ const p:any=(s.monads as any)[id]; const x=p.x||0, y=p.y||0; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; } if(!isFinite(minX)) return {minX:-1,minY:-1,maxX:1,maxY:1}; return { minX, minY, maxX, maxY } }

function fit(s: SnapshotSlim, w:number, h:number){ const b=worldBounds(s); const pad=24; const sx=(w-2*pad)/Math.max(1,(b.maxX-b.minX)||1); const sy=(h-2*pad)/Math.max(1,(b.maxY-b.minY)||1); const k=Math.min(sx,sy); return { k, ox: -b.minX*k + pad, oy: -b.minY*k + pad } }

export async function exportPNG(s: SnapshotSlim, opts: ExportOpts): Promise<Blob>{
  const scale = opts.scale ?? 1; const W = Math.max(1, Math.round(opts.width*scale)), H = Math.max(1, Math.round(opts.height*scale));
  const c = document.createElement('canvas'); c.width=W; c.height=H; const ctx=c.getContext('2d')!; const { k, ox, oy } = fit(s, W, H);

  // background
  if (opts.background && opts.background!=='transparent'){ ctx.fillStyle = opts.background; ctx.fillRect(0,0,W,H); }

  // grid (light)
  if (opts.showGrid){ ctx.strokeStyle='rgba(0,0,0,.06)'; ctx.lineWidth=1; const step=40; for(let x=0;x<W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } }

  // edges
  ctx.lineWidth = (opts.edgeWidth ?? 1) * Math.max(1, scale); ctx.strokeStyle='#94a3b8';
  for (const id in s.monads){ const a:any=(s.monads as any)[id]; for (const t of a.neighbors||[]){ if (id>=t) continue; const b:any=(s.monads as any)[t]; const x1=a.x*k+ox, y1=a.y*k+oy, x2=b.x*k+ox, y2=b.y*k+oy; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); } }

  // nodes
  ctx.fillStyle='#111827'; const r=(opts.nodesRadius ?? 3) * Math.max(1, scale);
  for (const id in s.monads){ const p:any=(s.monads as any)[id]; const x=p.x*k+ox, y=p.y*k+oy; ctx.beginPath(); ctx.arc(x,y,r,0,6.283); ctx.fill(); }

  // labels (centered, optional)
  if (opts.showLabels){ ctx.font = `${Math.round(11*scale)}px ${opts.font||'ui-sans-serif, system-ui'}`; ctx.fillStyle='#111827'; ctx.textAlign='left'; ctx.textBaseline='middle';
    for (const id in s.monads){ const p:any=(s.monads as any)[id]; if (!p.label) continue; const x=p.x*k+ox, y=p.y*k+oy; ctx.fillText(String(p.label), x+6*scale, y); }
  }

  // watermark
  if (opts.watermark){ ctx.save(); ctx.globalAlpha=0.25; ctx.rotate(-Math.PI/6); ctx.font=`${Math.round(24*scale)}px ${opts.font||'ui-sans-serif, system-ui'}`; ctx.fillStyle='#6b7280'; ctx.fillText(opts.watermark, 40, H/2); ctx.restore(); }

  return new Promise((res)=> c.toBlob(b=>res(b||new Blob()), 'image/png'));
}

export function exportSVG(s: SnapshotSlim, opts: ExportOpts): string {
  const scale = opts.scale ?? 1; const W=Math.max(1, Math.round(opts.width*scale)), H=Math.max(1, Math.round(opts.height*scale)); const { k, ox, oy }=fit(s,W,H);
  const bg = (opts.background && opts.background!=='transparent') ? `<rect width="100%" height="100%" fill="${opts.background}"/>` : '';
  const grid = opts.showGrid ? gridSVG(W,H) : '';
  let edges='';
  for (const id in s.monads){ const a:any=(s.monads as any)[id]; for (const t of a.neighbors||[]){ if (id>=t) continue; const b:any=(s.monads as any)[t]; const x1=a.x*k+ox, y1=a.y*k+oy, x2=b.x*k+ox, y2=b.y*k+oy; edges += `<line x1="${x1.toFixed(2)}" y1="${y1.toFixed(2)}" x2="${x2.toFixed(2)}" y2="${y2.toFixed(2)}" class="edge"/>`; } }
  let nodes=''; for (const id in s.monads){ const p:any=(s.monads as any)[id]; const x=p.x*k+ox, y=p.y*k+oy; nodes += `<circle cx="${x.toFixed(2)}" cy="${y.toFixed(2)}" r="${(opts.nodesRadius??3)*scale}" class="node"/>`; }
  let labels=''; if (opts.showLabels){ for (const id in s.monads){ const p:any=(s.monads as any)[id]; if(!p.label) continue; const x=p.x*k+ox, y=p.y*k+oy; labels += `<text x="${(x+6*scale).toFixed(2)}" y="${y.toFixed(2)}" class="label">${escapeXml(String(p.label))}</text>`; } }
  const css = `<![CDATA[
    .edge{ stroke:#94a3b8; stroke-width:${(opts.edgeWidth??1)*scale}; }
    .node{ fill:#111827; }
    .label{ fill:#111827; font:${Math.round(11*scale)}px ${opts.font||'ui-sans-serif, system-ui'}; dominant-baseline:middle; }
  ]]>`;
  return `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">\n  <defs><style type="text/css">${css}</style></defs>\n  ${bg}${grid}\n  <g>${edges}</g>\n  <g>${nodes}</g>\n  <g>${labels}</g>\n</svg>`;
}

function gridSVG(W:number,H:number){ const step=40; let lines=''; for(let x=0;x<W;x+=step){ lines += `<line x1="${x}" y1="0" x2="${x}" y2="${H}" stroke="rgba(0,0,0,.06)"/>`; } for(let y=0;y<H;y+=step){ lines += `<line x1="0" y1="${y}" x2="${W}" y2="${y}" stroke="rgba(0,0,0,.06)"/>`; } return `<g>${lines}</g>`; }
function escapeXml(s:string){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&apos;'}[c] as string)); }
```

---

## 2) `engine/renderer/exportPdf.ts` — print‑friendly single‑page PDF

```ts
// engine/renderer/exportPdf.ts — Stage 4T
import type { SnapshotSlim } from '../core/perf/timelineDelta';
import { exportPNG } from './export';

export async function exportPDF(s: SnapshotSlim, opts: { width: number; height: number; background?: string; title?: string; footer?: string; scale?: number }){
  const blob = await exportPNG(s, { width: opts.width, height: opts.height, scale: opts.scale??2, background: opts.background??'#ffffff' });
  const url = URL.createObjectURL(blob);
  const w = window.open('', '_blank'); if (!w) return;
  const title = opts.title || 'MPL Scene'; const footer = opts.footer || new Date().toLocaleString();
  w.document.write(`<!doctype html><html><head><meta charset="utf-8"/><title>${title}</title><style>
    @page{ size: A4; margin: 16mm; }
    body{ font-family: ui-sans-serif, system-ui; }
    .wrap{ display:flex; flex-direction:column; gap:12px; }
    img{ max-width:100%; height:auto; border:1px solid #e5e7eb; border-radius:8px; }
    .h{ font-weight:600; font-size:16px; }
    .f{ color:#6b7280; font-size:12px; }
  </style></head><body><div class="wrap">
    <div class="h">${title}</div>
    <img src="${url}"/>
    <div class="f">${footer}</div>
  </div><script>window.onload=()=>setTimeout(()=>window.print(), 300);</script></body></html>`);
  w.document.close();
}
```

---

## 3) `engine/share/pack.ts` — export/import Share Packs

```ts
// engine/share/pack.ts — Stage 4T
import type { ExecutionSnapshot } from '../debugger/graphTypes';

export type SharePack = {
  version: 'mpack-1';
  createdAt: string;
  meta: { title?: string; note?: string };
  scene: { tick: number; snapshot: any } | { range: { from:number; to:number }; history: any[] };
  local: {
    annotations?: any; // 4N key: mpl.annots.v1
    savedSearches?: any; // 4P key: mpl.savedsearch.v1
    baselines?: any; // 4S key: mpl.baselines.v1
    settings?: Record<string, any>; // selected mpl.* keys
  };
};

const KEYS = {
  ann: 'mpl.annots.v1',
  saved: 'mpl.savedsearch.v1',
  bases: 'mpl.baselines.v1',
};

export function captureLocal(keys = ['mpl.theme','mpl.presentation','mpl.search.recents']): Record<string,any>{ const out:Record<string,any>={}; for (const k of keys){ try{ const v=localStorage.getItem(k); if (v) out[k]=JSON.parse(v); }catch{} } return out; }

export function makePack(args:{ history: ExecutionSnapshot[]; mode: 'current'|'tail'; count?: number; title?: string; note?: string }): SharePack {
  const now = new Date().toISOString();
  const h = args.history; const tail = Math.max(0, (args.count ?? 200));
  const scene = (args.mode==='current')
    ? { tick: h.length-1, snapshot: h[h.length-1] }
    : { range: { from: Math.max(0, h.length-tail), to: h.length-1 }, history: h.slice(-tail) };
  const local = {
    annotations: tryParse(localStorage.getItem(KEYS.ann)),
    savedSearches: tryParse(localStorage.getItem(KEYS.saved)),
    baselines: tryParse(localStorage.getItem(KEYS.bases)),
    settings: captureLocal(),
  };
  return { version:'mpack-1', createdAt: now, meta: { title: args.title, note: args.note }, scene, local };
}

export async function packToBlob(pack: SharePack): Promise<Blob>{
  const json = JSON.stringify(pack, null, 2);
  if ((window as any).CompressionStream){
    const rs = new ReadableStream({ start(ctrl){ ctrl.enqueue(new TextEncoder().encode(json)); ctrl.close(); } });
    const gz = rs.pipeThrough(new (window as any).CompressionStream('gzip'));
    const blob = await new Response(gz).blob();
    return new Blob([blob], { type: 'application/gzip' });
  }
  return new Blob([json], { type:'application/json' });
}

export async function importPack(blob: Blob): Promise<SharePack>{
  let text: string;
  if ((window as any).DecompressionStream && blob.type.includes('gzip')){
    const ds = (blob.stream() as any).pipeThrough(new (window as any).DecompressionStream('gzip'));
    text = await new Response(ds).text();
  } else { text = await blob.text(); }
  const pack = JSON.parse(text);
  return pack;
}

export function applyPack(pack: SharePack){
  const l = pack.local || {};
  if (l.annotations) localStorage.setItem(KEYS.ann, JSON.stringify(l.annotations));
  if (l.savedSearches) localStorage.setItem(KEYS.saved, JSON.stringify(l.savedSearches));
  if (l.baselines) localStorage.setItem(KEYS.bases, JSON.stringify(l.baselines));
  if (l.settings){ for (const k in l.settings){ try{ localStorage.setItem(k, JSON.stringify(l.settings[k])); }catch{} } }
}

function tryParse(s:string|null){ try{ return s? JSON.parse(s) : undefined; }catch{ return undefined; } }
```

---

## 4) `playground/components/ExportPanel.tsx` — UI for PNG/SVG/PDF

```tsx
// playground/components/ExportPanel.tsx — Stage 4T
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { exportPNG, exportSVG } from '../../engine/renderer/export';
import { exportPDF } from '../../engine/renderer/exportPdf';

export const ExportPanel: React.FC<{ history: ExecutionSnapshot[]; tick: number }>
= ({ history, tick }) => {
  const [w, setW] = React.useState(1280); const [h, setH] = React.useState(720); const [scale, setScale] = React.useState(1);
  const [bg, setBg] = React.useState<'transparent'|string>('transparent');
  const [labels, setLabels] = React.useState(false); const [grid, setGrid] = React.useState(false);
  const [wm, setWm] = React.useState('');
  const slim = React.useMemo(()=> toSlim(history[Math.max(0, Math.min(tick, history.length-1))] as any), [history, tick]);

  async function saveBlob(blob: Blob, filename: string){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1000); }

  async function doPNG(){ const b = await exportPNG(slim as any, { width:w, height:h, scale, background:bg, showLabels:labels, showGrid:grid, watermark: wm||null }); await saveBlob(b, fileName('png')); }
  async function doSVG(){ const svg = exportSVG(slim as any, { width:w, height:h, scale, background:bg, showLabels:labels, showGrid:grid, watermark: null }); const b = new Blob([svg], { type:'image/svg+xml' }); await saveBlob(b, fileName('svg')); }
  async function doPDF(){ await exportPDF(slim as any, { width:w, height:h, title:'MPL Scene', footer: wm ? `© ${wm}` : undefined }); }

  function fileName(ext:string){ const ts=new Date().toISOString().replace(/[:T]/g,'-').slice(0,19); return `scene-${ts}.${ext}`; }

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Export</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <label>Size <input type="number" value={w} onChange={e=>setW(+e.target.value)} style={{ width:90 }} />×<input type="number" value={h} onChange={e=>setH(+e.target.value)} style={{ width:90 }} /></label>
          <label>Scale <select value={scale} onChange={e=>setScale(+e.target.value)}><option value={1}>1×</option><option value={2}>2×</option><option value={3}>3×</option><option value={4}>4×</option></select></label>
          <label>Background <select value={bg} onChange={e=>setBg(e.target.value as any)}><option value="transparent">Transparent</option><option value="#ffffff">White</option><option value="#0b1020">Deep</option><option value="#f8fafc">Paper</option></select></label>
        </div>
        <div className="mpl-row">
          <label><input type="checkbox" checked={grid} onChange={e=>setGrid(e.target.checked)} /> Grid</label>
          <label><input type="checkbox" checked={labels} onChange={e=>setLabels(e.target.checked)} /> Labels</label>
          <input placeholder="Watermark (optional)" value={wm} onChange={e=>setWm(e.target.value)} />
        </div>
        <div className="mpl-row">
          <button className="mpl-btn" onClick={doPNG}>Export PNG</button>
          <button className="mpl-btn" onClick={doSVG}>Export SVG</button>
          <button className="mpl-btn" onClick={doPDF}>Export PDF</button>
        </div>
        <div className="mpl-dim">Tip: use 2× or 4× scale for retina‑sharp PNGs.</div>
      </div>
    </div>
  );
};
```

---

## 5) `playground/components/PackPanel.tsx` — create/import Share Packs

```tsx
// playground/components/PackPanel.tsx — Stage 4T
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { makePack, packToBlob, importPack, applyPack } from '../../engine/share/pack';

export const PackPanel: React.FC<{ history: ExecutionSnapshot[] }>
= ({ history }) => {
  const [mode, setMode] = React.useState<'current'|'tail'>('current');
  const [count, setCount] = React.useState(200);
  const [title, setTitle] = React.useState('MPL Share Pack');
  const [note, setNote] = React.useState('');

  async function doExport(){ const pack = makePack({ history, mode, count, title, note }); const blob = await packToBlob(pack); const ext = blob.type.includes('gzip')? 'mpack.gz':'json'; const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`mpl-${Date.now()}.${ext}`; a.click(); URL.revokeObjectURL(a.href); }
  async function doImport(){ const i=document.createElement('input'); i.type='file'; i.accept='.json,.gz,.mpack,.mpack.gz,application/gzip,application/json'; i.onchange=async()=>{ const f=i.files?.[0]; if(!f) return; const pack = await importPack(f); applyPack(pack); alert('Pack imported. Reload to apply all settings.'); }; i.click(); }

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Share Pack</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <label>Mode <select value={mode} onChange={e=>setMode(e.target.value as any)}><option value="current">Current snapshot</option><option value="tail">Tail window</option></select></label>
          {mode==='tail' && <label>Count <input type="number" min={10} max={5000} value={count} onChange={e=>setCount(+e.target.value)} style={{ width:100 }} /></label>}
        </div>
        <input placeholder="Title" value={title} onChange={e=>setTitle(e.target.value)} />
        <textarea placeholder="Note (optional)" rows={2} value={note} onChange={e=>setNote(e.target.value)} />
        <div className="mpl-row">
          <button className="mpl-btn" onClick={doExport}>Export Pack</button>
          <button className="mpl-btn" onClick={doImport}>Import Pack</button>
        </div>
        <div className="mpl-dim">Packs include annotations, saved searches, baselines, and select settings. Tail mode captures the last N frames.</div>
      </div>
    </div>
  );
};
```

---

## 6) `playground/components/CanvasPanel.tsx` — wire Export + Pack

```tsx
// CanvasPanel.tsx — 4T wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { ExportPanel } from './ExportPanel';
import { PackPanel } from './PackPanel';

export const CanvasPanel: React.FC<{ history: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= ({ history, index, onIndex }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(history[Math.max(0, Math.min(index, history.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, history]);
  const canvasRef = React.useRef<any>(null);

  return (
    <div className="mpl-grid">
      <div className="mpl-main">
        <GraphCanvas ref={canvasRef} snapshot={slim} />
      </div>
      <aside className="mpl-side">
        <ExportPanel history={history} tick={index} />
        <PackPanel history={history} />
      </aside>
    </div>
  );
};
```

---

## 7) Styles — `playground/styles/debugger.css` (additions)

```css
/* Stage 4T — export & pack */
.mpl-card .mpl-row code { background:#f1f5f9; padding:2px 6px; border-radius:6px; }
```

---

## 8) Example — `playground/pages/DebugExample4T.tsx`

```tsx
// playground/pages/DebugExample4T.tsx
import React, { useMemo } from 'react';
import { DebuggerPanel } from '../components/DebuggerPanel';
import { ExecutionSnapshot } from '../../engine/debugger/graphTypes';

function makeHistory(): ExecutionSnapshot[]{
  const ids = Array.from({length:160}, (_,i)=>`N${i}`);
  const monads = ids.map((id,i)=>({ id, neighbors: [] as string[], x: Math.cos(i*.25)*220 + (Math.random()-0.5)*12, y: Math.sin(i*.25)*220 + (Math.random()-0.5)*12 }));
  for (let i=0;i<ids.length;i++) for (let j=i+1;j<ids.length;j++) if (Math.random()<0.025){ monads[i].neighbors.push(ids[j]); monads[j].neighbors.push(ids[i]); }
  return [{ tick:0, monads, rulesFired:['Seed','Bridge'] } as any];
}

export default function DebugExample4T(){
  const history = useMemo(makeHistory, []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4T — Scene Export (PNG/SVG/PDF) + Share Packs</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Export the scene in multiple formats, or bundle everything into a portable Share Pack.</p>
    </div>
  );
}
```

---

## 9) Notes

* **PDF** uses the browser print pipeline in a new tab; users can select printer or “Save as PDF”. If you prefer a Blob, swap in a minimal PDF writer later.
* **SVG** export reconstructs nodes/edges/labels in vector space. If your live renderer supports curved edges, you can extend the generator to use paths.
* **Annotations**: If you want annotations in PNG/SVG, project them by reusing the screen‑space math from 4N’s `AnnotLayer` using the same `fit()` transform.
* **Clipboard**: Optionally add “Copy PNG/SVG” by using `ClipboardItem` when available.
* **Packs**: When importing, we restore local storage keys; some UIs may require a refresh to pick them up.

---

## 10) Changelog — Stage 4T

* New: `engine/renderer/export.ts` (PNG/SVG), `engine/renderer/exportPdf.ts` (print helper)
* New: `engine/share/pack.ts` (make/apply/import/export .mpack)
* New UI: `ExportPanel.tsx`, `PackPanel.tsx`
* Updated: `CanvasPanel.tsx` (wire panels)
* Styles: small additions

```
```
