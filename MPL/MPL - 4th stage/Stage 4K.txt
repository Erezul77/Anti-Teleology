# MPL Playground — Stage 4K Patch (Timeline Heat Overlays + Bookmarkable Views + Share Links)

This patch adds **timeline heat overlays**, **bookmarkable views** with thumbnails, and **share links** that encode the current view into the URL. Built on 4C–4J (canvas, worker, LOD, inspector, mini‑map, capture, rules).

No external deps.

---

## Highlights

* **Heat lanes** over the scrubber: per‑tick activity (rule count) + optional diff lane (adds/removes/moves) for quick scanning
* **Bookmarks**: one‑click save of camera, tick, rule filter, bundling & cluster toggles; persistent in `localStorage` with tiny thumbnail
* **Share links**: URL hash encodes the current view (base64url) → **copy/paste** or use **Web Share API** when available
* **Deep‑link restore** on load: parse `#v=...` and rehydrate the view automatically

---

## 1) `engine/ui/viewState.ts` (new) — view state, encode/decode

```ts
// engine/ui/viewState.ts
export type ViewState = {
  t: number;                        // tick index
  cam: { x:number; y:number; z:number };
  rule?: { id: string; lastN: number; mode: 'fade'|'isolate' } | null;
  bundling?: { on: boolean; strength: number };
  cluster?: { colorBy: boolean; hulls: boolean };
  layout?: { useWorker: boolean; mode: 'grid'|'barnes'|'naive' };
};

export function minimize(v: Partial<ViewState>): ViewState {
  return {
    t: v.t ?? 0,
    cam: v.cam ?? { x:0, y:0, z:1 },
    rule: v.rule ?? null,
    bundling: v.bundling ?? { on: true, strength: 0.6 },
    cluster: v.cluster ?? { colorBy: true, hulls: false },
    layout: v.layout ?? { useWorker: true, mode: 'barnes' },
  };
}

// base64url helpers (no compression for simplicity; payloads are small)
export function encodeView(v: ViewState): string {
  const j = JSON.stringify(v);
  const b64 = btoa(unescape(encodeURIComponent(j)));
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}

export function decodeView(s: string): ViewState | null {
  try {
    const b64 = s.replace(/-/g,'+').replace(/_/g,'/');
    const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
    const txt = decodeURIComponent(escape(atob(b64 + pad)));
    return minimize(JSON.parse(txt));
  } catch { return null; }
}

export function makeShareURL(v: ViewState): string {
  const base = location.origin + location.pathname;
  return `${base}#v=${encodeView(v)}`;
}
```

---

## 2) `playground/components/TimelineHeat.tsx` (new) — heat overlays for the scrubber

```tsx
// playground/components/TimelineHeat.tsx
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';

export const TimelineHeat: React.FC<{ history: ExecutionSnapshot[]; width?: number; height?: number }>
= ({ history, width=780, height=24 }) => {
  const ref = React.useRef<HTMLCanvasElement>(null);
  React.useEffect(() => { draw(); }, [history]);

  function draw(){ const c = ref.current!; if (!c) return; const ctx = c.getContext('2d')!; c.width=width; c.height=height; ctx.clearRect(0,0,width,height);
    const n = Math.max(1, history.length);
    // lane 1: rules fired count per tick
    const counts = history.map(h => (h.rulesFired||[]).length);
    const maxC = Math.max(1, ...counts);
    for (let i=0;i<n;i++){ const x = Math.floor(i*width/n); const w = Math.ceil(width/n); const v = counts[i]/maxC; ctx.fillStyle = `rgba(99,102,241,${0.15 + 0.75*v})`; ctx.fillRect(x, 0, w, height/2 - 1); }
    // lane 2: node churn (approx): |Δnodes|
    let prev = history[0]; const churn:number[] = [0];
    for (let i=1;i<n;i++){ const a = new Set((prev?.monads||[] as any[]).map((m:any)=>m.id)); const b = new Set((history[i]?.monads||[] as any[]).map((m:any)=>m.id)); let d=0; for (const id of a){ if (!b.has(id)) d++; } for (const id of b){ if (!a.has(id)) d++; } churn.push(d); prev = history[i]; }
    const maxD = Math.max(1, ...churn);
    for (let i=0;i<n;i++){ const x = Math.floor(i*width/n); const w = Math.ceil(width/n); const v = churn[i]/maxD; ctx.fillStyle = `rgba(16,185,129,${0.12 + 0.78*v})`; ctx.fillRect(x, height/2 + 1, w, height/2 - 1); }
  }

  return (
    <div className="mpl-heat">
      <canvas ref={ref} width={width} height={height} />
      <div className="mpl-heat-legend">
        <span className="mpl-chip" style={{ background:'#c7d2fe' }}>Rules</span>
        <span className="mpl-chip" style={{ background:'#bbf7d0' }}>Node churn</span>
      </div>
    </div>
  );
};
```

---

## 3) `playground/components/BookmarkPanel.tsx` (new) — save/list/apply bookmarks

```tsx
// playground/components/BookmarkPanel.tsx
import React from 'react';
import { ViewState, minimize, makeShareURL } from '../../engine/ui/viewState';

export type Bookmark = ViewState & { id: string; name: string; thumb?: string; createdAt: string };

const KEY = 'mpl.bookmarks.v1';

export const BookmarkPanel: React.FC<{
  takeThumb?: () => string | null;               // returns dataURL
  current: ViewState;                             // current view
  onApply: (v: ViewState) => void;                // apply bookmark
}>
= ({ takeThumb, current, onApply }) => {
  const [items, setItems] = React.useState<Bookmark[]>(() => load());
  const [name, setName] = React.useState('');

  function load(): Bookmark[]{ try{ const raw = localStorage.getItem(KEY); return raw? JSON.parse(raw) : []; } catch { return []; } }
  function save(list: Bookmark[]){ try { localStorage.setItem(KEY, JSON.stringify(list)); } catch {}
  }

  function add(){ const v = minimize(current); const id = Math.random().toString(36).slice(2,8); const bm: Bookmark = { ...v, id, name: name||`View ${new Date().toLocaleString()}`, thumb: takeThumb?.() || undefined, createdAt: new Date().toISOString() }; const list=[bm, ...items]; setItems(list); save(list); setName(''); }
  function del(id:string){ const list = items.filter(b=>b.id!==id); setItems(list); save(list); }

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Bookmarks</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:10 }}>
        <div className="mpl-row">
          <input placeholder="name…" value={name} onChange={e=>setName(e.target.value)} style={{ flex:1, padding:6, border:'1px solid #e5e7eb', borderRadius:8 }} />
          <button className="mpl-btn" onClick={add}>Save</button>
        </div>
        <div className="mpl-bmlist">
          {items.map(b => (
            <div key={b.id} className="mpl-bm">
              {b.thumb ? <img alt="thumb" src={b.thumb} /> : <div className="mpl-bm-ph" />}
              <div className="mpl-bm-meta">
                <div className="mpl-bm-title">{b.name}</div>
                <div className="mpl-dim">{new Date(b.createdAt).toLocaleString()}</div>
                <div className="mpl-row">
                  <button className="mpl-btn" onClick={()=>onApply(b)}>Apply</button>
                  <button className="mpl-btn" onClick={()=>navigator.clipboard.writeText(makeShareURL(b))}>Copy Link</button>
                  {'share' in navigator ? <button className="mpl-btn" onClick={()=> (navigator as any).share({ url: makeShareURL(b), title: b.name })}>Share…</button> : null}
                  <button className="mpl-btn" onClick={()=>del(b.id)}>Delete</button>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

---

## 4) `playground/components/CanvasPanel.tsx` (update) — wire heat, bookmarks, share‑link restore

```tsx
// CanvasPanel.tsx — 4K wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { TimelineHeat } from './TimelineHeat';
import { BookmarkPanel } from './BookmarkPanel';
import { ViewState, minimize, decodeView, makeShareURL } from '../../engine/ui/viewState';
import { RulePanel } from './RulePanel';

export const CanvasPanel: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= ({ timeline, index, onIndex }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(timeline[Math.max(0, Math.min(index, timeline.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, timeline]);

  // view pieces
  const [camera, setCamera]   = React.useState<{x:number;y:number;z:number}>({ x:0,y:0,z:1 });
  const [ruleOverlay, setRuleOverlay] = React.useState<any|null>(null);
  const [bundle, setBundle]   = React.useState({ on: true, strength: 0.6 }); // from 4F
  const [cluster, setCluster] = React.useState({ colorBy: true, hulls: false });
  const [layout, setLayout]   = React.useState({ useWorker: true, mode: 'barnes' as 'barnes'|'grid'|'naive' });

  const canvasRef = React.useRef<any>(null);

  // expose overlay to canvas
  React.useEffect(() => { const g = (canvasRef.current as any)?._graph; if (!g) return; g.setRuleOverlay(ruleOverlay); g.draw(); }, [ruleOverlay, slim.tick]);

  // deep-link restore on mount (and on hashchange)
  React.useEffect(() => {
    function apply(v: ViewState){
      onIndex?.(v.t); setCamera(v.cam); if (v.rule){ const { id,lastN,mode }=v.rule; // delegate to RulePanel-like maker if you have one
        // Lightweight inline overlay (nodes-only) until rules panel recomputes
        setRuleOverlay({ rule:id, color:'#6366f1', nodes:new Set<string>(), edges:new Set<string>(), fadeOthers: mode==='fade', isolate: mode==='isolate' });
      } else { setRuleOverlay(null); }
      if (v.bundling) setBundle(v.bundling);
      if (v.cluster) setCluster(v.cluster as any);
      if (v.layout) setLayout(v.layout as any);
    }
    const parse = () => { const hash = location.hash; const m = /#v=([^&]+)/.exec(hash); if (!m) return; const v = decodeView(m[1]); if (v) apply(v); };
    parse(); window.addEventListener('hashchange', parse); return () => window.removeEventListener('hashchange', parse);
  }, []);

  // take a bookmark thumbnail from the live canvas
  function takeThumb(){ const el = (canvasRef.current as any)?.querySelector?.('canvas') || (canvasRef.current as any); const c = el as HTMLCanvasElement|undefined; if (!c) return null; try{ return c.toDataURL('image/png'); } catch { return null; } }

  // current view snapshot for bookmark/share
  const currentView: ViewState = React.useMemo(() => minimize({ t:index, cam:camera, rule: ruleOverlay? { id: ruleOverlay.rule, lastN: 6, mode: ruleOverlay.isolate? 'isolate':'fade' } : null, bundling: bundle, cluster, layout }), [index, camera.x, camera.y, camera.z, !!ruleOverlay, bundle.on, bundle.strength, cluster.colorBy, cluster.hulls, layout.useWorker, layout.mode]);

  return (
    <div className="mpl-grid">
      <div className="mpl-main">
        {/* Top: timeline heat above the scrubber */}
        <TimelineHeat history={timeline} />
        {/* (your existing PlayheadScrubber row lives here) */}
        <GraphCanvas ref={canvasRef} snapshot={slim} camera={camera} onCamera={setCamera} /* plus your existing props… */ />
        <div className="mpl-row">
          <BookmarkPanel current={currentView} takeThumb={takeThumb} onApply={(v)=>{
            // set URL and apply
            const url = makeShareURL(v); history.pushState(null,'',url); // shallow
            onIndex?.(v.t); setCamera(v.cam); if (v.rule) setRuleOverlay({ rule:v.rule.id, color:'#6366f1', nodes:new Set(), edges:new Set(), fadeOthers:v.rule.mode==='fade', isolate:v.rule.mode==='isolate' }); else setRuleOverlay(null);
            if (v.bundling) setBundle(v.bundling); if (v.cluster) setCluster(v.cluster as any); if (v.layout) setLayout(v.layout as any);
          }} />
          <RulePanel history={timeline} tick={index} onOverlay={setRuleOverlay} />
        </div>
      </div>
      <aside className="mpl-side">
        <div className="mpl-card"><div className="mpl-card-h">Share</div><div className="mpl-card-b">
          <div className="mpl-row">
            <button className="mpl-btn" onClick={()=>navigator.clipboard.writeText(makeShareURL(currentView))}>Copy View Link</button>
            {'share' in navigator ? <button className="mpl-btn" onClick={()=> (navigator as any).share({ url: makeShareURL(currentView), title: 'MPL View' })}>Share…</button> : null}
          </div>
          <div className="mpl-dim" style={{ marginTop: 6 }}>Links encode tick, camera, and rule/bundle/cluster/layout toggles in the URL hash.</div>
        </div></aside>
    </div>
  );
};
```

---

## 5) `playground/styles/debugger.css` (additions)

```css
/* Stage 4K — heat lanes + bookmarks */
.mpl-heat { display: grid; gap: 6px; align-items: start; }
.mpl-heat canvas { width: 100%; height: 24px; border-radius: 6px; background: #fff; border: 1px solid #e5e7eb; }
.mpl-heat-legend { display: flex; gap: 8px; font-size: 12px; color: #6b7280; }

.mpl-bmlist { display: grid; gap: 10px; }
.mpl-bm { display: grid; grid-template-columns: 120px 1fr; gap: 10px; align-items: center; border: 1px solid #eef2f7; border-radius: 10px; padding: 8px; background: #fff; }
.mpl-bm img { width: 120px; height: 80px; object-fit: cover; border-radius: 8px; border: 1px solid #e5e7eb; }
.mpl-bm-ph { width: 120px; height: 80px; border-radius: 8px; background: repeating-linear-gradient(45deg,#f3f4f6,#f3f4f6 6px,#e5e7eb 6px,#e5e7eb 12px); }
.mpl-bm-meta { display: grid; gap: 6px; }
.mpl-bm-title { font-weight: 600; }
```

---

## 6) `playground/pages/DebugExample4K.tsx`

```tsx
// playground/pages/DebugExample4K.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

function makeHistory(): ExecutionSnapshot[] {
  const ticks: ExecutionSnapshot[] = [];
  const ids = Array.from({length: 40}, (_,i)=>`N${i}`);
  function snap(t:number){
    const monads = ids.map((id,i)=>({ id, neighbors: [] as string[], x: Math.cos((i+t)*.2)*200 + (Math.random()-0.5)*6, y: Math.sin((i-t)*.2)*200 + (Math.random()-0.5)*6 }));
    // random edges
    for (let i=0;i<ids.length;i++) for (let j=i+1;j<ids.length;j++) if (Math.random()<0.06) { monads[i].neighbors.push(ids[j]); monads[j].neighbors.push(ids[i]); }
    const rules = Array.from({length: (Math.random()*4)|0}, (_,k)=> k%2? 'Bridge' : 'PromotePath');
    return { tick: t, monads, rulesFired: rules } as any;
  }
  for (let t=0;t<20;t++) ticks.push(snap(t));
  return ticks;
}

export default function DebugExample4K(){
  const history = useMemo(makeHistory, []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4K — Timeline Heat Overlays + Bookmarkable Views + Share Links</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Heat lanes show rule activity & node churn. Create a bookmark, then copy/share a link to this exact view.</p>
    </div>
  );
}
```

---

## 7) Notes

* **URL size**: The encoded view contains only lightweight fields (tick/camera/toggles). For very long rule IDs, consider mapping to stable short IDs when encoding.
* **Privacy**: URLs include state only — not data. They expect the same dataset/timeline to be present on the receiver.
* **Thumbnails**: Captured from the on‑screen canvas. For headless captures, use the 4I `CapturePanel` instead.
* **Extensibility**: Add more fields to `ViewState` as you expose additional toggles.

---

## 8) Changelog — Stage 4K

* New: `engine/ui/viewState.ts` (encode/decode + share URL)
* New UI: `TimelineHeat.tsx` (heat lanes), `BookmarkPanel.tsx` (save/list/apply)
* Updated: `CanvasPanel.tsx` (heat + bookmarks + deep‑link handling)
* Styles: heat lane & bookmark polish

```
```
