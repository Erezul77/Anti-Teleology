# MPL Playground — Stage 4P Patch (Saved Searches + Live Filters + Alerts)

This patch builds on **4O (Global Search)** by adding:

* **Saved Searches**: name, color, scope, mode (fade/isolate), persisted, shareable via URL hash
* **Live Filters**: auto‑re‑run a saved search each tick and update the canvas overlay
* **Alerts**: thresholds & comparators on match counts; tray toasts + optional Web Notifications

No new deps. State lives in `localStorage`.

---

## Highlights

* Save current query from Search panel with one click
* Apply a saved search → instantly sets query + overlay
* Live mode binds to the playback head (or streaming updates) and refreshes highlight
* Alerts can target **nodes/edges/rules** counts with `>=`, `<=`, `>`, `<`, `=`; cooldown prevents spam
* URL share: `#s=<base64url>` encodes a single saved search (import on open)

---

## 1) `engine/search/saved.ts` (new) — model + storage + share encoding

```ts
// engine/search/saved.ts — Stage 4P
export type Scope = { nodes:boolean; edges:boolean; rules:boolean };
export type Mode = 'fade'|'isolate';

export interface SavedSearch {
  id: string;
  name: string;
  q: string;
  scope: Scope;
  mode: Mode;
  color: string;        // overlay tint
  live?: boolean;       // auto update each tick
  alert?: {
    field: 'nodes'|'edges'|'rules';
    op: '>='|'>'|'='|'<'|'<=';
    value: number;
    cooldownMs?: number; // suppress repeated alerts within window
  } | null;
  createdAt: string;
  updatedAt: string;
}

const KEY = 'mpl.savedsearch.v1';

export function loadSaved(): SavedSearch[]{ try{ const raw=localStorage.getItem(KEY); return raw? JSON.parse(raw) : []; }catch{ return []; } }
export function saveSaved(list: SavedSearch[]){ try{ localStorage.setItem(KEY, JSON.stringify(list)); }catch{} }

export function upsertSearch(s: SavedSearch){ const list = loadSaved(); const i=list.findIndex(x=>x.id===s.id); if(i>=0) list[i]=s; else list.unshift(s); saveSaved(list); return list; }
export function removeSearch(id: string){ const list = loadSaved().filter(x=>x.id!==id); saveSaved(list); return list; }

export function createSaved(partial: Partial<SavedSearch>): SavedSearch {
  const now = new Date().toISOString();
  return {
    id: Math.random().toString(36).slice(2, 8),
    name: partial.name || 'Untitled',
    q: partial.q || '',
    scope: partial.scope || { nodes:true, edges:true, rules:false },
    mode: partial.mode || 'fade',
    color: partial.color || colorFromName(partial.name||partial.q||'search'),
    live: !!partial.live,
    alert: partial.alert ?? null,
    createdAt: now,
    updatedAt: now,
  };
}

export function touch(s: SavedSearch){ s.updatedAt = new Date().toISOString(); return s; }

export function colorFromName(name: string){ let h=2166136261>>>0; for (let i=0;i<name.length;i++){ h^=name.charCodeAt(i); h=Math.imul(h,16777619);} const hue=h%360; return `hsl(${hue} 70% 45%)`; }

// share encoding for a single saved search
export function encodeSaved(s: SavedSearch){ const j=JSON.stringify(s); const b=btoa(unescape(encodeURIComponent(j))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); return b; }
export function decodeSaved(str: string): SavedSearch|null { try{ const b=str.replace(/-/g,'+').replace(/_/g,'/'); const pad=b.length%4? '='.repeat(4-(b.length%4)) : ''; const j=decodeURIComponent(escape(atob(b+pad))); const s=JSON.parse(j); return s; }catch{ return null; } }
```

---

## 2) `engine/search/watch.ts` (new) — evaluate saved searches + alerts per tick

```ts
// engine/search/watch.ts — Stage 4P
import type { SnapshotSlim } from '../core/perf/timelineDelta';
import { buildSearchView, search } from './index';
import type { SavedSearch } from './saved';

export type WatchEval = { count: {nodes:number; edges:number; rules:number}; fired: boolean };

export function evalSaved(slim: SnapshotSlim, saved: SavedSearch, last?: number): WatchEval {
  const view = buildSearchView(slim); const res = search(slim as any, view, saved.q, saved.scope);
  const cnt = saved.alert?.field ? (res.count as any)[saved.alert.field] : (res.count.nodes + res.count.edges + res.count.rules);
  const fired = saved.alert ? compare(cnt, saved.alert.op, saved.alert.value) && (last===undefined || cnt!==last) : false; // rising edge by change
  return { count: res.count, fired };
}

function compare(v:number, op:string, t:number){ if(op==='>=')return v>=t; if(op==='>')return v>t; if(op==='<=')return v<=t; if(op==="<")return v<t; return v===t; }
```

---

## 3) `playground/components/SavedSearchPanel.tsx` (new) — save/apply/manage

```tsx
// playground/components/SavedSearchPanel.tsx — Stage 4P
import React from 'react';
import type { Scope, Mode, SavedSearch } from '../../engine/search/saved';
import { loadSaved, createSaved, upsertSearch, removeSearch, touch, encodeSaved } from '../../engine/search/saved';

export const SavedSearchPanel: React.FC<{
  current: { q: string; scope: Scope; mode: Mode };
  onApply: (s: SavedSearch) => void;
}>
= ({ current, onApply }) => {
  const [items, setItems] = React.useState<SavedSearch[]>(loadSaved());
  const [name, setName] = React.useState('');

  function save(){ const s = createSaved({ name, q: current.q, scope: current.scope, mode: current.mode }); setItems(upsertSearch(s)); setName(''); }
  function del(id:string){ setItems(removeSearch(id)); }
  function toggleLive(id:string){ setItems(prev => { const list = prev.map(s => s.id===id ? touch({ ...s, live: !s.live }) : s); list.forEach(upsertSearch); return [...list]; }); }

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Saved Searches</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        <div className="mpl-row">
          <input placeholder="name…" value={name} onChange={e=>setName(e.target.value)} style={{ flex:1, padding:6, border:'1px solid var(--mpl-border)', borderRadius:8 }} />
          <button className="mpl-btn" onClick={save} disabled={!current.q.trim()}>Save current</button>
        </div>
        <div className="mpl-list-b">
          {items.map(s => (
            <div key={s.id} className="mpl-saved">
              <span className="mpl-dot" style={{ background:s.color }} />
              <strong>{s.name}</strong>
              <code className="mpl-dim" title={s.q} style={{ overflow:'hidden', textOverflow:'ellipsis' }}>{s.q}</code>
              <div className="mpl-row" style={{ marginLeft:'auto' }}>
                <label style={{ display:'inline-flex', alignItems:'center', gap:6 }}>
                  <input type="checkbox" checked={!!s.live} onChange={()=>toggleLive(s.id)} /> Live
                </label>
                <button className="mpl-btn" onClick={()=>onApply(s)}>Apply</button>
                <button className="mpl-btn" onClick={()=>navigator.clipboard.writeText(location.origin+location.pathname+'#s='+encodeSaved(s))}>Share</button>
                <button className="mpl-btn" onClick={()=>del(s.id)}>Delete</button>
              </div>
            </div>
          ))}
        </div>
        <div className="mpl-dim">Tip: Toggle <em>Live</em> to follow the timeline and auto‑refresh highlights.</div>
      </div>
    </div>
  );
};
```

---

## 4) `playground/components/AlertTray.tsx` (new) — in‑app toasts + log

```tsx
// playground/components/AlertTray.tsx — Stage 4P
import React from 'react';

export type AlertItem = { id:string; title:string; body:string; ts:number; color:string };

export const AlertTray: React.FC<{ feed: AlertItem[]; onClear: ()=>void }>
= ({ feed, onClear }) => {
  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Alerts</div>
      <div className="mpl-card-b" style={{ display:'grid', gap:8 }}>
        {!feed.length && <div className="mpl-dim">No alerts yet.</div>}
        {!!feed.length && <button className="mpl-btn" onClick={onClear}>Clear</button>}
        <div className="mpl-alerts">
          {feed.map(a => (
            <div key={a.id} className="mpl-alert" style={{ borderLeftColor:a.color }}>
              <div className="mpl-alert-title">{a.title}</div>
              <div className="mpl-alert-body">{a.body}</div>
              <div className="mpl-dim">{new Date(a.ts).toLocaleTimeString()}</div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export function toast(title:string, body:string, color:string){ try{ if('Notification' in window && Notification.permission==='granted'){ new Notification(title, { body }); } else if('Notification' in window && Notification.permission!=='denied'){ Notification.requestPermission?.(); } }catch{} }
```

---

## 5) `playground/components/SearchPanel.tsx` (update) — expose current and accept apply

```tsx
// SearchPanel.tsx — 4P: prop plumbing to coordinate with SavedSearchPanel
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { buildSearchView, search } from '../../engine/search/index';

export const SearchPanel: React.FC<{
  history: ExecutionSnapshot[];
  tick: number;
  onOverlay: (h:any|null)=>void;
  onSelect: (ids:string[])=>void;
  onZoom: (ids:string[])=>void;
  currentOut?: (cur: { q:string; scope:{nodes:boolean;edges:boolean;rules:boolean}; mode:'fade'|'isolate' })=>void;
  applyExternal?: { q:string; scope:{nodes:boolean;edges:boolean;rules:boolean}; mode:'fade'|'isolate' } | null;
}>
= ({ history, tick, onOverlay, onSelect, onZoom, currentOut, applyExternal=null }) => {
  const [q, setQ] = React.useState('');
  const [nodes, setNodes] = React.useState(true);
  const [edges, setEdges] = React.useState(true);
  const [rules, setRules] = React.useState(false);
  const [mode, setMode] = React.useState<'fade'|'isolate'>('fade');

  React.useEffect(()=>{ if (applyExternal){ setQ(applyExternal.q); setNodes(applyExternal.scope.nodes); setEdges(applyExternal.scope.edges); setRules(applyExternal.scope.rules); setMode(applyExternal.mode); } }, [applyExternal?.q]);
  React.useEffect(()=>{ currentOut?.({ q, scope:{nodes,edges,rules}, mode }); }, [q, nodes, edges, rules, mode]);

  const slim = React.useMemo(()=>toSlim(history[Math.max(0, Math.min(tick, history.length-1))] as any), [tick, history]);
  const view = React.useMemo(()=>buildSearchView(slim as any), [slim.tick]);
  const res = React.useMemo(()=>search(slim as any, view, q, { nodes, edges, rules }), [q, nodes, edges, rules, view, slim.tick]);
  React.useEffect(()=>{ if (!q){ onOverlay(null); return; } onOverlay({ nodes:res.nodes, edges:res.edges, color:'#22c55e', fadeOthers: mode==='fade', isolate: mode==='isolate' }); }, [q, res.count.nodes, res.count.edges, mode]);

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Search</div>
      <div className="mpl-card-b">{/* unchanged UI from 4O, omitted here for brevity */}</div>
    </div>
  );
};
```

---

## 6) `playground/components/CanvasPanel.tsx` (update) — wire live filters + alerts

```tsx
// CanvasPanel.tsx — Stage 4P wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { SearchPanel } from './SearchPanel';
import { SavedSearchPanel } from './SavedSearchPanel';
import { evalSaved } from '../../engine/search/watch';
import { loadSaved, upsertSearch, decodeSaved } from '../../engine/search/saved';
import { AlertTray, toast, AlertItem } from './AlertTray';

export const CanvasPanel: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void }>
= ({ timeline, index, onIndex }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(timeline[Math.max(0, Math.min(index, timeline.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, timeline]);

  // overlay plumbing
  const canvasRef = React.useRef<any>(null);
  function setOverlay(h:any|null){ const g=(canvasRef.current as any)?._graph; if(!g) return; g.setHighlightOverlay(h); g.draw(); }

  // cross‑panel state
  const [curSearch, setCurSearch] = React.useState<{ q:string; scope:{nodes:boolean;edges:boolean;rules:boolean}; mode:'fade'|'isolate' }>({ q:'', scope:{nodes:true,edges:true,rules:false}, mode:'fade' });
  const [applyExternal, setApplyExternal] = React.useState<any>(null);
  const [alerts, setAlerts] = React.useState<AlertItem[]>([]);
  const lastCounts = React.useRef<Record<string, number>>({});
  const cooldownUntil = React.useRef<Record<string, number>>({});

  // deep‑link import for a shared saved search (#s=...)
  React.useEffect(()=>{ const parse=()=>{ const m=/#s=([^&]+)/.exec(location.hash); if(!m) return; const s = decodeSaved(m[1]); if(!s) return; upsertSearch(s); setApplyExternal({ q: s.q, scope:s.scope, mode:s.mode }); location.hash = location.hash.replace(/#s=[^&]+/, ''); }; parse(); window.addEventListener('hashchange',parse); return ()=>window.removeEventListener('hashchange',parse); }, []);

  // live evaluation on tick
  React.useEffect(()=>{
    const list = loadSaved().filter(s=>s.live);
    for (const s of list){
      const { count, fired } = evalSaved(slim as any, s, lastCounts.current[s.id]);
      lastCounts.current[s.id] = (s.alert?.field ? (count as any)[s.alert.field] : (count.nodes+count.edges+count.rules));
      if (s.alert && fired){
        const now = Date.now(); const until = cooldownUntil.current[s.id] || 0; if (now < until) continue;
        const val = lastCounts.current[s.id];
        const title = `Alert: ${s.name}`; const body = `${s.alert.field} ${s.alert.op} ${s.alert.value}  (now ${val})`;
        toast(title, body, s.color);
        setAlerts(a=>[{ id: Math.random().toString(36).slice(2,8), title, body, ts: now, color: s.color }, ...a].slice(0,50));
        cooldownUntil.current[s.id] = now + (s.alert.cooldownMs ?? 10_000);
      }
    }
  }, [slim.tick]);

  // apply from SavedSearchPanel
  function applySaved(s:any){ setApplyExternal({ q: s.q, scope:s.scope, mode:s.mode }); setOverlay({ nodes:new Set(), edges:new Set(), color:s.color, fadeOthers: s.mode==='fade', isolate: s.mode==='isolate' }); }

  return (
    <div className="mpl-grid">
      <div className="mpl-main">
        <GraphCanvas ref={canvasRef} snapshot={slim} />
      </div>
      <aside className="mpl-side">
        <SearchPanel history={timeline} tick={index} onOverlay={setOverlay} onSelect={()=>{}} onZoom={()=>{}} currentOut={setCurSearch} applyExternal={applyExternal} />
        <SavedSearchPanel current={curSearch} onApply={applySaved} />
        <AlertTray feed={alerts} onClear={()=>setAlerts([])} />
      </aside>
    </div>
  );
};
```

---

## 7) Styles — `playground/styles/debugger.css` (additions)

```css
/* Stage 4P — saved searches + alerts */
.mpl-saved { display: grid; grid-template-columns: auto auto 1fr auto; gap: 8px; align-items: center; padding: 6px 0; border-bottom: 1px dashed var(--mpl-border); }
.mpl-dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; }
.mpl-alerts { display: grid; gap: 8px; }
.mpl-alert { border-left: 4px solid #22c55e; background: var(--mpl-surface); border: 1px solid var(--mpl-border); border-left-color: var(--mpl-border); padding: 8px 10px; border-radius: 8px; }
.mpl-alert-title { font-weight: 600; }
.mpl-alert-body { font-size: 12px; }
```

---

## 8) Example — `playground/pages/DebugExample4P.tsx`

```tsx
// playground/pages/DebugExample4P.tsx
import React, { useMemo } from 'react';
import { DebuggerPanel } from '../components/DebuggerPanel';
import { ExecutionSnapshot } from '../../engine/debugger/graphTypes';

function makeHistory(): ExecutionSnapshot[] {
  const ticks: ExecutionSnapshot[] = []; const ids = Array.from({length:200},(_,i)=>`N${i}`);
  for (let t=0;t<30;t++){
    const monads = ids.map((id,i)=>({ id, neighbors: [] as string[], x: Math.cos((i+t)*.15)*240 + (Math.random()-0.5)*8, y: Math.sin((i-t)*.15)*240 + (Math.random()-0.5)*8 }));
    for (let i=0;i<ids.length;i++) for (let j=i+1;j<ids.length;j++) if (Math.random()<0.02){ monads[i].neighbors.push(ids[j]); monads[j].neighbors.push(ids[i]); }
    const rules = Array.from({length: ((Math.sin(t*.4)+1)*2)|0 }, ()=> (['Bridge','PromotePath','Seed','AttachTail'][(Math.random()*4)|0]));
    ticks.push({ tick:t, monads, rulesFired: rules } as any);
  }
  return ticks;
}

export default function DebugExample4P(){
  const history = useMemo(makeHistory, []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4P — Saved Searches + Live Filters + Alerts</h1>
      <DebuggerPanel history={history} />
      <p className="mpl-dim">Save a query (e.g., <code>degree:>=4 rule:Bridge</code>), toggle <strong>Live</strong>, and add an alert like <code>nodes &gt;= 10</code>.</p>
    </div>
  );
}
```

---

## 9) Notes

* **Live sources**: If you stream new snapshots, keep the `slim.tick` effect — it reevaluates on each frame snapshot.
* **Alert semantics**: We fire on threshold comparison and value change (prevents constant retriggering). Adjust to edge‑trigger or hysteresis as needed.
* **Web Notifications**: We request permission lazily on first toast. Consider storing a flag to avoid re‑prompting.
* **Overlay color**: Saved with the search so applied highlight tint is consistent.
* **URL share**: `#s=...` imports a saved search (and persists it) on open. You can also add `q` to the 4K `ViewState` if you want deep‑linking of ad‑hoc queries.

---

## 10) Changelog — Stage 4P

* New: `engine/search/saved.ts` (model/storage/share)
* New: `engine/search/watch.ts` (evaluation + thresholds)
* New UI: `SavedSearchPanel.tsx`, `AlertTray.tsx`
* Updated: `SearchPanel.tsx` (coordination hooks)
* Updated: `CanvasPanel.tsx` (wire live filters + alerts + deep‑link import)
* Styles: saved search list & alerts

```
```
