# MPL Playground — Stage 4B Patch (Force/Sticky Layout + Smooth Tick Interpolation)

This patch adds a lightweight **force‑directed (sticky) layout** and **buttery tick interpolation** on top of the 4A canvas renderer. The result: stable visuals, smooth transitions between timeline ticks, and responsive drag‑to‑pin editing — all with zero new deps.

---

## Highlights

* **Force layout**: repulsion + edge springs + damping; runs incrementally on each frame
* **Sticky physics**: nodes “settle” and keep their positions across ticks; you can pin/unpin by dragging
* **Tick interpolation**: lerp node positions & edge fades between snapshots; configurable duration & easing
* **Playback controls**: play/pause, speed, interpolation duration, and physics strength sliders
* **Scales well** to \~1–2k nodes (O(n²) with soft cutoffs); easy to upgrade to grid/Barnes‑Hut later

---

## 1) `engine/renderer/layout/force.ts` (new)

```ts
// engine/renderer/layout/force.ts
// Stage 4B — Simple force/sticky layout; no external deps

import type { SnapshotSlim, MonadView } from "../../core/perf/timelineDelta";

export interface ForceParams {
  repulsion: number;  // Coulomb constant (px^2)
  spring: number;     // Hooke constant for edges
  rest: number;       // rest length for edges (px)
  damping: number;    // velocity damping [0..1]
  maxStep: number;    // clamp per‑frame displacement (px)
}
export interface ForceState {
  pos: Record<string, { x:number; y:number; vx:number; vy:number; pinned?: boolean }>; // persistent across ticks
}

export const DefaultForce: ForceParams = { repulsion: 800, spring: 0.02, rest: 90, damping: 0.9, maxStep: 20 };

export function ensureState(s: ForceState, snap: SnapshotSlim) {
  for (const id in snap.monads) if (!s.pos[id]) s.pos[id] = { x: snap.monads[id].x || 0, y: snap.monads[id].y || 0, vx: 0, vy: 0 };
  for (const id in s.pos) if (!snap.monads[id]) delete s.pos[id];
}

export function seedFromSnapshot(s: ForceState, snap: SnapshotSlim){
  for (const id in snap.monads){ const m = snap.monads[id]; const p = s.pos[id] || (s.pos[id] = { x: 0, y: 0, vx: 0, vy: 0 }); if (typeof m.x === 'number') p.x = m.x; if (typeof m.y === 'number') p.y = m.y; }
}

export function stepLayout(s: ForceState, snap: SnapshotSlim, params: ForceParams = DefaultForce, dt = 1) {
  const ids = Object.keys(s.pos); const n = ids.length; if (!n) return;
  const { repulsion, spring, rest, damping, maxStep } = params;

  // Repulsion (naive O(n^2) with cutoff)
  for (let i = 0; i < n; i++) {
    const ai = s.pos[ids[i]]; if (ai.pinned) continue;
    for (let j = i + 1; j < n; j++) {
      const aj = s.pos[ids[j]]; if (aj.pinned) continue;
      let dx = ai.x - aj.x, dy = ai.y - aj.y; let d2 = dx*dx + dy*dy; if (d2 < 1) d2 = 1; // avoid blowup
      const cut = 600*600; if (d2 > cut) continue; // soft cutoff for perf
      const f = repulsion / d2; const invd = 1 / Math.sqrt(d2); dx *= invd; dy *= invd;
      ai.vx += dx * f * dt; ai.vy += dy * f * dt; aj.vx -= dx * f * dt; aj.vy -= dy * f * dt;
    }
  }

  // Springs along neighbor edges
  for (const id in snap.monads){
    const m = snap.monads[id]; const a = s.pos[id]; if (!a) continue;
    for (const t of (m.neighbors || [])) {
      if (!s.pos[t]) continue; const b = s.pos[t];
      let dx = a.x - b.x, dy = a.y - b.y; const d = Math.max(1, Math.hypot(dx, dy)); const k = spring * (d - rest); const nx = dx / d, ny = dy / d;
      if (!a.pinned) { a.vx -= nx * k * dt; a.vy -= ny * k * dt; }
      if (!b.pinned) { b.vx += nx * k * dt; b.vy += ny * k * dt; }
    }
  }

  // Integrate + damping + clamp
  for (const id of ids) {
    const p = s.pos[id]; if (p.pinned) { p.vx = p.vy = 0; continue; }
    p.vx *= damping; p.vy *= damping;
    let dx = p.vx * dt, dy = p.vy * dt;
    const mag = Math.hypot(dx, dy); if (mag > maxStep) { const s = maxStep / Math.max(1e-6, mag); dx *= s; dy *= s; }
    p.x += dx; p.y += dy;
  }
}

export function pinAt(s: ForceState, id: string, x: number, y: number){ const p = s.pos[id] ||= { x, y, vx: 0, vy: 0 }; p.pinned = true; p.x = x; p.y = y; p.vx = p.vy = 0; }
export function unpin(s: ForceState, id: string){ const p = s.pos[id]; if (p) p.pinned = false; }
```

---

## 2) `engine/renderer/anim/transition.ts` (new)

```ts
// engine/renderer/anim/transition.ts
// Stage 4B — Smooth tick interpolation between snapshots

export type Easing = 'linear'|'easeInOut'|'easeOutCubic';
export function ease(kind: Easing, t: number){
  if (kind==='easeInOut') return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
  if (kind==='easeOutCubic') return 1 - Math.pow(1 - t, 3);
  return t;
}

export interface BlendPos { x:number; y:number; alpha:number }
export function lerpPositions(prev: Record<string, BlendPos>, next: Record<string, BlendPos>, t: number): Record<string, BlendPos> {
  const out: Record<string, BlendPos> = {};
  const ids = new Set([...Object.keys(prev), ...Object.keys(next)]);
  ids.forEach(id => {
    const A = prev[id] || { x: next[id]?.x ?? 0, y: next[id]?.y ?? 0, alpha: 0 };
    const B = next[id] || { x: prev[id]?.x ?? 0, y: prev[id]?.y ?? 0, alpha: 0 };
    out[id] = { x: A.x + (B.x - A.x)*t, y: A.y + (B.y - A.y)*t, alpha: A.alpha + (B.alpha - A.alpha)*t };
  });
  return out;
}
```

---

## 3) `playground/components/GraphCanvas.tsx` (update) — drag‑pin + physics + interpolation

```tsx
// playground/components/GraphCanvas.tsx (4A → 4B)
import React, { useEffect, useRef, useState } from 'react';
import { CanvasGraph } from '../../engine/renderer/canvas/CanvasGraph';
import { SnapshotSlim } from '../../engine/core/perf/timelineDelta';
import { ForceState, DefaultForce, ensureState, seedFromSnapshot, stepLayout, pinAt, unpin } from '../../engine/renderer/layout/force';
import { lerpPositions, ease, BlendPos } from '../../engine/renderer/anim/transition';

export const GraphCanvas: React.FC<{
  snapshot: SnapshotSlim | null;
  hotRule?: string | null;
  onPick?: (id: string|null) => void;
  physics?: boolean;
  physicsStrength?: number; // multiplier [0..2]
  blendT?: number;          // 0..1 when interpolating
}>
= ({ snapshot, hotRule=null, onPick, physics=true, physicsStrength=1, blendT=1 }) => {
  const ref = useRef<HTMLCanvasElement>(null);
  const graphRef = useRef<CanvasGraph | null>(null);
  const [force] = useState<ForceState>({ pos: {} });
  const [size, setSize] = useState({ w: 800, h: 480 });
  const [drag, setDrag] = useState<{ id: string; offX:number; offY:number }|null>(null);
  const lastSnap = useRef<SnapshotSlim | null>(null);

  // init canvas graph
  useEffect(() => {
    const c = ref.current!; const g = new CanvasGraph(c); graphRef.current = g;
    const ro = new ResizeObserver(() => { const r = c.getBoundingClientRect(); setSize({ w: r.width|0, h: r.height|0 }); g.resize(r.width|0, r.height|0); g.draw(); }); ro.observe(c.parentElement!);
    return () => { ro.disconnect(); };
  }, []);

  // seed/ensure force state for new snapshots
  useEffect(() => {
    const g = graphRef.current; if (!g || !snapshot) return;
    ensureState(force, snapshot); // keep pos map in sync
    if (!lastSnap.current) seedFromSnapshot(force, snapshot); // first time seed
    lastSnap.current = snapshot;
    g.setSnapshot(snapshot as any); g.setHotRule(hotRule || null); g.draw();
  }, [snapshot?.tick, hotRule]);

  // RAF loop: physics + draw with optional interpolation
  useEffect(() => {
    let raf = 0; const g = graphRef.current!; let last = performance.now();
    function frame(ts: number){
      const dt = Math.min(1/30, (ts - last)/1000); last = ts;
      if (physics && snapshot) stepLayout(force, snapshot, { ...DefaultForce, spring: DefaultForce.spring * physicsStrength, repulsion: DefaultForce.repulsion * physicsStrength }, dt * 60);

      // Build position maps (BlendPos) from force state
      const pos: Record<string, BlendPos> = {}; for (const id in force.pos) pos[id] = { x: force.pos[id].x, y: force.pos[id].y, alpha: 1 };
      // Interpolate from lastSnap positions if blendT < 1 (handled by parent)
      const t = Math.max(0, Math.min(1, blendT));
      g.setExternalPositions(t < 1 ? lerpPositions(g.prevPos || pos, pos, t) : pos); // see CanvasGraph additions below
      g.draw();
      raf = requestAnimationFrame(frame);
    }
    raf = requestAnimationFrame(frame);
    return () => cancelAnimationFrame(raf);
  }, [snapshot?.tick, physics, physicsStrength, blendT]);

  // mouse interactions: drag‑to‑pin
  useEffect(() => {
    const c = ref.current!; const g = graphRef.current!;
    const md = (e: MouseEvent) => { const hit = pick(e); if (!hit) return; const p = g.getScreenPos(hit); setDrag({ id: hit, offX: p.x - e.clientX, offY: p.y - e.clientY }); pinAt(force, hit, force.pos[hit]?.x || 0, force.pos[hit]?.y || 0); onPick?.(hit); };
    const mm = (e: MouseEvent) => { if (!drag) return; const world = g.screenToWorld(e.clientX + drag.offX, e.clientY + drag.offY); pinAt(force, drag.id, world.x, world.y); };
    const mu = () => setDrag(null);
    const dbl = (e: MouseEvent) => { const hit = pick(e); if (hit) unpin(force, hit); };
    function pick(e: MouseEvent){ if (!snapshot) return null; const rect = c.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; return g.hitNode(x, y); }
    c.addEventListener('mousedown', md); window.addEventListener('mousemove', mm); window.addEventListener('mouseup', mu); c.addEventListener('dblclick', dbl);
    return () => { c.removeEventListener('mousedown', md); window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); c.removeEventListener('dblclick', dbl); };
  }, [snapshot?.tick, drag?.id]);

  return <canvas ref={ref} style={{ width:'100%', height: 480, display:'block', border:'1px solid #e5e7eb', borderRadius: 10 }} />;
};
```

---

## 4) `engine/renderer/canvas/CanvasGraph.ts` (update) — external positions + helpers

```ts
// engine/renderer/canvas/CanvasGraph.ts (additions for 4B)
// ...existing imports...
export class CanvasGraph {
  // existing fields...
  private last?: SnapshotSlim; private sel: string | null = null; private hotRule: string | null = null;
  externalPos: Record<string, { x:number; y:number; alpha:number }> | null = null;
  prevPos: Record<string, { x:number; y:number; alpha:number }> | null = null;

  // ...existing constructor + methods...
  setExternalPositions(p: Record<string,{x:number;y:number;alpha:number}>){ this.prevPos = this.externalPos; this.externalPos = p; }

  getScreenPos(id: string){ const m = this.last?.monads[id]; if (!m) return { x: 0, y: 0 }; const p = this.externalPos?.[id] || { x: m.x||0, y: m.y||0, alpha: 1 }; return worldToScreen(p as any, this.cam); }
  screenToWorld(sx: number, sy: number){ return { x: (sx - this.cam.x) / this.cam.z, y: (sy - this.cam.y) / this.cam.z } }
  hitNode(sx: number, sy: number): string | null { const r = this.nodeRadius * this.cam.z + 2; const r2 = r*r; for (const id in (this.last?.monads||{})){ const p = this.getScreenPos(id); const dx=p.x-sx, dy=p.y-sy; if (dx*dx+dy*dy<=r2) return id; } return null; }

  draw(){ const s = this.last; if (!s) return; const ctx = this.ctx; const { width, height } = this.canvas; ctx.save(); ctx.fillStyle = this.theme.bg; ctx.fillRect(0,0,width,height); drawGrid(ctx, this.cam, width, height, this.theme.grid);
    // Use external positions if present
    const P = this.externalPos; // may be null

    // edges
    ctx.lineWidth = 1; for (const id in s.monads){ const m = s.monads[id]; const nb = m.neighbors||[]; const a = P?.[id] || m; for (const t of nb){ const B = s.monads[t]; if (!B) continue; const b = P?.[t] || B; const A2 = worldToScreen(a as any, this.cam), B2 = worldToScreen(b as any, this.cam); ctx.strokeStyle = this.theme.edge; if (this.hotRule && isEdgeHot(s, id, t, this.hotRule)) ctx.strokeStyle = this.theme.edgeHot; ctx.globalAlpha = (a as any).alpha*0.9*(b as any).alpha; ctx.beginPath(); ctx.moveTo(A2.x, A2.y); ctx.lineTo(B2.x, B2.y); ctx.stroke(); ctx.globalAlpha = 1; } }

    // nodes
    for (const id in s.monads){ const m = s.monads[id]; const p = P?.[id] || m; const scr = worldToScreen(p as any, this.cam); ctx.beginPath(); ctx.arc(scr.x, scr.y, this.nodeRadius*this.cam.z, 0, Math.PI*2); ctx.globalAlpha = (p as any).alpha ?? 1; ctx.fillStyle = this.sel===id ? this.theme.nodeSel : this.theme.node; ctx.fill(); ctx.globalAlpha = 1; }

    // labels
    ctx.fillStyle = this.theme.label; ctx.textAlign='center'; ctx.textBaseline='top'; for (const id in s.monads){ const p = P?.[id] || s.monads[id]; const scr = worldToScreen(p as any, this.cam); ctx.globalAlpha = (p as any).alpha ?? 1; ctx.fillText(id, scr.x, scr.y + this.nodeRadius*this.cam.z + 2); ctx.globalAlpha = 1; }
    ctx.restore(); }
}
```

---

## 5) `playground/components/CanvasPlaybackPanel.tsx` (new)

```tsx
// playground/components/CanvasPlaybackPanel.tsx
// Stage 4B — Controls: play/pause, speed, interpolation, physics strength

import React from 'react';

export const CanvasPlaybackPanel: React.FC<{
  playing: boolean; onToggle: () => void; speed: number; setSpeed: (n:number)=>void;
  blendMs: number; setBlendMs: (n:number)=>void; phys: number; setPhys: (n:number)=>void;
}>
= ({ playing, onToggle, speed, setSpeed, blendMs, setBlendMs, phys, setPhys }) => {
  return (
    <div className="mpl-row">
      <button className="mpl-btn" onClick={onToggle}>{playing? '⏸ Pause':'▶ Play'}</button>
      <label>Speed× <input type="number" min={0.1} step={0.1} value={speed} onChange={e=>setSpeed(parseFloat(e.target.value)||1)} style={{ width: 80 }} /></label>
      <label>Interp ms <input type="number" min={0} step={50} value={blendMs} onChange={e=>setBlendMs(parseInt(e.target.value)||0)} style={{ width: 100 }} /></label>
      <label>Physics <input type="range" min={0} max={2} step={0.05} value={phys} onChange={e=>setPhys(parseFloat(e.target.value))} /></label>
    </div>
  );
};
```

---

## 6) `playground/components/CanvasPanel.tsx` (update) — hook playback + interpolation

```tsx
// playground/components/CanvasPanel.tsx (4A → 4B)
import React from 'react';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { GraphCanvas } from './GraphCanvas';
import { CanvasPlaybackPanel } from './CanvasPlaybackPanel';
import { ease } from '../../engine/renderer/anim/transition';

export const CanvasPanel: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void; hotRule?: string|null }>
= ({ timeline, index, onIndex, hotRule=null }) => {
  const snap = React.useMemo(() => ensurePositions(toSlim(timeline[Math.max(0, Math.min(index, timeline.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, timeline]);

  const [playing, setPlaying] = React.useState(false);
  const [speed, setSpeed] = React.useState(1);
  const [blendMs, setBlendMs] = React.useState(220);
  const [phys, setPhys] = React.useState(1);
  const [blendT, setBlendT] = React.useState(1);
  const lastIdx = React.useRef(index);
  const animStart = React.useRef<number>(0);

  // Drive tick playback
  React.useEffect(() => {
    if (!playing) return; let raf = 0; function step(){ onIndex?.(i => { const next = Math.min(timeline.length-1, (typeof i==='number'?i:i) + Math.max(1, Math.round(speed))); return next; } as any); raf = requestAnimationFrame(step); } raf = requestAnimationFrame(step); return () => cancelAnimationFrame(raf); }, [playing, speed, timeline.length]);

  // Trigger interpolation on index change
  React.useEffect(() => { if (index !== lastIdx.current){ animStart.current = performance.now(); lastIdx.current = index; setBlendT(0); } }, [index]);
  React.useEffect(() => { if (blendMs<=0) { setBlendT(1); return; } let raf = 0; function frame(){ const t = Math.min(1, (performance.now() - animStart.current) / Math.max(1, blendMs)); setBlendT(ease('easeOutCubic', t)); if (t<1) raf = requestAnimationFrame(frame); } raf = requestAnimationFrame(frame); return () => cancelAnimationFrame(raf); }, [index, blendMs]);

  return (
    <div className="mpl-canvas">
      <CanvasPlaybackPanel playing={playing} onToggle={()=>setPlaying(p=>!p)} speed={speed} setSpeed={setSpeed} blendMs={blendMs} setBlendMs={setBlendMs} phys={phys} setPhys={setPhys} />
      <GraphCanvas snapshot={snap} hotRule={hotRule} physics={true} physicsStrength={phys} blendT={blendT} />
      <div className="mpl-small mpl-dim">Tick {snap.tick} • {Object.keys(snap.monads).length} monads</div>
    </div>
  );
};
```

---

## 7) `playground/components/DebuggerPanel.tsx` (augment) — Canvas playback section

```tsx
// playground/components/DebuggerPanel.tsx — add Canvas playback/physics section
import { CanvasPanel } from './CanvasPanel';

// inside component JSX, replace previous Canvas section with:
<section className="mpl-section">
  <header className="mpl-section-h">Canvas Renderer (Physics + Interpolation)</header>
  <CanvasPanel timeline={timeline as any} index={idx} onIndex={setIdx as any} />
</section>
```

---

## 8) `playground/styles/debugger.css` (additions)

```css
/* Stage 4B — Playback controls */
.mpl-row label { display: inline-flex; gap: 6px; align-items: center; margin-right: 10px; }
```

---

## 9) Example — `playground/pages/DebugExample4B.tsx`

```tsx
// playground/pages/DebugExample4B.tsx
import React, { useMemo, useState } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample4B() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"], x: -80, y: 0 }, { id: "B", neighbors: ["A"], x: 80, y: 0 } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A", sourceId: "A", targetId: "B" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B","C"], x: -100, y: -20 }, { id: "B", neighbors: ["A","C"], x: 100, y: -20 }, { id: "C", neighbors: ["A","B"], x: 0, y: 110 } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B", sourceId: "B", targetId: "C" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"], x: -60, y: 0 }, { id: "C", neighbors: ["A"], x: 60, y: 0 } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4B — Force/Sticky Layout + Smooth Tick Interpolation</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 10) Notes

* **Pin/unpin**: drag a node to pin (sticks under cursor); double‑click a node to unpin.
* **Interpolation**: `blendMs = 0` disables interpolation (snaps instantly). Default easing is `easeOutCubic`.
* **Performance**: The O(n²) repulsion uses a 600px cutoff. For larger graphs, next steps are a **grid or Barnes–Hut** approximation (planned 4D).
* **Stability**: Since we reuse the persistent `ForceState`, positions are naturally sticky across ticks; new nodes seed near their snapshot positions.

---

## 11) Changelog — Stage 4B

* New engine: `layout/force.ts`, `anim/transition.ts`
* Updated renderer: `CanvasGraph.ts` (external positions, hit tests, world/screen helpers)
* Updated UI: `GraphCanvas` (physics + drag‑pin + interpolation), `CanvasPlaybackPanel`, `CanvasPanel` (controls)
* Debugger wiring: Canvas section now includes playback & physics controls
* CSS: small tweaks for control row

```
```
