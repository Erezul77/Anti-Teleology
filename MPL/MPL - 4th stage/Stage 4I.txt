# MPL Playground — Stage 4I Patch (Save/Load Layouts + Snapshot Diff + Capture)

This patch adds three production‑ready utilities on top of 4C–4H:

* **Save/Load Layouts** → export/import positions, camera, and selection (with autosave)
* **Snapshot Diff** → pick two ticks and visualize adds/removes/moves
* **Capture** → record canvas to **WebM** (MediaRecorder) or export **PNG frame sequence**

(Notes: Browsers typically **cannot encode MP4** directly; we record WebM/VP8/VP9. For MP4/GIF, transcode externally; commands included in Notes.)

---

## Highlights

* `layout.io`: schema‑checked save format with versioning and integrity hash
* `diff.ts`: fast graph set diff + movement detection with pixel/world thresholds
* `CanvasGraph` overlays: green **adds**, red **removes**, amber **moves** (node halos + edge strokes)
* `CapturePanel`: one‑click recording (start/pause/stop) + autosave last clip; optional PNG export @ N FPS
* `StoragePanel`: download `.mpl-layout.json`, upload to restore; optional **autosave to localStorage**

---

## 1) `engine/renderer/io/layout.ts` (new) — save/load schema

```ts
// engine/renderer/io/layout.ts
// Stage 4I — Persist positions, camera, selection; with basic integrity

export interface LayoutSaveV1 {
  $schema: 'mpl-layout.v1';
  createdAt: string;                // ISO
  model: string;                    // optional app string (e.g., 'MPL Playground')
  tick: number;                     // source tick number
  camera: { x:number; y:number; z:number };
  selection: string[];
  positions: Record<string,{ x:number; y:number }>; // world coords
  hash: string;                     // simple checksum of positions
}

export function createSave(payload: Omit<LayoutSaveV1,'$schema'|'createdAt'|'hash'>, model='MPL Playground'): LayoutSaveV1 {
  const base: LayoutSaveV1 = {
    $schema: 'mpl-layout.v1',
    createdAt: new Date().toISOString(),
    model,
    tick: payload.tick,
    camera: payload.camera,
    selection: payload.selection||[],
    positions: payload.positions||{},
    hash: ''
  };
  base.hash = checksum(base);
  return base;
}

export function verifySave(s: LayoutSaveV1): boolean {
  return s?.$schema==='mpl-layout.v1' && s.hash === checksum(s);
}

function checksum(s: LayoutSaveV1): string {
  // deterministic JSON of positions + tick + camera
  const sortedIds = Object.keys(s.positions||{}).sort();
  let acc = `${s.tick}|${s.camera.x}|${s.camera.y}|${s.camera.z}|`;
  for (const id of sortedIds){ const p=s.positions[id]; acc += `${id}:${Math.round(p.x*100)/100},${Math.round(p.y*100)/100};`; }
  let h=2166136261>>>0; for (let i=0;i<acc.length;i++){ h ^= acc.charCodeAt(i); h = Math.imul(h, 16777619); }
  return `fnv1a:${(h>>>0).toString(16)}`;
}

export function downloadJSON(obj: any, filename: string){
  const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}

export async function openJSON<T=any>(): Promise<T|null>{
  return new Promise(res => {
    const inp = document.createElement('input'); inp.type='file'; inp.accept='.json,application/json';
    inp.onchange = () => { const f = inp.files?.[0]; if (!f) return res(null); const r = new FileReader(); r.onload = () => { try{ res(JSON.parse(String(r.result))); } catch{ res(null); } }; r.readAsText(f); };
    inp.click();
  });
}
```

---

## 2) `engine/graph/diff.ts` (new) — graph + motion diff

```ts
// engine/graph/diff.ts
// Stage 4I — Diff two snapshots; detect node/edge adds/removes and moved nodes

import type { SnapshotSlim } from '../core/perf/timelineDelta';

export interface GraphDiff {
  aTick: number; bTick: number;
  addedNodes: string[]; removedNodes: string[]; movedNodes: string[];
  addedEdges: [string,string][]; removedEdges: [string,string][];
}

export function diffSnapshots(a: SnapshotSlim, b: SnapshotSlim, moveThresh=8): GraphDiff {
  const aid = Object.keys(a.monads); const bid = Object.keys(b.monads);
  const A = new Set(aid), B = new Set(bid);
  const addedNodes = bid.filter(id=>!A.has(id));
  const removedNodes = aid.filter(id=>!B.has(id));

  function edgesOf(s: SnapshotSlim){
    const E = new Set<string>();
    for (const id in s.monads){ const nb = s.monads[id].neighbors||[]; for (const t of nb){ if (id < t) E.add(`${id}|${t}`); }
    } return E;
  }
  const EA = edgesOf(a), EB = edgesOf(b);
  const addedEdges = [...EB].filter(e=>!EA.has(e)).map(k=>k.split('|') as [string,string]);
  const removedEdges = [...EA].filter(e=>!EB.has(e)).map(k=>k.split('|') as [string,string]);

  // moved nodes by world distance threshold (if both exist)
  const movedNodes: string[] = [];
  for (const id of bid){ if (!A.has(id)) continue; const pa = (a.monads as any)[id]; const pb = (b.monads as any)[id]; if (!pa||!pb) continue; const dx=(pb.x||0)-(pa.x||0), dy=(pb.y||0)-(pa.y||0); if (dx*dx+dy*dy >= moveThresh*moveThresh) movedNodes.push(id); }

  return { aTick: a.tick, bTick: b.tick, addedNodes, removedNodes, movedNodes, addedEdges, removedEdges };
}
```

---

## 3) `engine/renderer/canvas/CanvasGraph.ts` (update) — diff overlay API

```ts
// CanvasGraph.ts — 4I diff overlay (snippets)
export type DiffOverlay = {
  addedNodes?: Set<string>; removedNodes?: Set<string>; movedNodes?: Set<string>;
  addedEdges?: Set<string>; removedEdges?: Set<string>;
};

export class CanvasGraph {
  // ...existing fields
  private diff: DiffOverlay | null = null;
  setDiff(d: DiffOverlay | null){ this.diff = d; }

  private edgeKey(a:string,b:string){ return a<b? `${a}|${b}` : `${b}|${a}`; }

  draw(){
    // ...existing drawing (grid, hulls, etc.)

    // Edges (augment stroke if in diff)
    ctx.lineWidth = 1; let drawn = 0; let cursor = this.frameEdgeCursor; const stride = Math.max(1, this.lod.sampleStride|0);
    outer: for (const id in s.monads){ const m = s.monads[id]; const a = P?.[id] || m; const nb = m.neighbors||[]; for (let ei=0; ei<nb.length; ei++){ const t=nb[ei]; if (id>=t) continue; if ((cursor++%stride)!==0) continue; const b = P?.[t] || s.monads[t]; const A2=worldToScreen(a as any,this.cam), B2=worldToScreen(b as any,this.cam);
        let col = this.theme.edge; let alpha = ((a as any).alpha*(b as any).alpha);
        const k = this.edgeKey(id,t);
        if (this.diff?.addedEdges?.has(k)) { col = '#10b981'; alpha = 0.95; }
        else if (this.diff?.removedEdges?.has(k)) { col = '#ef4444'; alpha = 0.7; }
        ctx.strokeStyle = col; ctx.globalAlpha = alpha; ctx.beginPath(); routeEdge(ctx,A2.x,A2.y,B2.x,B2.y,this.edgeMode,this.curvature,id<t?1:-1); ctx.stroke(); ctx.globalAlpha=1;
        if (++drawn>=this.lod.edgeBudget) break outer; }
    }
    this.frameEdgeCursor = cursor;

    // Nodes (augment with halos)
    for (const id in s.monads){ const p = P?.[id] || s.monads[id]; const scr=worldToScreen(p as any,this.cam); const r = this.getNodeRadius(id);
      if (this.diff){ if (this.diff.addedNodes?.has(id)){ halo(ctx,scr.x,scr.y,r,'#10b981'); } else if (this.diff.removedNodes?.has(id)){ halo(ctx,scr.x,scr.y,r,'#ef4444'); } else if (this.diff.movedNodes?.has(id)){ halo(ctx,scr.x,scr.y,r,'#f59e0b'); } }
      ctx.beginPath(); ctx.arc(scr.x, scr.y, r, 0, Math.PI*2); ctx.fillStyle = this.sel===id ? this.theme.nodeSel : this.theme.node; ctx.fill();
    }

    // ...labels as before
  }
}

function halo(ctx: CanvasRenderingContext2D, x:number,y:number,r:number,color:string){
  ctx.save(); ctx.shadowColor=color; ctx.shadowBlur=18; ctx.beginPath(); ctx.arc(x,y,r+2,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fill(); ctx.restore();
}
```

---

## 4) `playground/components/StoragePanel.tsx` (new) — save/load + autosave

```tsx
// playground/components/StoragePanel.tsx
import React from 'react';
import { createSave, verifySave, downloadJSON, openJSON } from '../../engine/renderer/io/layout';

export const StoragePanel: React.FC<{
  tick: number;
  camera: { x:number;y:number;z:number };
  positions: Record<string,{x:number;y:number}>;
  selection: string[];
  onLoad: (payload: { camera:any; positions:any; selection:string[] }) => void;
}>
= ({ tick, camera, positions, selection, onLoad }) => {
  const [auto, setAuto] = React.useState(true);

  React.useEffect(() => {
    if (!auto) return; const save = createSave({ tick, camera, selection, positions });
    try { localStorage.setItem('mpl.autosave', JSON.stringify(save)); } catch {}
  }, [tick, camera.x, camera.y, camera.z, Object.keys(positions).length, selection.join('|'), auto]);

  const saveToFile = () => { const save = createSave({ tick, camera, selection, positions }); downloadJSON(save, `layout-t${tick}.mpl-layout.json`); };
  const loadFromFile = async () => { const obj = await openJSON<any>(); if (!obj) return; if (!verifySave(obj)) return alert('Invalid or corrupted layout file.'); onLoad({ camera: obj.camera, positions: obj.positions, selection: obj.selection||[] }); };
  const loadAutosave = () => { try { const raw = localStorage.getItem('mpl.autosave'); if (!raw) return; const obj = JSON.parse(raw); if (!verifySave(obj)) return alert('Autosave corrupt.'); onLoad({ camera: obj.camera, positions: obj.positions, selection: obj.selection||[] }); } catch { alert('Failed to load autosave.'); } };

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Storage</div>
      <div className="mpl-card-b">
        <div className="mpl-row"><button className="mpl-btn" onClick={saveToFile}>Save Layout</button><button className="mpl-btn" onClick={loadFromFile}>Load Layout</button></div>
        <label><input type="checkbox" checked={auto} onChange={e=>setAuto(e.target.checked)} /> Autosave to localStorage</label>
        <button className="mpl-btn" onClick={loadAutosave}>Load Autosave</button>
      </div>
    </div>
  );
};
```

---

## 5) `playground/components/DiffPanel.tsx` (new) — diff UI

```tsx
// playground/components/DiffPanel.tsx
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { diffSnapshots } from '../../engine/graph/diff';

export const DiffPanel: React.FC<{
  history: ExecutionSnapshot[];
  onOverlay: (overlay: { addedNodes:Set<string>; removedNodes:Set<string>; movedNodes:Set<string>; addedEdges:Set<string>; removedEdges:Set<string> } | null)=>void;
}>
= ({ history, onOverlay }) => {
  const [a, setA] = React.useState(0);
  const [b, setB] = React.useState(Math.max(0, history.length-1));
  const [move, setMove] = React.useState(8);

  const slimA = React.useMemo(()=>toSlim(history[Math.max(0,Math.min(a,history.length-1))] as any), [a, history]);
  const slimB = React.useMemo(()=>toSlim(history[Math.max(0,Math.min(b,history.length-1))] as any), [b, history]);
  const D = React.useMemo(()=>diffSnapshots(slimA as any, slimB as any, move), [slimA.tick, slimB.tick, move]);

  React.useEffect(()=>{
    onOverlay({
      addedNodes: new Set(D.addedNodes),
      removedNodes: new Set(D.removedNodes),
      movedNodes: new Set(D.movedNodes),
      addedEdges: new Set(D.addedEdges.map(([x,y])=>x<y?`${x}|${y}`:`${y}|${x}`)),
      removedEdges: new Set(D.removedEdges.map(([x,y])=>x<y?`${x}|${y}`:`${y}|${x}`))
    });
    return () => onOverlay(null);
  }, [D.aTick, D.bTick, move]);

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Snapshot Diff</div>
      <div className="mpl-card-b">
        <div className="mpl-row">
          <label>A <select value={a} onChange={e=>setA(parseInt(e.target.value))}>{history.map((h,i)=><option key={i} value={i}>t{i}</option>)}</select></label>
          <label>B <select value={b} onChange={e=>setB(parseInt(e.target.value))}>{history.map((h,i)=><option key={i} value={i}>t{i}</option>)}</select></label>
          <label>Move ≥ <input type="number" value={move} step={1} onChange={e=>setMove(parseInt(e.target.value)||0} style={{ width: 64 }} /> px</label>
        </div>
        <div className="mpl-list-b mpl-dim">
          <span className="mpl-chip" style={{ background:'#d1fae5' }}>+ nodes {D.addedNodes.length}</span>
          <span className="mpl-chip" style={{ background:'#fee2e2' }}>– nodes {D.removedNodes.length}</span>
          <span className="mpl-chip" style={{ background:'#fef3c7' }}>↔ moved {D.movedNodes.length}</span>
          <span className="mpl-chip" style={{ background:'#d1fae5' }}>+ edges {D.addedEdges.length}</span>
          <span className="mpl-chip" style={{ background:'#fee2e2' }}>– edges {D.removedEdges.length}</span>
        </div>
      </div>
    </div>
  );
};
```

---

## 6) `playground/components/CapturePanel.tsx` (new) — WebM recording + PNG frames

```tsx
// playground/components/CapturePanel.tsx
import React from 'react';

export const CapturePanel: React.FC<{ canvasRef: React.RefObject<HTMLCanvasElement> }>
= ({ canvasRef }) => {
  const [rec, setRec] = React.useState<MediaRecorder|null>(null);
  const [chunks, setChunks] = React.useState<Blob[]>([]);
  const [fps, setFps] = React.useState(30);
  const [pngEvery, setPngEvery] = React.useState(0); // 0 = off
  const [pngCount, setPngCount] = React.useState(0);

  const can = () => canvasRef.current as HTMLCanvasElement | null;

  const start = () => {
    const c = can(); if (!c) return;
    const stream = c.captureStream?.(fps) as MediaStream;
    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm;codecs=vp8';
    const mr = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
    mr.ondataavailable = e => { if (e.data && e.data.size) setChunks(ch => [...ch, e.data]); };
    mr.onstop = () => {
      const blob = new Blob(chunks, { type: mime });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `mpl-capture-${Date.now()}.webm`; a.click(); URL.revokeObjectURL(a.href); setChunks([]);
    };
    mr.start(); setRec(mr);
  };

  const stop = () => { if (!rec) return; rec.stop(); setRec(null); };

  // PNG frame export at interval (optional)
  React.useEffect(() => {
    if (!pngEvery || !can()) return; let t=0; let raf=0; const tick=(ts:number)=>{ if (!can()) return; if (t===0) t=ts; const dt=ts-t; if (dt>=1000/Math.max(1,pngEvery)){ t=ts; const data = can()!.toDataURL('image/png'); const a=document.createElement('a'); a.href = data; a.download = `frame-${String(pngCount).padStart(5,'0')}.png`; a.click(); setPngCount(c=>c+1); } raf=requestAnimationFrame(tick); }; raf=requestAnimationFrame(tick); return ()=>cancelAnimationFrame(raf);
  }, [pngEvery]);

  return (
    <div className="mpl-card">
      <div className="mpl-card-h">Capture</div>
      <div className="mpl-card-b">
        <div className="mpl-row">
          <button className="mpl-btn" onClick={start} disabled={!!rec}>Start WebM</button>
          <button className="mpl-btn" onClick={stop} disabled={!rec}>Stop</button>
          <label>FPS <input type="number" value={fps} onChange={e=>setFps(parseInt(e.target.value)||30)} style={{ width: 64 }} /></label>
        </div>
        <div className="mpl-row">
          <label>PNG every <input type="number" value={pngEvery} onChange={e=>setPngEvery(parseInt(e.target.value)||0)} style={{ width: 64 }} /> ms (0=off)</label>
          <span className="mpl-dim">Frames saved: {pngCount}</span>
        </div>
      </div>
    </div>
  );
};
```

---

## 7) `playground/components/CanvasPanel.tsx` (update) — wire everything

```tsx
// playground/components/CanvasPanel.tsx — 4I wiring (excerpt)
import React from 'react';
import type { ExecutionSnapshot } from '../../engine/debugger/graphTypes';
import { ensurePositions } from '../../engine/renderer/layout/seededLayout';
import { toSlim } from '../../engine/core/perf/timelineDelta';
import { GraphCanvas } from './GraphCanvas';
import { StoragePanel } from './StoragePanel';
import { DiffPanel } from './DiffPanel';
import { CapturePanel } from './CapturePanel';

export const CanvasPanel: React.FC<{ timeline: ExecutionSnapshot[]; index: number; onIndex?: (i:number)=>void; hotRule?: string|null }>
= ({ timeline, index, onIndex, hotRule=null }) => {
  const slim = React.useMemo(() => ensurePositions(toSlim(timeline[Math.max(0, Math.min(index, timeline.length-1))] || { tick: index, monads: [], rulesFired: [] } as any)), [index, timeline]);

  const canvasRef = React.useRef<HTMLCanvasElement>(null);
  const [camera, setCamera] = React.useState({ x:0,y:0,z:1 });
  const [positions, setPositions] = React.useState<Record<string,{x:number;y:number}>>({});
  const [selection, setSelection] = React.useState<string[]>([]);
  const [overlay, setOverlay] = React.useState<any>(null);

  return (
    <div className="mpl-grid">
      <div className="mpl-main">
        {/* existing playback + scrubber rows remain (from 4G/4H) */}
        <GraphCanvas
          snapshot={slim}
          camera={camera}
          onCamera={setCamera}
          onPositions={setPositions}
          onSelect={setSelection}
          ref={canvasRef as any}
        />
        <div className="mpl-row">
          <StoragePanel tick={slim.tick} camera={camera} positions={positions} selection={selection} onLoad={({ camera, positions, selection }) => {
            setCamera(camera); // positions injection is applied by seeding on next tick: optional live apply below
            // live apply positions to current graph
            const g = (canvasRef.current as any)?._graph; // if you stash ref inside GraphCanvas, apply now
            if (g) { const map:any = {}; for (const id in positions){ map[id] = { x: positions[id].x, y: positions[id].y, alpha: 1 }; } g.setExternalPositions(map); g.draw(); }
            setSelection(selection||[]);
          }} />
          <DiffPanel history={timeline} onOverlay={setOverlay} />
          <CapturePanel canvasRef={canvasRef} />
        </div>
      </div>
      <aside className="mpl-side">
        <div className="mpl-card"><div className="mpl-card-h">Diff Legend</div><div className="mpl-card-b mpl-dim"><div className="mpl-chip" style={{ background:'#d1fae5' }}>Green = added</div><div className="mpl-chip" style={{ background:'#fee2e2' }}>Red = removed</div><div className="mpl-chip" style={{ background:'#fef3c7' }}>Amber = moved</div></div></div>
      </aside>
    </div>
  );
};
```

> In your `GraphCanvas` implementation, forward an instance handle if you want direct calls from panels: `useImperativeHandle(ref, () => ({ get graph(){ return graphRef.current; } }));` and stash it on `ref.current._graph = graphRef.current` for simplicity.

---

## 8) `playground/styles/debugger.css` (additions)

```css
/* Stage 4I — small UI tweaks */
.mpl-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.mpl-chip { padding: 2px 6px; border-radius: 999px; }
```

---

## 9) Example — `playground/pages/DebugExample4I.tsx`

```tsx
// playground/pages/DebugExample4I.tsx
import React, { useMemo, useState } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

function makeHistory(): ExecutionSnapshot[] {
  const A: ExecutionSnapshot = { tick: 0, monads: [ { id: 'A', neighbors: ['B'], x: -120, y: 0 }, { id: 'B', neighbors: ['A'], x: 120, y: 0 } ], rulesFired: [] } as any;
  const B: ExecutionSnapshot = { tick: 1, monads: [ { id: 'A', neighbors: ['C'], x: -80, y: -40 }, { id: 'C', neighbors: ['A'], x: 80, y: 40 } ], rulesFired: [] } as any; // B removed, C added
  const C: ExecutionSnapshot = { tick: 2, monads: [ { id: 'A', neighbors: ['C','D'], x: -40, y: 60 }, { id: 'C', neighbors: ['A'], x: 40, y: -60 }, { id: 'D', neighbors: ['A'], x: 0, y: 0 } ], rulesFired: [] } as any; // A moved, D added
  return [A,B,C];
}

export default function DebugExample4I(){
  const history = useMemo(makeHistory, []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 4I — Save/Load Layouts + Snapshot Diff + Capture</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 10) Notes

* **MP4/GIF**: Use the exported WebM to transcode offline, e.g.:

  * MP4 (H.264): `ffmpeg -i input.webm -c:v libx264 -pix_fmt yuv420p out.mp4`
  * GIF (palette): `ffmpeg -i input.webm -vf "fps=15,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" out.gif`
* **Positions injection**: A loaded layout can be applied immediately via `setExternalPositions()`; to persist across ticks, seed your force state with the loaded positions.
* **Diff thresholds**: `moveThresh` is world‑space pixels between snapshots; increase on noisy timelines.
* **Autosave**: toggled in `StoragePanel`; safe to keep on — files are tiny (positions + a few fields).

---

## 11) Changelog — Stage 4I

* New: `renderer/io/layout.ts` (save/load), `graph/diff.ts` (diff)
* Updated: `CanvasGraph.ts` (diff overlay)
* New UI: `StoragePanel.tsx`, `DiffPanel.tsx`, `CapturePanel.tsx`
* Updated: `CanvasPanel.tsx` (integrated panels)
* CSS: minor tweaks

```
```
