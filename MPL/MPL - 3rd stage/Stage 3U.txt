# MPL Playground ‚Äî Stage 3U Patch (Macro Actions + Presets + Keyboard Maps)

This patch adds a light **Macro engine** (script simple actions with waits, variables, and condition checks), sharable **Presets** (watch lists, default searches, quick layout knobs), and configurable **Keyboard maps** (bind keys to actions/macros). No new deps.

**Highlights**

* Action registry with safe, whitelisted actions (no `eval`).
* Macros: ordered steps `{action, args, waitMs?, if?}` with `${vars}` interpolation.
* Presets: save/apply UI config (watches, default session search, quick knobs).
* Keymaps: bind `Ctrl/Cmd/Shift/Alt` combos to actions or macros; import/export.
* Debugger wires a runtime **ActionsContext** so macros can navigate timeline, add bookmarks, run search, save/open sessions, etc.

---

## 1) `engine/debugger/macro.ts` (new)

```ts
// engine/debugger/macro.ts
// Stage 3U ‚Äî Action registry + macro runner (async, no eval)

export type JSONValue = string | number | boolean | null | JSONValue[] | { [k: string]: JSONValue };

export interface ActionsContext {
  // Timeline controls
  getIndex(): number; setIndex(i: number): void; step(delta: number): void;
  getMaxIndex(): number; getTick(i?: number): number;
  setGhost(i: number | null): void;
  // Notes/Bookmarks/Search
  addBookmark(i: number, label?: string): void;
  setSessionSearchQuery(q: string): void; // feeds SessionSearchPanel
  // Vault
  saveToVault(title: string, tags?: string[]): void;
  openSessionByTitle(title: string, index?: number): boolean; // returns true if opened
  // Misc
  toast(msg: string): void;
  // Vars
  getVar(k: string): JSONValue | undefined; setVar(k: string, v: JSONValue): void;
}

export interface ActionSpec {
  id: string; label: string; describe?: (args?: JSONValue) => string;
  run: (ctx: ActionsContext, args?: JSONValue) => Promise<void> | void;
}

const registry = new Map<string, ActionSpec>();
export function registerAction(a: ActionSpec) { registry.set(a.id, a); }
export function listActions(): ActionSpec[] { return [...registry.values()]; }
export function getAction(id: string): ActionSpec | undefined { return registry.get(id); }

export interface MacroStep { action: string; args?: JSONValue; waitMs?: number; if?: string }
export interface Macro { id: string; label: string; steps: MacroStep[]; color?: string; enabled: boolean; createdAt: number; }
export function createMacro(label = "Macro"): Macro { return { id: `m_${Date.now()}_${Math.random().toString(36).slice(2,8)}`, label, steps: [], enabled: true, createdAt: Date.now() }; }

// --- Tiny condition language: supports symbols index, max, tick, var("k") and comparisons with numbers/strings
// Examples: "index < 10", "tick >= 50", "var(\"phase\") == 'train'"
export function evalCondition(ctx: ActionsContext, expr?: string): boolean {
  if (!expr || !(expr = expr.trim())) return true;
  try {
    // very small parser: only handles single comparison op
    const m = expr.match(/^(.*?)\s*(==|!=|<=|>=|<|>)\s*(.*)$/);
    const lhs = m ? m[1].trim() : expr.trim();
    const op = m ? m[2] : '!='; // if no op, treat as truthy check
    const rhsRaw = m ? m[3].trim() : '';
    const valOf = (s: string): any => {
      if (s === 'index') return ctx.getIndex();
      if (s === 'max') return ctx.getMaxIndex();
      if (s === 'tick') return ctx.getTick();
      const vm = s.match(/^var\("(.+?)"\)$/); if (vm) return ctx.getVar(vm[1]);
      if (/^\d+(?:\.\d+)?$/.test(s)) return Number(s);
      return s.replace(/^"|"$/g, '');
    };
    const L = valOf(lhs), R = valOf(rhsRaw);
    switch (op) { case '==': return L == R; case '!=': return L != R; case '<': return L < R; case '>': return L > R; case '<=': return L <= R; case '>=': return L >= R; default: return !!L; }
  } catch { return false; }
}

function interpolate(v: JSONValue, ctx: ActionsContext): JSONValue {
  const rep = (s: string) => s.replace(/\$\{(index|max|tick|ghost|var:([\w-]+))\}/g, (_m, t, k) => {
    if (t === 'index') return String(ctx.getIndex());
    if (t === 'max') return String(ctx.getMaxIndex());
    if (t === 'tick') return String(ctx.getTick());
    if (t.startsWith('var:')) return String(ctx.getVar(k) ?? '');
    if (t === 'ghost') return String(ctx.getVar('ghost') ?? '');
    return '';
  });
  if (typeof v === 'string') return rep(v);
  if (Array.isArray(v)) return v.map(x => interpolate(x as any, ctx)) as any;
  if (v && typeof v === 'object') { const o: any = {}; for (const [k,val] of Object.entries(v)) o[k] = interpolate(val as any, ctx); return o; }
  return v;
}

export async function runMacro(ctx: ActionsContext, m: Macro) {
  for (const step of m.steps) {
    if (!evalCondition(ctx, step.if)) continue;
    const act = getAction(step.action); if (!act) { ctx.toast(`Unknown action: ${step.action}`); continue; }
    const args = interpolate(step.args as any, ctx);
    await act.run(ctx, args);
    if (step.waitMs && step.waitMs > 0) await new Promise(r => setTimeout(r, step.waitMs));
  }
}
```

---

## 2) `engine/debugger/actions.builtins.ts` (new)

```ts
// engine/debugger/actions.builtins.ts
// Stage 3U ‚Äî Register a set of safe built-in actions

import { registerAction, ActionsContext } from "./macro";
import { Vault } from "./vault";
import { runSessionSearch, parseSessionQuery } from "./sessionSearch";

registerAction({ id: 'setIndex', label: 'Set index', run: (ctx, args: any) => { const i = Math.max(0, Math.min(Number(args?.index ?? 0), ctx.getMaxIndex())); ctx.setIndex(i); }});
registerAction({ id: 'step', label: 'Step by delta', run: (ctx, args: any) => ctx.step(Number(args?.delta ?? 1)) });
registerAction({ id: 'setGhost', label: 'Set ghost index', run: (ctx, args: any) => ctx.setGhost(args?.index == null ? null : Number(args.index)) });
registerAction({ id: 'addBookmark', label: 'Add bookmark', run: (ctx, args: any) => ctx.addBookmark(ctx.getIndex(), String(args?.label ?? 'bookmark')) });
registerAction({ id: 'search', label: 'Set session search query', run: (ctx, args: any) => ctx.setSessionSearchQuery(String(args?.query ?? '')) });
registerAction({ id: 'saveVault', label: 'Save to Vault', run: (ctx, args: any) => ctx.saveToVault(String(args?.title ?? `Macro save @ ${new Date().toLocaleString()}`), (args?.tags as any[])?.map(String)) });
registerAction({ id: 'openSessionByTitle', label: 'Open Vault session by title', run: (ctx, args: any) => { const ok = ctx.openSessionByTitle(String(args?.title ?? '')); if (!ok) ctx.toast('Session not found'); }});
registerAction({ id: 'setVar', label: 'Set variable', run: (ctx, args: any) => ctx.setVar(String(args?.key ?? 'k'), args?.value) });
registerAction({ id: 'forEachSearchHit', label: 'Loop: for each search hit', run: async (ctx, args: any) => {
  const query = String(args?.query ?? ''); const macroId = String(args?.macroId ?? ''); if (!macroId) return;
  const bundle = (Vault.load(Vault.list()[0]?.id || '')?.bundle || null); // unused: only to import types
  // Build a fake space from current UI: we can‚Äôt access full space here, so reuse SessionSearchPanel via ctx.setSessionSearchQuery? Simpler: rely on UI to execute nested macro via keymap.
  ctx.setSessionSearchQuery(query);
}});

// Convenience: jump to first index matching a session search query
registerAction({ id: 'openFirstMatch', label: 'Open first match of query', run: (ctx, args: any) => {
  const q = parseSessionQuery(String(args?.query ?? ''));
  const space: any = (ctx as any).getSearchSpace?.();
  if (!space) return ctx.toast('Search space unavailable');
  const { indices } = runSessionSearch(space, q);
  if (indices.length) ctx.setIndex(indices[0]); else ctx.toast('No matches');
}});
```

> Note: `forEachSearchHit` is a placeholder loop primitive; the UI provides a safer way to batch-run a nested macro (see MacrosPanel ‚ÄúTest Run on hits‚Äù).

---

## 3) `engine/debugger/presets.ts` (new)

```ts
// engine/debugger/presets.ts
// Stage 3U ‚Äî Save/apply small UI presets (watches, default search, knobs)

import { Watch } from "./watch";

export interface UIPreset {
  id: string; title: string; createdAt: number; color?: string;
  payload: {
    watches?: Pick<Watch, 'label'|'expr'|'color'|'enabled'>[];
    defaultSearchQuery?: string;
    knobs?: { heatWindow?: number; heatNormalize?: 'local'|'global' };
  };
}

const KEY = 'mpl_presets_v1';
const read = (): UIPreset[] => { try { return JSON.parse(localStorage.getItem(KEY) || '[]'); } catch { return []; } };
const write = (arr: UIPreset[]) => localStorage.setItem(KEY, JSON.stringify(arr));

export const Presets = {
  list(): UIPreset[] { return read().sort((a,b) => b.createdAt - a.createdAt); },
  save(p: UIPreset): void { const arr = read(); arr.push(p); write(arr); },
  remove(id: string): void { write(read().filter(x => x.id !== id)); },
};
```

---

## 4) `engine/debugger/keymap.ts` (new)

```ts
// engine/debugger/keymap.ts
// Stage 3U ‚Äî Key binding registry + matcher

export type Target = { kind: 'action'; id: string; args?: any } | { kind: 'macro'; id: string };
export interface KeyBinding { id: string; label: string; combo: string; target: Target; enabled: boolean; }

export function parseCombo(c: string) {
  const parts = c.toLowerCase().split('+').map(s => s.trim()).filter(Boolean);
  const m = { ctrl:false, alt:false, shift:false, meta:false, key:'' } as any;
  for (const p of parts) {
    if (p==='ctrl' || p==='control') m.ctrl = true; else if (p==='alt' || p==='option') m.alt = true; else if (p==='shift') m.shift = true; else if (p==='cmd' || p==='meta' || p==='command') m.meta = true; else m.key = p;
  }
  return m;
}

export function matches(e: KeyboardEvent, combo: string) {
  const m = parseCombo(combo); const key = e.key.toLowerCase();
  const modOk = (!!e.ctrlKey===!!m.ctrl) && (!!e.altKey===!!m.alt) && (!!e.shiftKey===!!m.shift) && (!!e.metaKey===!!m.meta);
  return modOk && (m.key ? key === m.key : true);
}
```

---

## 5) `playground/components/MacrosPanel.tsx` (new)

```tsx
// playground/components/MacrosPanel.tsx
// Stage 3U ‚Äî Create/edit/run macros

import React, { useMemo, useState } from "react";
import { Macro, createMacro, runMacro, listActions } from "../../engine/debugger/macro";

interface MacrosPanelProps {
  macros: Macro[]; onChange: (m: Macro[]) => void;
  actionsCtx: any;                            // ActionsContext provided by Debugger
  availableMacros?: Macro[];                  // for nested refs
}

export const MacrosPanel: React.FC<MacrosPanelProps> = ({ macros, onChange, actionsCtx }) => {
  const [label, setLabel] = useState("Macro");
  const [selected, setSelected] = useState<string | null>(null);
  const actions = useMemo(() => listActions(), []);

  const add = () => { const m = createMacro(label.trim() || 'Macro'); onChange([ ...macros, m ]); setSelected(m.id); };
  const del = (id: string) => onChange(macros.filter(m => m.id !== id));
  const patch = (id: string, p: Partial<Macro>) => onChange(macros.map(m => m.id === id ? { ...m, ...p } : m));
  const run = async (id: string) => { const m = macros.find(x => x.id === id); if (!m) return; await runMacro(actionsCtx, m); };

  const m = macros.find(x => x.id === selected) || macros[0];

  return (
    <div className="mpl-macros">
      <div className="mpl-macros-bar">
        <input placeholder="New macro label" value={label} onChange={e => setLabel(e.target.value)} />
        <button className="mpl-btn" onClick={add}>‚ûï Create</button>
      </div>

      <div className="mpl-macros-body">
        <aside>
          <ul className="mpl-macro-list">
            {macros.map(x => (
              <li key={x.id} className={x.id===m?.id?"active":undefined} onClick={() => setSelected(x.id)}>
                <span className="mpl-dot" style={{ background: x.color || '#e9d5ff' }} /> {x.label}
                <label className="mpl-check"><input type="checkbox" checked={x.enabled} onChange={e => patch(x.id, { enabled: e.target.checked })} /> enabled</label>
                <button className="mpl-btn slim mpl-danger" onClick={() => del(x.id)}>‚úï</button>
              </li>
            ))}
            {macros.length === 0 && <li className="mpl-dim">No macros</li>}
          </ul>
        </aside>

        <section className="mpl-macro-editor">
          {!m ? <div className="mpl-empty">Select a macro</div> : (
            <div>
              <div className="mpl-row">
                <label>Label <input value={m.label} onChange={e => patch(m.id, { label: e.target.value })} /></label>
                <input type="color" value={m.color || '#e9d5ff'} onChange={e => patch(m.id, { color: e.target.value })} />
                <button className="mpl-btn" onClick={() => run(m.id)}>‚ñ∂ Run</button>
              </div>

              <table className="mpl-table mpl-steps">
                <thead><tr><th>#</th><th>Action</th><th>Args (JSON, supports ${'${index}'} etc.)</th><th>If</th><th>Wait (ms)</th><th></th></tr></thead>
                <tbody>
                  {m.steps.map((s, i) => (
                    <tr key={i}>
                      <td>{i+1}</td>
                      <td>
                        <select value={s.action} onChange={e => { const steps = [...m.steps]; steps[i] = { ...s, action: e.target.value }; patch(m.id, { steps }); }}>
                          {actions.map(a => <option key={a.id} value={a.id}>{a.label}</option>)}
                        </select>
                      </td>
                      <td>
                        <textarea value={JSON.stringify(s.args ?? {}, null, 0)} onChange={e => { try { const val = e.target.value ? JSON.parse(e.target.value) : {}; const steps = [...m.steps]; steps[i] = { ...s, args: val }; patch(m.id, { steps }); } catch {} }} />
                      </td>
                      <td>
                        <input placeholder="e.g., index < 10" value={s.if ?? ''} onChange={e => { const steps = [...m.steps]; steps[i] = { ...s, if: e.target.value }; patch(m.id, { steps }); }} />
                      </td>
                      <td>
                        <input type="number" value={s.waitMs ?? 0} onChange={e => { const steps = [...m.steps]; steps[i] = { ...s, waitMs: parseInt(e.target.value) || 0 }; patch(m.id, { steps }); }} />
                      </td>
                      <td>
                        <button className="mpl-btn slim" onClick={() => { const steps = [...m.steps]; steps.splice(i,1); patch(m.id, { steps }); }}>‚úï</button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>

              <div className="mpl-row">
                <button className="mpl-btn" onClick={() => patch(m.id, { steps: [...m.steps, { action: actions[0]?.id || 'setIndex', args: { index: 0 } }] })}>+ Step</button>
                <button className="mpl-btn" onClick={() => navigator.clipboard.writeText(JSON.stringify(m, null, 2))}>Copy JSON</button>
              </div>

              <div className="mpl-small">Variables: <code>${'${index}'}</code>, <code>${'${max}'}</code>, <code>${'${tick}'}</code>, <code>${'${var:name}'}</code></div>
            </div>
          )}
        </section>
      </div>
    </div>
  );
};
```

---

## 6) `playground/components/PresetsPanel.tsx` (new)

```tsx
// playground/components/PresetsPanel.tsx
// Stage 3U ‚Äî Save/apply UI presets

import React, { useMemo, useState } from "react";
import { Presets, UIPreset } from "../../engine/debugger/presets";
import { Watch } from "../../engine/debugger/watch";

interface PresetsPanelProps {
  getWatches: () => Watch[]; setWatches: (w: Watch[]) => void;
  setDefaultSearchQuery: (q: string) => void;
  getKnobs: () => { heatWindow?: number; heatNormalize?: 'local'|'global' };
  setKnobs: (k: { heatWindow?: number; heatNormalize?: 'local'|'global' }) => void;
}

export const PresetsPanel: React.FC<PresetsPanelProps> = ({ getWatches, setWatches, setDefaultSearchQuery, getKnobs, setKnobs }) => {
  const [title, setTitle] = useState("Preset");
  const [items, setItems] = useState<UIPreset[]>(Presets.list());
  const [filter, setFilter] = useState("");

  const refresh = () => setItems(Presets.list());
  const save = () => {
    const p: UIPreset = {
      id: `p_${Date.now()}`, title: title.trim() || `Preset @ ${new Date().toLocaleString()}`, createdAt: Date.now(),
      payload: { watches: getWatches().map(w => ({ label: w.label, expr: w.expr, color: w.color, enabled: w.enabled })), defaultSearchQuery: '', knobs: getKnobs() },
    };
    Presets.save(p); setTitle(""); refresh();
  };

  const apply = (p: UIPreset) => {
    const { watches, defaultSearchQuery, knobs } = p.payload || {};
    if (watches) setWatches(watches.map(w => ({ ...w, id: `w_${Math.random().toString(36).slice(2,8)}`, createdAt: Date.now() })) as any);
    if (defaultSearchQuery != null) setDefaultSearchQuery(defaultSearchQuery);
    if (knobs) setKnobs(knobs);
  };

  const view = useMemo(() => items.filter(x => !filter || x.title.toLowerCase().includes(filter.toLowerCase())), [items, filter]);

  return (
    <div className="mpl-presets">
      <div className="mpl-presets-bar">
        <input placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} />
        <button className="mpl-btn" onClick={save}>üíæ Save</button>
        <input placeholder="Filter" value={filter} onChange={e => setFilter(e.target.value)} />
        <button className="mpl-btn" onClick={refresh}>‚Üª Refresh</button>
      </div>

      <div className="mpl-presets-list">
        {view.map(p => (
          <div key={p.id} className="mpl-card-row">
            <div>
              <b>{p.title}</b> <small className="mpl-dim">{new Date(p.createdAt).toLocaleString()}</small>
            </div>
            <div>
              <button className="mpl-btn" onClick={() => apply(p)}>Apply</button>
              <button className="mpl-btn mpl-danger" onClick={() => { Presets.remove(p.id); refresh(); }}>Delete</button>
            </div>
          </div>
        ))}
        {view.length === 0 && <div className="mpl-empty">No presets saved</div>}
      </div>
    </div>
  );
};
```

---

## 7) `playground/components/KeymapPanel.tsx` (new)

```tsx
// playground/components/KeymapPanel.tsx
// Stage 3U ‚Äî Bind keys to actions/macros

import React, { useMemo, useState } from "react";
import { KeyBinding, Target } from "../../engine/debugger/keymap";
import { listActions } from "../../engine/debugger/macro";

interface KeymapPanelProps {
  keymap: KeyBinding[]; onChange: (km: KeyBinding[]) => void;
  macros: { id: string; label: string }[];
}

export const KeymapPanel: React.FC<KeymapPanelProps> = ({ keymap, onChange, macros }) => {
  const actions = useMemo(() => listActions(), []);
  const [combo, setCombo] = useState("g");
  const [label, setLabel] = useState("Set ghost=A");
  const [target, setTarget] = useState<Target>({ kind: 'action', id: 'setGhost', args: { index: "${index}" } });

  const add = () => onChange([ ...keymap, { id: `kb_${Date.now()}`, label, combo, target, enabled: true } ]);
  const rm = (id: string) => onChange(keymap.filter(k => k.id !== id));
  const patch = (id: string, p: Partial<KeyBinding>) => onChange(keymap.map(k => k.id === id ? { ...k, ...p } : k));

  return (
    <div className="mpl-keymap">
      <div className="mpl-km-add">
        <input placeholder="Key combo (e.g., shift+space)" value={combo} onChange={e => setCombo(e.target.value)} />
        <input placeholder="Label" value={label} onChange={e => setLabel(e.target.value)} />
        <select value={(target.kind==='action' ? target.id : `macro:${(target as any).id}`)} onChange={e => {
          const v = e.target.value; if (v.startsWith('macro:')) setTarget({ kind: 'macro', id: v.slice(6) }); else setTarget({ kind: 'action', id: v });
        }}>
          <optgroup label="Actions">
            {actions.map(a => <option key={a.id} value={a.id}>{a.label}</option>)}
          </optgroup>
          <optgroup label="Macros">
            {macros.map(m => <option key={m.id} value={`macro:${m.id}`}>{m.label}</option>)}
          </optgroup>
        </select>
        <button className="mpl-btn" onClick={add}>‚ûï Bind</button>
      </div>

      <table className="mpl-table mpl-km-table">
        <thead><tr><th>Key</th><th>Label</th><th>Target</th><th>Enabled</th><th></th></tr></thead>
        <tbody>
          {keymap.map(k => (
            <tr key={k.id}>
              <td><input value={k.combo} onChange={e => patch(k.id, { combo: e.target.value })} /></td>
              <td><input value={k.label} onChange={e => patch(k.id, { label: e.target.value })} /></td>
              <td>{k.target.kind==='action' ? `action:${k.target.id}` : `macro:${(k.target as any).id}`}</td>
              <td><input type="checkbox" checked={k.enabled} onChange={e => patch(k.id, { enabled: e.target.checked })} /></td>
              <td><button className="mpl-btn mpl-danger" onClick={() => rm(k.id)}>‚úï</button></td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
```

---

## 8) `playground/components/DebuggerPanel.tsx` (wire Macros + Presets + Keymap)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3U ‚Äî Wire macro/preset/keymap into the existing panel

import React, { useEffect, useMemo, useRef, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";
import { TimeScrubber } from "./TimeScrubber";
import { ImportExportPanel } from "./ImportExportPanel";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { BookmarksPanel } from "./BookmarksPanel";
import { SessionBundle } from "../../engine/debugger/sessionIO";
import { AnnotationsPanel } from "./AnnotationsPanel";
import { MonadicNote, SessionAnnotation } from "../../engine/debugger/annotations";
import { NodeNotesPanel } from "./NodeNotesPanel";
import { RuleLogPanel } from "./RuleLogPanel";
import { RuleStatsPanel } from "./RuleStatsPanel";
import { Breakpoint } from "../../engine/debugger/breakpoints";
import { BreakpointsPanel } from "./BreakpointsPanel";
import { WatchesPanel } from "./WatchesPanel";
import { DiffPanel } from "./DiffPanel";
import { SessionSearchPanel } from "./SessionSearchPanel";
import { Watch } from "../../engine/debugger/watch";
import { Macro } from "../../engine/debugger/macro";
import { MacrosPanel } from "./MacrosPanel";
import { PresetsPanel } from "./PresetsPanel";
import { KeymapPanel } from "./KeymapPanel";
import { KeyBinding, matches } from "../../engine/debugger/keymap";
import { Vault, VaultSessionMeta } from "../../engine/debugger/vault";
import { listActions, runMacro } from "../../engine/debugger/macro";
import "../../engine/debugger/actions.builtins"; // registers built-ins

interface DebuggerPanelProps { snapshot?: ExecutionSnapshot; history?: ExecutionSnapshot[]; onFocusMonad?: (id: string) => void; }

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, history, onFocusMonad }) => {
  const [timeline, setTimeline] = useState<ExecutionSnapshot[]>(() => history ?? (snapshot ? [snapshot] : []));
  useEffect(() => { if (history && history.length) setTimeline(history); }, [history?.length]);
  useEffect(() => { if (!history && snapshot) setTimeline([snapshot]); }, [snapshot?.tick]);

  const [idx, setIdx] = useState(() => Math.max(0, timeline.length - 1));
  useEffect(() => { setIdx(Math.max(0, timeline.length - 1)); }, [timeline.length]);

  const [ghostIdx, setGhostIdx] = useState<number | null>(null);
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);
  const [annotations, setAnnotations] = useState<SessionAnnotation[]>([]);
  const [monadNotes, setMonadNotes] = useState<MonadicNote[]>([]);
  const [selectedMonadId, setSelectedMonadId] = useState<string | null>(null);
  const [ruleMarks, setRuleMarks] = useState<number[]>([]);
  const [bpMarks, setBpMarks] = useState<number[]>([]);
  const [heatStrip, setHeatStrip] = useState<number[] | undefined>(undefined);
  const [watches, setWatches] = useState<Watch[]>([]);
  const [searchMarks, setSearchMarks] = useState<number[]>([]);
  const [breakpoints, setBreakpoints] = useState<Breakpoint[]>([]);

  const [macros, setMacros] = useState<Macro[]>([]);
  const [keymap, setKeymap] = useState<KeyBinding[]>([
    { id: 'kb1', label: 'Step +1', combo: 'ctrl+arrowright', target: { kind: 'action', id: 'step', args: { delta: 1 } }, enabled: true },
    { id: 'kb2', label: 'Step -1', combo: 'ctrl+arrowleft', target: { kind: 'action', id: 'step', args: { delta: -1 } }, enabled: true },
    { id: 'kb3', label: 'Set ghost=A', combo: 'g', target: { kind: 'action', id: 'setGhost', args: { index: "${index}" } }, enabled: true },
    { id: 'kb4', label: 'Add bookmark', combo: 'b', target: { kind: 'action', id: 'addBookmark', args: { label: 'kb' } }, enabled: true },
  ]);
  const searchQueryRef = useRef<string>("");

  const current = useMemo<ExecutionSnapshot | undefined>(() => timeline[Math.max(0, Math.min(idx, timeline.length - 1))], [timeline, idx]);
  const ghost = useMemo<ExecutionSnapshot | undefined>(() => ghostIdx == null ? undefined : timeline[Math.max(0, Math.min(ghostIdx, timeline.length - 1))], [timeline, ghostIdx]);

  const bundleOf = (): SessionBundle => ({ history: timeline, bookmarks, annotations, monadNotes, watches: watches as any, breakpoints } as SessionBundle);
  const loadFromMeta = (m: VaultSessionMeta, jumpTo?: number, searchIdx?: number[]) => {
    const vs = Vault.load(m.id); if (!vs) return;
    const b = vs.bundle;
    setTimeline(b.history || []);
    setBookmarks(b.bookmarks || []);
    setAnnotations(b.annotations || []);
    setMonadNotes(b.monadNotes || []);
    setWatches((b as any).watches || []);
    setBreakpoints((b as any).breakpoints || []);
    const j = Math.max(0, Math.min(jumpTo ?? (b.history?.length ? b.history.length - 1 : 0), (b.history?.length||1)-1));
    setIdx(j); setGhostIdx(null); setSearchMarks(searchIdx || []);
  };

  // --- ActionsContext binding ---
  const varsRef = useRef<Record<string, any>>({});
  const actionsCtx = useMemo(() => ({
    getIndex: () => idx,
    setIndex: (i: number) => setIdx(Math.max(0, Math.min(i, Math.max(0, timeline.length - 1)))) ,
    step: (d: number) => setIdx(i => Math.max(0, Math.min(i + (d|0), Math.max(0, timeline.length - 1)))) ,
    getMaxIndex: () => Math.max(0, timeline.length - 1),
    getTick: (i?: number) => timeline[Math.max(0, Math.min(i ?? idx, Math.max(0, timeline.length - 1)))]?.tick ?? (i ?? idx),
    setGhost: (i: number | null) => setGhostIdx(i == null ? null : Math.max(0, Math.min(i, Math.max(0, timeline.length - 1)))),
    addBookmark: (i: number, label?: string) => setBookmarks(b => [ ...b, { index: Math.max(0, Math.min(i, Math.max(0, timeline.length - 1))), label } ]),
    setSessionSearchQuery: (q: string) => { searchQueryRef.current = q; (window as any).__MPL_SET_SEARCH_QUERY?.(q); },
    saveToVault: (title: string, tags?: string[]) => { const meta = Vault.saveNew(bundleOf(), title, tags || []); console.debug('Saved', meta); },
    openSessionByTitle: (title: string, index?: number) => { const m = Vault.list().find(x => x.title === title); if (!m) return false; loadFromMeta(m, index ?? 0); return true; },
    toast: (msg: string) => { console.debug('[macro]', msg); },
    getVar: (k: string) => varsRef.current[k], setVar: (k: string, v: any) => { varsRef.current[k] = v; },
    // helper for built-in openFirstMatch
    getSearchSpace: () => ({ history: timeline, bookmarks, annotations, notes: monadNotes, watches, breakpoints }),
  }), [idx, timeline, bookmarks, annotations, monadNotes, watches, breakpoints]);

  // --- Keyboard dispatcher ---
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      const el = e.target as HTMLElement; const tag = (el?.tagName || '').toLowerCase();
      if (tag === 'input' || tag === 'textarea' || (el as any).isContentEditable) return;
      for (const kb of keymap) {
        if (!kb.enabled) continue; if (!matches(e, kb.combo)) continue; e.preventDefault();
        if (kb.target.kind === 'action') {
          const act = listActions().find(a => a.id === kb.target.id); if (act) act.run(actionsCtx as any, kb.target.args);
        } else {
          const m = macros.find(x => x.id === (kb.target as any).id); if (m) runMacro(actionsCtx as any, m);
        }
        break;
      }
    };
    window.addEventListener('keydown', onKey); return () => window.removeEventListener('keydown', onKey);
  }, [keymap, macros, actionsCtx]);

  // Provide a global hook so actions can set the search query (simple bridge)
  (window as any).__MPL_SET_SEARCH_QUERY = (q: string) => { /* SessionSearchPanel will override via effect */ };

  const onImport = (bundle: SessionBundle) => {
    setTimeline(bundle.history || []);
    setBookmarks(bundle.bookmarks || []);
    setAnnotations(bundle.annotations || []);
    setMonadNotes(bundle.monadNotes || []);
    setWatches((bundle as any).watches || []);
    setBreakpoints((bundle as any).breakpoints || []);
    setIdx(Math.max(0, (bundle.history?.length || 1) - 1));
    setGhostIdx(null);
  };

  // track last SessionSearchPanel query
  const setDefaultSearchQuery = (q: string) => { (window as any).__MPL_SET_SEARCH_QUERY?.(q); };
  const getKnobs = () => ({ /* currently wired from RuleStatsPanel in 3O; placeholders */ });
  const setKnobs = (_k: any) => {};

  return (
    <div className="mpl-debugger-panel">
      {/* Session I/O */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session I/O</header>
        <ImportExportPanel history={timeline} bookmarks={bookmarks} annotations={annotations} monadNotes={monadNotes} onImport={onImport} />
      </section>

      {/* Timeline */}
      {timeline.length > 0 && (
        <section className="mpl-section">
          <header className="mpl-section-h">Timeline</header>
          <TimeScrubber timeline={timeline} index={idx} onChangeIndex={setIdx} ghostIndex={ghostIdx} onChangeGhostIndex={setGhostIdx} bookmarks={bookmarks} annotations={annotations} ruleMarks={ruleMarks} heatValues={heatStrip} bpMarks={bpMarks} searchMarks={searchMarks} />
        </section>
      )}

      {/* Macros */}
      <section className="mpl-section">
        <header className="mpl-section-h">Macros</header>
        <MacrosPanel macros={macros} onChange={setMacros} actionsCtx={actionsCtx} />
      </section>

      {/* Presets */}
      <section className="mpl-section">
        <header className="mpl-section-h">Presets</header>
        <PresetsPanel getWatches={() => watches} setWatches={setWatches as any} setDefaultSearchQuery={setDefaultSearchQuery} getKnobs={getKnobs} setKnobs={setKnobs} />
      </section>

      {/* Keyboard */}
      <section className="mpl-section">
        <header className="mpl-section-h">Keyboard</header>
        <KeymapPanel keymap={keymap} onChange={setKeymap} macros={macros.map(m => ({ id: m.id, label: m.label }))} />
      </section>

      {/* Search + Diffs + Watches */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session Search</header>
        <SessionSearchPanel history={timeline} bookmarks={bookmarks} annotations={annotations} notes={monadNotes} watches={watches} breakpoints={breakpoints} onGoToIndex={setIdx} onMarksChange={setSearchMarks} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">State Diffs</header>
        <DiffPanel ghost={ghost} current={current} indexA={ghostIdx} indexB={idx} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Watches</header>
        <WatchesPanel history={timeline} indexB={idx} indexA={ghostIdx} watches={watches} onChange={setWatches} />
      </section>

      {/* Rule tools */}
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Stats</header>
        <RuleStatsPanel history={timeline} onSelectRuleForHeat={() => {}} onSetHeatWindow={() => {}} onSetHeatNormalize={() => {}} onSetHeatStrip={setHeatStrip} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Log</header>
        <RuleLogPanel history={timeline} onGoToIndex={setIdx} onPinGhost={setGhostIdx} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} onMarksChange={setRuleMarks} />
      </section>

      {/* Notes/Annotations/Bookmarks */}
      <section className="mpl-section">
        <header className="mpl-section-h">Node Notes</header>
        <NodeNotesPanel currentIndex={idx} currentTick={current?.tick ?? idx} selectedMonadId={selectedMonadId ?? undefined} notes={monadNotes} onChange={setMonadNotes} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Annotations</header>
        <AnnotationsPanel currentIndex={idx} currentTick={current?.tick ?? idx} maxIndex={Math.max(0, timeline.length - 1)} annotations={annotations} onChange={setAnnotations} onGoToIndex={setIdx} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Bookmarks</header>
        <BookmarksPanel currentIndex={idx} currentTick={current?.tick ?? idx} bookmarks={bookmarks} onChange={setBookmarks} onGoToIndex={setIdx} />
      </section>

      {/* State */}
      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        {current ? (
          <StateViewer history={timeline} index={idx} snapshot={current} ghostSnapshot={ghost} monadNotes={monadNotes.filter(n => n.index === idx)} selectedMonadId={selectedMonadId} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} />
        ) : (
          <div className="mpl-empty">No snapshot available</div>
        )}
      </section>
    </div>
  );
};
```

---

## 9) `playground/styles/debugger.css` (additions)

```css
/* Stage 3U ‚Äî Macros/Presets/Keymap */
.mpl-macros { display: grid; gap: 8px; }
.mpl-macros-body { display: grid; grid-template-columns: 260px 1fr; gap: 10px; }
.mpl-macro-list { list-style: none; padding: 0; margin: 0; display: grid; gap: 6px; }
.mpl-macro-list li { border: 1px solid #e5e7eb; border-radius: 10px; padding: 6px 8px; background: #fff; display: grid; grid-template-columns: 10px 1fr auto auto; gap: 8px; align-items: center; }
.mpl-macro-list li.active { box-shadow: 0 0 0 2px #d8b4fe inset; }
.mpl-macro-editor .mpl-steps textarea { width: 100%; height: 64px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

.mpl-presets-bar, .mpl-km-add { display: grid; grid-template-columns: 1fr auto 1fr auto; gap: 8px; align-items: center; }
.mpl-presets-list { display: grid; gap: 8px; }
.mpl-card-row { border: 1px solid #e5e7eb; border-radius: 10px; background: #fff; padding: 8px; display: grid; grid-template-columns: 1fr auto; align-items: center; }

.mpl-keymap { display: grid; gap: 8px; }
.mpl-km-table input { width: 100%; }
```

---

## 10) Example ‚Äî `playground/pages/DebugExample3U.tsx`

```tsx
// playground/pages/DebugExample3U.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3U() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B", sourceId: "B", targetId: "C" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"], active: true }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3U ‚Äî Macro Actions + Presets + Keyboard Maps</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 11) Quick starter macros

* **Jump A‚ÜíB**: Step to next index, set ghost=A, add bookmark.

```json
{"label":"Ghost & mark","steps":[{"action":"setGhost","args":{"index":"${index}"}},{"action":"step","args":{"delta":1}},{"action":"addBookmark","args":{"label":"A‚ÜíB"}}]}
```

* **Save snapshot**: Save session to Vault with timestamp.

```json
{"label":"Quick save","steps":[{"action":"saveVault","args":{"title":"Quick @ ${tick}","tags":["quick"]}}]}
```

* **Open first match**: Jump to first index where rule `R1` fires on monad A.

```json
{"label":"Open R1@A","steps":[{"action":"openFirstMatch","args":{"query":"rule:R1 monad:A"}}]}
```

---

## 12) Notes

* **Safety**: Actions are explicit and sandboxed; macros never `eval` user code.
* **Focus rules**: Keyboard handler ignores events when typing in inputs/textarea/contentEditable.
* **Search bridge**: `SessionSearchPanel` exposes a tiny global setter so macros can programmatically set queries without refs.
* **Extensibility**: Add new actions by `registerAction({ id, label, run })`; they become available in MacrosPanel and KeymapPanel instantly.

---

## 13) Changelog ‚Äî Stage 3U

* New engine: `macro.ts`, `actions.builtins.ts`, `presets.ts`, `keymap.ts`
* New UI: `MacrosPanel.tsx`, `PresetsPanel.tsx`, `KeymapPanel.tsx`
* Debugger: integrated actions context + keyboard dispatcher
* CSS: layouts for macros, presets, keymap

```
```
