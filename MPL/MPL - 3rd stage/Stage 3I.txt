# MPL Playground — Stage 3I Patch (Graphical State Tree View)

This patch delivers **Stage 3I** for the MPL (Monad Programming Language) Playground: a live **Graphical State Tree/Graph View** with pan/zoom, active‑monad highlighting, and a Table/Graph toggle. It is designed to drop into your existing repo without breaking current behavior.

> **What’s included**
>
> * New graph types and conversion utilities
> * A performant, dependency‑free SVG **Graph View**
> * A unified **State Viewer** with **Table | Graph** toggle
> * Minimal CSS additions
> * Type‑safe interfaces and non‑invasive integration points

> **How to integrate**
>
> 1. Copy files into the paths shown below.
> 2. If your project uses different paths/namespaces, adjust the imports accordingly.
> 3. Render `<StateViewer snapshot={currentSnapshot} />` anywhere you currently show debug state. (See **Wiring** at the end.)
>
> **Zero external deps**: No D3 or other graph libs required. If you want D3 later, this architecture makes it easy to swap the layout.

---

## 1) `engine/debugger/graphTypes.ts`

```ts
// engine/debugger/graphTypes.ts
// Stage 3I — shared graph + snapshot types

export type MonadId = string | number;

export interface MonadState {
  id: MonadId;
  position?: { x: number; y: number }; // optional physical location if engine tracks it
  neighbors?: MonadId[];                // optional neighbor topology
  data?: Record<string, unknown>;       // arbitrary monad payload
  active?: boolean;                     // true if currently focused or breakpoint target
}

export interface RuleFire {
  ruleId: string;
  at: number;        // tick/time index
  monadId: MonadId;
}

export interface ExecutionSnapshot {
  tick: number;                  // current tick/step
  monads: MonadState[];          // all monads this tick
  rulesFired?: RuleFire[];       // rules that fired at this tick
  focusMonadId?: MonadId | null; // optional explicit focus override
}

export interface GraphNode {
  id: string;        // stringified monad id
  label?: string;    // optional label (defaults to id)
  x: number;         // layout position in graph space
  y: number;
  radius: number;    // display radius
  active?: boolean;  // highlight flag
  data?: Record<string, unknown>;
}

export interface GraphEdge {
  id: string;        // `${source}->${target}`
  source: string;    // node id
  target: string;    // node id
}

export interface GraphData {
  nodes: GraphNode[];
  edges: GraphEdge[];
}
```

---

## 2) `engine/debugger/toGraph.ts`

```ts
// engine/debugger/toGraph.ts
// Stage 3I — convert an ExecutionSnapshot into GraphData with a simple radial/grid fallback layout.

import { ExecutionSnapshot, GraphData, GraphEdge, GraphNode, MonadState } from "./graphTypes";

/** Layout options for the graph builder */
export interface LayoutOptions {
  /** If true and positions are missing, use a radial layout around the centroid */
  radialFallback?: boolean;
  /** Base radius for nodes (px) */
  nodeRadius?: number;
  /** Spacing multiplier used by fallback layout */
  spacing?: number;
}

const DEFAULTS: Required<LayoutOptions> = {
  radialFallback: true,
  nodeRadius: 14,
  spacing: 60,
};

/** Ensure string id */
function sid(id: string | number): string {
  return typeof id === "string" ? id : String(id);
}

/** Build edges from neighbors, deduping undirected pairs */
function buildEdges(monads: MonadState[]): GraphEdge[] {
  const seen = new Set<string>();
  const edges: GraphEdge[] = [];
  for (const m of monads) {
    if (!m.neighbors) continue;
    for (const n of m.neighbors) {
      const a = sid(m.id);
      const b = sid(n);
      const key = a < b ? `${a}->${b}` : `${b}->${a}`;
      if (seen.has(key)) continue;
      seen.add(key);
      edges.push({ id: key, source: a, target: b });
    }
  }
  return edges;
}

/**
 * Simple deterministic radial layout if positions are missing.
 * Places nodes on concentric rings sized by sqrt(N).
 */
function radialLayout(monads: MonadState[], spacing: number): { [id: string]: { x: number; y: number } } {
  const n = monads.length;
  if (n === 0) return {};

  // Determine ring counts: ~sqrt(n) per ring
  const perRing = Math.max(1, Math.round(Math.sqrt(n)));
  const positions: { [id: string]: { x: number; y: number } } = {};

  let ring = 0;
  let placed = 0;
  while (placed < n) {
    const remaining = n - placed;
    const count = Math.min(perRing, remaining);
    const radius = spacing * (ring + 1);
    for (let i = 0; i < count; i++) {
      const angle = (2 * Math.PI * i) / count + (ring % 2 === 1 ? Math.PI / count : 0);
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      const m = monads[placed + i];
      positions[sid(m.id)] = { x, y };
    }
    placed += count;
    ring++;
  }

  return positions;
}

export function buildGraphFromSnapshot(s: ExecutionSnapshot, opts?: LayoutOptions): GraphData {
  const o = { ...DEFAULTS, ...(opts || {}) };
  const nodes: GraphNode[] = [];

  // Use existing positions when provided; otherwise compute a fallback
  const hasPositions = s.monads.some(m => !!m.position);
  const fallbackPositions = hasPositions ? {} : radialLayout(s.monads, o.spacing);

  for (const m of s.monads) {
    const id = sid(m.id);
    const pos = m.position || fallbackPositions[id] || { x: 0, y: 0 };
    nodes.push({
      id,
      label: id,
      x: pos.x,
      y: pos.y,
      radius: o.nodeRadius,
      active: !!(m.active || (s.focusMonadId != null && sid(s.focusMonadId) === id)),
      data: m.data || {},
    });
  }

  const edges = buildEdges(s.monads);
  return { nodes, edges };
}
```

---

## 3) `playground/components/GraphStateView.tsx`

```tsx
// playground/components/GraphStateView.tsx
// Stage 3I — Dependency‑free SVG graph renderer with pan/zoom + active highlighting

import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { ExecutionSnapshot, GraphData } from "../../engine/debugger/graphTypes";
import { buildGraphFromSnapshot } from "../../engine/debugger/toGraph";

interface GraphStateViewProps {
  snapshot: ExecutionSnapshot;
  width?: number;   // optional fixed size; falls back to container measure
  height?: number;
  onSelectMonad?: (id: string) => void;
  /** If true, dims non-neighbor nodes of the focused monad */
  neighborFocusMode?: boolean;
}

function useMeasure(ref: React.RefObject<HTMLElement>) {
  const [size, setSize] = useState<{ width: number; height: number }>({ width: 300, height: 200 });
  useEffect(() => {
    if (!ref.current) return;
    const ro = new ResizeObserver(([entry]) => {
      const cr = entry.contentRect;
      setSize({ width: cr.width, height: cr.height });
    });
    ro.observe(ref.current);
    return () => ro.disconnect();
  }, [ref]);
  return size;
}

export const GraphStateView: React.FC<GraphStateViewProps> = ({ snapshot, width, height, onSelectMonad, neighborFocusMode }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const size = useMeasure(containerRef);
  const W = width ?? size.width ?? 600;
  const H = height ?? size.height ?? 400;

  const graph: GraphData = useMemo(() => buildGraphFromSnapshot(snapshot, { nodeRadius: 14, spacing: 80 }), [snapshot]);

  // Pan/Zoom state
  const [zoom, setZoom] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const dragRef = useRef<{ x: number; y: number } | null>(null);

  const onWheel = useCallback((e: React.WheelEvent) => {
    e.preventDefault();
    const delta = -e.deltaY;
    const factor = Math.exp(delta * 0.001);
    setZoom(z => {
      const nz = Math.min(4, Math.max(0.25, z * factor));
      return nz;
    });
  }, []);

  const onMouseDown = useCallback((e: React.MouseEvent) => {
    dragRef.current = { x: e.clientX, y: e.clientY };
  }, []);

  const onMouseMove = useCallback((e: React.MouseEvent) => {
    if (!dragRef.current) return;
    const dx = e.clientX - dragRef.current.x;
    const dy = e.clientY - dragRef.current.y;
    dragRef.current = { x: e.clientX, y: e.clientY };
    setOffset(o => ({ x: o.x + dx, y: o.y + dy }));
  }, []);

  const onMouseUp = useCallback(() => { dragRef.current = null; }, []);

  // Neighbor focus: compute visible set if enabled
  const neighborSet = useMemo(() => {
    if (!neighborFocusMode) return null as null | Set<string>;
    const focusId = snapshot.focusMonadId != null ? String(snapshot.focusMonadId) : (graph.nodes.find(n => n.active)?.id ?? null);
    if (!focusId) return null;

    const directNeighbors = new Set<string>();
    for (const e of graph.edges) {
      if (e.source === focusId) directNeighbors.add(e.target);
      if (e.target === focusId) directNeighbors.add(e.source);
    }
    directNeighbors.add(focusId);
    return directNeighbors;
  }, [neighborFocusMode, graph, snapshot.focusMonadId]);

  return (
    <div ref={containerRef} className="mpl-graph-container" style={{ width: width ? `${width}px` : "100%", height: height ? `${height}px` : "100%" }}>
      <svg
        className="mpl-graph-svg"
        width={W}
        height={H}
        onWheel={onWheel}
        onMouseDown={onMouseDown}
        onMouseMove={onMouseMove}
        onMouseUp={onMouseUp}
      >
        <defs>
          <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
            <path d="M0,0 L0,6 L6,3 z" />
          </marker>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="coloredBlur" />
            <feMerge>
              <feMergeNode in="coloredBlur" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>

        <g transform={`translate(${W / 2 + offset.x}, ${H / 2 + offset.y}) scale(${zoom})`}>
          {/* Edges */}
          {graph.edges.map(e => {
            const a = graph.nodes.find(n => n.id === e.source)!;
            const b = graph.nodes.find(n => n.id === e.target)!;
            const dimmed = neighborSet && !(neighborSet.has(a.id) && neighborSet.has(b.id));
            return (
              <line
                key={e.id}
                x1={a.x}
                y1={a.y}
                x2={b.x}
                y2={b.y}
                className={`mpl-edge ${dimmed ? "mpl-dim" : ""}`}
              />
            );
          })}

          {/* Nodes */}
          {graph.nodes.map(n => {
            const dimmed = neighborSet && !neighborSet.has(n.id);
            return (
              <g key={n.id} transform={`translate(${n.x}, ${n.y})`} className="mpl-node" onClick={() => onSelectMonad?.(n.id)}>
                <circle r={n.radius} className={`mpl-node-circle ${n.active ? "mpl-node-active" : ""} ${dimmed ? "mpl-dim" : ""}`} filter={n.active ? "url(#glow)" : undefined} />
                <text className={`mpl-node-label ${dimmed ? "mpl-dim" : ""}`} y={n.radius + 14} textAnchor="middle">{n.label ?? n.id}</text>
              </g>
            );
          })}
        </g>
      </svg>
    </div>
  );
};
```

---

## 4) `playground/components/StateViewer.tsx`

```tsx
// playground/components/StateViewer.tsx
// Stage 3I — Unified state viewer with Table | Graph toggle

import React, { useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { GraphStateView } from "./GraphStateView";

interface StateViewerProps {
  snapshot: ExecutionSnapshot;
  onSelectMonad?: (id: string) => void;
}

type ViewMode = "table" | "graph";

export const StateViewer: React.FC<StateViewerProps> = ({ snapshot, onSelectMonad }) => {
  const [mode, setMode] = useState<ViewMode>("table");
  const [neighborOnly, setNeighborOnly] = useState(false);

  const rows = useMemo(() => {
    return snapshot.monads.map(m => ({
      id: String(m.id),
      neighbors: m.neighbors?.length ?? 0,
      active: !!(m.active || (snapshot.focusMonadId != null && String(snapshot.focusMonadId) === String(m.id))),
    }));
  }, [snapshot]);

  return (
    <div className="mpl-state-viewer">
      <div className="mpl-toolbar">
        <div className="mpl-seg">
          <button className={`mpl-btn ${mode === "table" ? "active" : ""}`} onClick={() => setMode("table")}>Table</button>
          <button className={`mpl-btn ${mode === "graph" ? "active" : ""}`} onClick={() => setMode("graph")}>Graph</button>
        </div>
        {mode === "graph" && (
          <label className="mpl-check">
            <input type="checkbox" checked={neighborOnly} onChange={e => setNeighborOnly(e.target.checked)} />
            Neighbor focus
          </label>
        )}
      </div>

      {mode === "table" ? (
        <div className="mpl-table-wrap">
          <table className="mpl-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Neighbors</th>
                <th>Active</th>
              </tr>
            </thead>
            <tbody>
              {rows.map(r => (
                <tr key={r.id} onClick={() => onSelectMonad?.(r.id)} className={r.active ? "mpl-row-active" : undefined}>
                  <td>{r.id}</td>
                  <td>{r.neighbors}</td>
                  <td>{r.active ? "●" : ""}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="mpl-graph-wrap">
          <GraphStateView snapshot={snapshot} onSelectMonad={onSelectMonad} neighborFocusMode={neighborOnly} />
        </div>
      )}
    </div>
  );
};
```

---

## 5) `playground/components/DebuggerPanel.tsx` (excerpt to integrate toggle + viewer)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3I — Add the StateViewer with table/graph toggle

import React from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";

interface DebuggerPanelProps {
  snapshot: ExecutionSnapshot; // current tick snapshot from engine
  onFocusMonad?: (id: string) => void;
}

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, onFocusMonad }) => {
  return (
    <div className="mpl-debugger-panel">
      {/* ...existing controls (run/step/breakpoints/etc.)... */}

      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        <StateViewer snapshot={snapshot} onSelectMonad={onFocusMonad} />
      </section>
    </div>
  );
};
```

> **Note**: If your existing `DebuggerPanel` already renders a `StateViewer`, replace it with this one or merge the toggle logic.

---

## 6) `playground/styles/debugger.css` (additions)

```css
/* Stage 3I — Minimal styles */
.mpl-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 8px 0;
}
.mpl-seg { display: inline-flex; border: 1px solid var(--border, #ddd); border-radius: 10px; overflow: hidden; }
.mpl-btn { padding: 6px 12px; border: none; background: #f5f5f7; cursor: pointer; font-size: 13px; }
.mpl-btn.active { background: #111; color: #fff; }
.mpl-check { display: inline-flex; gap: 8px; align-items: center; font-size: 13px; }

.mpl-table-wrap { max-height: 320px; overflow: auto; border: 1px solid #e5e5e5; border-radius: 8px; }
.mpl-table { width: 100%; border-collapse: collapse; font-size: 13px; }
.mpl-table th, .mpl-table td { padding: 8px 10px; border-bottom: 1px solid #eee; text-align: left; }
.mpl-row-active { background: #fffbdd; }

.mpl-graph-wrap { height: 420px; border: 1px solid #e5e5e5; border-radius: 8px; }
.mpl-graph-container { width: 100%; height: 100%; }
.mpl-graph-svg { width: 100%; height: 100%; background: #fff; }

.mpl-edge { stroke: #c7c7d0; stroke-width: 1.2; }
.mpl-node-circle { fill: #ececff; stroke: #7676ff; stroke-width: 1.2; }
.mpl-node-active { stroke: #111; stroke-width: 2; }
.mpl-node-label { font-size: 10px; fill: #333; }
.mpl-dim { opacity: 0.25; }
```

---

## 7) Optional: wiring helper (if you don’t already expose a snapshot)

If your engine exposes a time‑indexed state history, create a selector like so:

```ts
// engine/debugger/selectors.ts
import { ExecutionSnapshot, MonadState } from "./graphTypes";

export function makeSnapshot(tick: number, monads: MonadState[], rules: { ruleId: string; monadId: string | number }[], focus?: string | number | null): ExecutionSnapshot {
  return {
    tick,
    monads,
    rulesFired: rules.map(r => ({ ruleId: r.ruleId, at: tick, monadId: r.monadId })),
    focusMonadId: focus ?? null,
  };
}
```

---

## 8) Example usage (temporary; remove in production)

```tsx
// playground/pages/DebugExample.tsx
import React, { useMemo } from "react";
import { StateViewer } from "../components/StateViewer";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample() {
  const snapshot: ExecutionSnapshot = useMemo(() => ({
    tick: 12,
    monads: [
      { id: "A", neighbors: ["B", "C"], active: true },
      { id: "B", neighbors: ["A", "C"] },
      { id: "C", neighbors: ["A", "B", "D"] },
      { id: "D", neighbors: ["C"] },
    ],
    focusMonadId: "A",
  }), []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3I — Graph State View</h1>
      <StateViewer snapshot={snapshot} onSelectMonad={(id) => console.log("select", id)} />
    </div>
  );
}
```

---

## 9) Notes and extension hooks

* **Rule Overlay (Stage 3J)**: Add per‑node badges for last‑fired rule; edges can pulse when a transfer rule triggers.
* **Time Travel (Stage 3K)**: Keep `ExecutionSnapshot[]` and connect a scrubber to resupply `snapshot`.
* **Import/Export (Stage 3L)**: Serialize `ExecutionSnapshot` with `JSON.stringify` + download link.
* **Custom Layouts**: Replace `radialLayout` with force or grid; the renderer is agnostic as long as `GraphData` is provided.
* **Performance**: For very large graphs, swap SVG for Canvas (same API possible) or virtualize labels.

---

## 10) Changelog — Stage 3I

* Added `engine/debugger/graphTypes.ts` with shared types
* Added `engine/debugger/toGraph.ts` for snapshot→graph conversion
* New `GraphStateView` SVG renderer (pan/zoom, glow for active)
* Upgraded `StateViewer` with Table | Graph toggle and neighbor focus mode
* Minimal CSS augmentations under `.mpl-*` namespace

---

## 11) Wiring

Where you already compute or log state each tick, construct an `ExecutionSnapshot` and pass it down:

```tsx
<DebuggerPanel snapshot={currentSnapshot} onFocusMonad={(id) => setFocus(id)} />
```

If your engine already maintains focus/active monad, set `focusMonadId` accordingly; otherwise toggle `monad.active` on the focused item.

That’s it — Stage **3I** is ready. Paste these files and you’ll have a live Graph View with interaction.
