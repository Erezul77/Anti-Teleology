# MPL – Stage 3H (Seekable Traces: Random Access via HTTP Range + Keyframes)

Stage **3H** makes **.mpltrace** playable from a **URL** with **instant seek**. We add:

* **Keyframes** (periodic full frames) in the recorder
* A **byte‑offset index** (`.mplidx`) mapping each frame to **\[offset,length]**
* A **remote replay** that fetches only the bytes it needs using **HTTP Range**
* A tiny **Range‑enabled static server** (Node) for local testing

This builds on **3G** (delta frames + compression). For reliable random access, 3H recommends **schema v1.2** with a **keyframe interval** so the viewer can jump to the nearest keyframe and apply a short delta chain.

> Note: Random access is straightforward on **uncompressed NDJSON** (no `Content‑Encoding`). If you serve with on‑the‑fly gzip, the index must match the compressed byte stream. To keep things simple, serve traces **without** `Content‑Encoding` or pre‑compress to a block format that supports indexing. 3H defaults to **identity** encoding.

---

## Directory Tree (delta)

```
MPL-Stage-3/
├─ package.json
├─ README.md
├─ server/
│  └─ range-static.ts          # NEW: tiny static file server w/ Accept-Ranges
├─ src/
│  ├─ trace/
│  │  ├─ schema.ts             # UPDATED: v1.2 (keyint)
│  │  ├─ record.ts             # UPDATED: periodic keyframes
│  │  ├─ index-types.ts        # NEW: index JSON types
│  │  ├─ build-index.ts        # NEW: Node CLI to produce .mplidx
│  │  ├─ remote.ts             # NEW: fetch-by-range reader + keyframe seek
│  │  └─ ndjson-range.ts       # NEW: helpers for byte-range fetch
│  └─ web/
│     └─ seek-main.ts          # NEW: Remote seekable replay UI
└─ index-3h-seek.html          # NEW: Stage 3H launcher
```

Add to **package.json**:

```json
{
  "scripts": {
    "serve:range": "tsx server/range-static.ts ./public 5173",
    "build:3h:index": "tsx src/trace/build-index.ts",
    "dev:3h": "vite --open index-3h-seek.html"
  },
  "devDependencies": {
    "tsx": "^4.19.0"
  }
}
```

> You can still use `vite` to serve the UI files; use `serve:range` to host large `.mpltrace` files with proper **Range** support if your default dev server is not exposing raw files.

---

## src/trace/schema.ts (UPDATED — v1.2 adds keyframe interval)

```ts
export type TraceInit = {
  type: 'init';
  schema: 'mpl-trace@1' | 'mpl-trace@1.1' | 'mpl-trace@1.2';
  width: number; height: number; rule: string;
  topology: 'Moore' | 'VonNeumann'; edges: 'Wrap' | 'Clip';
  seed: number; engine: 'GPU' | 'CPU' | 'Workers';
  tile?: { w: number; h: number };
  notes?: string;
  enc?: 'full' | 'delta-xor';        // default encoding (3G)
  comp?: 'none' | 'gzip';             // transport compression hint
  keyint?: number;                    // NEW: keyframe interval in frames (0/undefined = none)
};

export type TraceFrame = {
  type: 'frame';
  step: number; pop: number; bbox?: { x0:number;y0:number;x1:number;y1:number };
  rle_b64?: string;                    // full frame (v1/1.1)
  payload_b64?: string;                // delta payload (v1.1/1.2)
  enc?: 'full' | 'delta-xor';
  comp?: 'none' | 'gzip';
};

export type TraceNote = { type:'note'; step:number; text:string };
export type TraceEvent = TraceInit | TraceFrame | TraceNote;
```

---

## src/trace/record.ts (UPDATED — periodic keyframes)

```ts
import { rleEncode, b64 } from './rle.js';
import { encodeDelta, toB64 } from './delta.js';
import type { TraceInit, TraceFrame } from './schema.js';

export type SnapshotSource = { width:number; height:number; readFull(): Promise<Uint8Array>|Uint8Array; stats?(buf:Uint8Array):{pop:number; bbox?:{x0:number;y0:number;x1:number;y1:number}} };

export class Recorder {
  private step = 0; private nextCapture = 0; private prev?: Uint8Array;
  constructor(private src: SnapshotSource, private init: TraceInit, private interval=10){ }

  async captureIfNeeded(writer: { write(o:any): void }){
    if (this.step === 0){ writer.write({ ...this.init, schema: this.init.schema ?? 'mpl-trace@1.2' }); }
    if (this.step >= this.nextCapture){
      const buf = await this.src.readFull();
      const { pop, bbox } = this.src.stats? this.src.stats(buf) : { pop: buf.reduce((a,b)=>a+(b&1),0) } as any;
      const keyint = this.init.keyint ?? 0;
      const forceKey = keyint>0 && (this.step % keyint === 0);
      const useDelta = !forceKey && (this.init.enc ?? 'delta-xor') === 'delta-xor' && this.prev;
      let frame: TraceFrame;
      if (useDelta){
        const rle = encodeDelta(this.prev!, buf, this.src.width, this.src.height);
        frame = { type:'frame', step:this.step, pop, bbox, payload_b64: toB64(rle), enc:'delta-xor', comp: this.init.comp ?? 'none' };
      } else {
        const rle = rleEncode(buf, this.src.width, this.src.height);
        frame = { type:'frame', step:this.step, pop, bbox, rle_b64: b64(rle), enc:'full', comp: this.init.comp ?? 'none' };
      }
      writer.write(frame); this.prev = buf; this.nextCapture += this.interval;
    }
    this.step++;
  }
}
```

---

## src/trace/index-types.ts (NEW)

```ts
export type TraceIndex = {
  schema: 'mpl-trace-index@1';
  traceUrl?: string;          // optional hint
  fileSize: number;           // bytes
  initOffset: number;         // byte offset of init line
  frames: Array<{ step:number; offset:number; length:number; key:boolean }>;
};
```

---

## src/trace/build-index.ts (NEW — Node CLI to create .mplidx)

```ts
#!/usr/bin/env tsx
import fs from 'node:fs';
import path from 'node:path';
import { TraceIndex } from './index-types.js';

const inPath = process.argv[2];
if (!inPath) { console.error('Usage: tsx src/trace/build-index.ts <trace.ndjson> [out.mplidx]'); process.exit(1); }
const outPath = process.argv[3] || (inPath + '.mplidx');

const fd = fs.openSync(inPath, 'r');
const stat = fs.statSync(inPath);
const buf = Buffer.alloc(1<<20); // 1MB chunk
let pos = 0; let lineStart = 0; let leftover = Buffer.alloc(0);

const frames: TraceIndex['frames'] = []; let initOffset = -1;

while (pos < stat.size){
  const toRead = Math.min(buf.length, stat.size - pos);
  fs.readSync(fd, buf, 0, toRead, pos);
  let block = Buffer.concat([leftover, buf.slice(0, toRead)]);
  let idx: number;
  while ((idx = block.indexOf(0x0a)) !== -1){ // '\n'
    const line = block.slice(0, idx).toString('utf8');
    const start = lineStart; const length = idx + 1; // include '\n'
    try {
      const obj = JSON.parse(line);
      if (obj.type === 'init'){ initOffset = start; }
      if (obj.type === 'frame'){
        const key = (obj.enc === 'full') || !!obj.rle_b64;
        frames.push({ step: obj.step, offset: start, length, key });
      }
    } catch {}
    lineStart += length; block = block.slice(idx+1);
  }
  leftover = block; pos += toRead;
}
fs.closeSync(fd);

if (initOffset < 0) throw new Error('init not found');
const index: TraceIndex = { schema: 'mpl-trace-index@1', fileSize: stat.size, initOffset, frames };
fs.writeFileSync(outPath, JSON.stringify(index, null, 2));
console.log('wrote', outPath);
```

---

## src/trace/ndjson-range.ts (NEW — byte‑range helpers)

```ts
export async function fetchRange(url: string, start: number, length: number): Promise<string> {
  const end = start + length - 1;
  const resp = await fetch(url, { headers: { 'Range': `bytes=${start}-${end}` } });
  if (!resp.ok && resp.status !== 206) throw new Error('Range fetch failed: ' + resp.status);
  return await resp.text();
}
```

---

## src/trace/remote.ts (NEW — remote reader + keyframe seek)

```ts
import { TraceIndex } from './index-types.js';
import type { TraceInit, TraceFrame } from './schema.js';
import { fetchRange } from './ndjson-range.js';
import { unb64, rleDecode } from './rle.js';
import { fromB64, decodeDelta } from './delta.js';

export class RemoteTrace {
  private idx!: TraceIndex; private init!: TraceInit; private url!: string; private cache = new Map<number, TraceFrame>();
  constructor(private traceUrl: string, private indexUrl?: string){ this.url = traceUrl; }

  async load(){
    const idxUrl = this.indexUrl || (this.traceUrl + '.mplidx');
    this.idx = await (await fetch(idxUrl)).json();
    // read init line
    const initText = await fetchRange(this.url, this.idx.initOffset, 1<<18); // 256KB safety for long init
    this.init = JSON.parse(initText.split(/\n/)[0]);
    return this.init;
  }

  getInit(){ return this.init; }
  frameCount(){ return this.idx.frames.length; }
  frameMeta(i:number){ return this.idx.frames[i]; }

  async getFrame(i:number): Promise<TraceFrame>{
    if (this.cache.has(i)) return this.cache.get(i)!;
    const meta = this.idx.frames[i];
    const line = await fetchRange(this.url, meta.offset, meta.length);
    const obj = JSON.parse(line) as TraceFrame; this.cache.set(i, obj); return obj;
  }

  /**
   * Decode grid for frame i by jumping to nearest keyframe and walking forward.
   */
  async materializeGrid(i:number): Promise<Uint8Array>{
    if (i<0 || i>=this.idx.frames.length) throw new Error('index');
    // find nearest keyframe <= i
    let k=i; while (k>0 && !this.idx.frames[k].key) k--;
    let f = await this.getFrame(k);
    if (!(f.rle_b64 || f.enc==='full')) throw new Error('first frame not key');
    let grid = rleDecode(unb64(f.rle_b64!), this.init.width, this.init.height);
    for (let j=k+1;j<=i;j++){
      const fj = await this.getFrame(j);
      if (fj.payload_b64){
        grid = decodeDelta(grid, fromB64(fj.payload_b64), this.init.width, this.init.height);
      } else if (fj.rle_b64){
        grid = rleDecode(unb64(fj.rle_b64), this.init.width, this.init.height);
      } else {
        throw new Error('bad frame');
      }
    }
    return grid;
  }
}
```

---

## src/web/seek-main.ts (NEW — remote seek UI)

```ts
import { RemoteTrace } from '../trace/remote.js';
import { TiledRenderer } from '../render/tiled-renderer.js';

const $=<T extends HTMLElement>(id:string)=> document.getElementById(id) as T;
const urlInp=$('url') as HTMLInputElement; const idxInp=$('idx') as HTMLInputElement; const loadBtn=$('load');
const playBtn=$('play'); const stepBtn=$('step'); const seekInp=$('seek') as HTMLInputElement; const info=$('info');
const canvas = document.getElementById('grid') as HTMLCanvasElement;

let rt: RemoteTrace|null = null; let playing=false; let view={x:0,y:0,zoom:4}; let frame=0;
let renderer: TiledRenderer;

function cellsSourceFrom(buf: Uint8Array, W:number, H:number){
  return { gridW:W, gridH:H, version: ()=> 1, readRect: (x0:number,y0:number,x1:number,y1:number)=>{ const w=x1-x0, h=y1-y0; const out=new Uint8Array(w*h); for(let y=0;y<h;y++){ out.set(buf.slice((y0+y)*W+x0, (y0+y)*W+x0+w), y*w); } return out; } };
}

async function load(){
  rt = new RemoteTrace(urlInp.value.trim(), idxInp.value.trim() || undefined);
  const init = await rt.load();
  seekInp.max = String(rt.frameCount()-1); seekInp.value='0'; frame=0;
  renderer = new TiledRenderer(canvas, cellsSourceFrom(new Uint8Array(init.width*init.height), init.width, init.height), 64, 64);
  info!.textContent = `${init.width}×${init.height} rule=${init.rule} keyint=${init.keyint ?? 0}`;
}

async function goto(f:number){
  if (!rt) return; frame = Math.max(0, Math.min(rt.frameCount()-1, f));
  const grid = await rt.materializeGrid(frame);
  (renderer as any).setSource(cellsSourceFrom(grid, (rt as any).getInit().width, (rt as any).getInit().height));
  await renderer.draw(view, 128);
  const meta = rt.frameMeta(frame); info!.textContent = `frame ${frame} (step ${meta.step})`;
}

async function step(){ await goto(frame+1); }
function loop(){ if(!playing) return; step().then(()=> requestAnimationFrame(loop)); }

loadBtn.addEventListener('click', ()=> load());
seekInp.addEventListener('input', ()=> goto(Number(seekInp.value)));
playBtn.addEventListener('click', ()=>{ playing=!playing; playBtn!.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); });
stepBtn.addEventListener('click', ()=>{ if(!playing) step(); });

// Pan/zoom
let dragging=false, lastX=0, lastY=0; canvas.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener('mouseup', ()=> dragging=false);
window.addEventListener('mousemove', e=>{ if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; view.x=Math.max(0,view.x-dx/view.zoom); view.y=Math.max(0,view.y-dy/view.zoom); });
canvas.addEventListener('wheel', e=>{ e.preventDefault(); const factor=e.deltaY<0?1.1:0.9; view.zoom=Math.max(1,Math.min(32,view.zoom*factor)); }, { passive:false });
```

---

## server/range-static.ts (NEW — minimal range server)

```ts
#!/usr/bin/env tsx
import http from 'node:http';
import fs from 'node:fs';
import path from 'node:path';

const root = process.argv[2] || '.'; const port = Number(process.argv[3]||5173);

const server = http.createServer((req, res) => {
  const url = new URL(req.url || '/', `http://${req.headers.host}`);
  const filePath = path.join(root, decodeURIComponent(url.pathname));
  if (!fs.existsSync(filePath) || fs.statSync(filePath).isDirectory()){
    res.writeHead(404).end('Not found'); return;
  }
  const stat = fs.statSync(filePath);
  res.setHeader('Accept-Ranges', 'bytes');
  const range = req.headers.range;
  if (range){
    const m = /bytes=(\d+)-(\d+)?/.exec(range);
    if (!m){ res.writeHead(416).end(); return; }
    const start = Number(m[1]); const end = Math.min(stat.size-1, m[2]? Number(m[2]) : stat.size-1);
    res.writeHead(206, { 'Content-Range': `bytes ${start}-${end}/${stat.size}`, 'Content-Length': (end-start+1), 'Content-Type': contentType(filePath) });
    fs.createReadStream(filePath, { start, end }).pipe(res);
  } else {
    res.writeHead(200, { 'Content-Length': stat.size, 'Content-Type': contentType(filePath) });
    fs.createReadStream(filePath).pipe(res);
  }
});

server.listen(port, ()=> console.log(`Range server on http://localhost:${port} (root=${path.resolve(root)})`));

function contentType(p:string){
  if (p.endsWith('.mpltrace') || p.endsWith('.ndjson')) return 'application/x-ndjson';
  if (p.endsWith('.mplidx') || p.endsWith('.json')) return 'application/json';
  return 'application/octet-stream';
}
```

---

## index-3h-seek.html (NEW — remote seek UI)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 3H – Seekable Remote Replay</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 3H (Seekable Traces via HTTP Range + Keyframes)</h1>
    <small>Index‑assisted random access • nearest keyframe decode</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row"><label>Trace URL</label><input id="url" placeholder="http://localhost:5173/traces/my.mpltrace" style="width:240px" /></div>
      <div class="row"><label>Index URL (optional)</label><input id="idx" placeholder="http://localhost:5173/traces/my.mpltrace.mplidx" style="width:240px" /></div>
      <div class="row"><button id="load">Load</button></div>
      <div class="row"><label>Seek</label><input id="seek" type="range" min="0" max="0" value="0" style="width:240px" /></div>
      <div class="row"><button id="play">▶︎ Play</button><button id="step">Step</button></div>
      <div class="row"><small id="info">—</small></div>
      <div class="row"><small>Tip: build the index with <code>npm run build:3h:index -- traces/foo.mpltrace</code> and serve both files with <code>serve:range</code>.</small></div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="960" height="640"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/seek-main.ts"></script>
</body>
</html>
```

---

## README addendum (3H)

````md
### 3H – Seekable Traces (HTTP Range + Keyframes)

**Record with keyframes** (example: delta frames every 10 steps, keyframe every 100 frames):
- When constructing `Recorder`, pass an init with `schema:'mpl-trace@1.2'`, `enc:'delta-xor'`, `keyint:100`.

**Build an index (.mplidx)**
```bash
npm run build:3h:index -- traces/my.mpltrace
# writes traces/my.mpltrace.mplidx
````

**Serve the files with Range support**

```bash
npm run serve:range -- ./traces 5173
# open http://localhost:5173/my.mpltrace and .mplidx
```

**Play remotely with instant seek**

```bash
npm run dev:3h
# open index-3h-seek.html, paste the trace URL and (optionally) index URL
```

**How it seeks**

1. Find the nearest **keyframe ≤ target** in `.mplidx`.
2. Range‑fetch that line and decode to a full grid.
3. Walk forward applying a short chain of **delta** frames until the target; draw via 3C tiled renderer.

**Limitations**

* Range indexing assumes **uncompressed NDJSON** on the wire. If you enable `Content-Encoding: gzip` at the server, the byte offsets change.
* For very sparse deltas, increase `keyint` to keep seek latency bounded.

```
```
