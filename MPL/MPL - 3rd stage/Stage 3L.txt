# MPL Playground ‚Äî Stage 3L Patch (Import/Export, Bookmarks, Diff Mode)

This patch adds:

* **Import/Export sessions** as JSON (`ExecutionSnapshot[]` + optional bookmarks)
* **Bookmarks & annotations per tick** (pin, label, note, jump)
* **Diff Mode**: color‚Äëcoded A‚ÜîB comparison between ghost (A) and current (B)

It builds on **3I‚Äì3K** and stays dependency‚Äëfree.

> **How to integrate**
>
> 1. Drop in the new files below. 2) Replace/merge the updated components. 3) Add the CSS. 4) Use `DebuggerPanel` with `history` (preferred) or `snapshot`.

---

## 1) `engine/debugger/sessionIO.ts`

```ts
// engine/debugger/sessionIO.ts
// Stage 3L ‚Äî Import/Export of ExecutionSnapshot histories + bookmarks

import { ExecutionSnapshot } from "./graphTypes";
import { Bookmark } from "./bookmarks";

export interface SessionBundle {
  version: "3L";
  createdAt: number; // epoch ms
  history: ExecutionSnapshot[];
  bookmarks?: Bookmark[];
}

export function makeBundle(history: ExecutionSnapshot[], bookmarks?: Bookmark[]): SessionBundle {
  return { version: "3L", createdAt: Date.now(), history, bookmarks };
}

export function validateBundle(obj: unknown): obj is SessionBundle {
  if (!obj || typeof obj !== "object") return false as const;
  const b = obj as any;
  if (b.version !== "3L" || !Array.isArray(b.history)) return false;
  // shallow validation of snapshots
  for (const s of b.history) {
    if (typeof s !== "object" || typeof s.tick !== "number" || !Array.isArray(s.monads)) return false;
  }
  if (b.bookmarks && !Array.isArray(b.bookmarks)) return false;
  return true;
}

export function downloadJSON(filename: string, data: any) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

export async function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(String(reader.result || ""));
    reader.onerror = reject;
    reader.readAsText(file);
  });
}
```

---

## 2) `engine/debugger/bookmarks.ts`

```ts
// engine/debugger/bookmarks.ts
// Stage 3L ‚Äî Bookmark/annotation helpers

export interface Bookmark {
  id: string;         // uid
  tick: number;       // reference tick
  index: number;      // index in the history array when saved
  label?: string;
  note?: string;
  createdAt: number;  // epoch ms
}

export function createBookmark(index: number, tick: number, label = "", note = ""): Bookmark {
  return { id: `bm_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`, index, tick, label, note, createdAt: Date.now() };
}

export function updateBookmark(b: Bookmark, patch: Partial<Bookmark>): Bookmark {
  return { ...b, ...patch };
}

export function removeBookmark(bookmarks: Bookmark[], id: string): Bookmark[] {
  return bookmarks.filter(b => b.id !== id);
}

export function serializeBookmarks(bms: Bookmark[]): Bookmark[] {
  // already plain objects; return shallow copy
  return bms.map(b => ({ ...b }));
}
```

---

## 3) `engine/debugger/diff.ts`

```ts
// engine/debugger/diff.ts
// Stage 3L ‚Äî Diff utilities for A (ghost) vs B (current)

import { GraphData } from "./graphTypes";

export interface DiffResult {
  nodesAdded: Set<string>;    // in B not in A
  nodesRemoved: Set<string>;  // in A not in B
  nodesChanged: Set<string>;  // present in both but changed
  edgesAdded: Set<string>;    // edge id `${a}->${b}` in B not A
  edgesRemoved: Set<string>;  // in A not B
}

function shallowNodeSignature(n: { id: string; data?: any }, neighborCount?: number): string {
  // Use neighbor count + a stable snapshot of `data` keys to detect structural changes without deep costs
  const keys = n.data ? Object.keys(n.data).sort().join("|") : "";
  return `k:${keys}|deg:${neighborCount ?? 0}`;
}

export function computeDiff(a: GraphData | null, b: GraphData | null, neighborDegA?: Map<string, number>, neighborDegB?: Map<string, number>): DiffResult {
  const res: DiffResult = {
    nodesAdded: new Set(), nodesRemoved: new Set(), nodesChanged: new Set(), edgesAdded: new Set(), edgesRemoved: new Set()
  };
  if (!a && !b) return res;
  const aNodes = new Map<string, string>();
  const bNodes = new Map<string, string>();

  if (a) for (const n of a.nodes) aNodes.set(n.id, shallowNodeSignature(n, neighborDegA?.get(n.id)));
  if (b) for (const n of b.nodes) bNodes.set(n.id, shallowNodeSignature(n, neighborDegB?.get(n.id)));

  for (const id of bNodes.keys()) if (!aNodes.has(id)) res.nodesAdded.add(id);
  for (const id of aNodes.keys()) if (!bNodes.has(id)) res.nodesRemoved.add(id);
  for (const id of bNodes.keys()) {
    const sa = aNodes.get(id); const sb = bNodes.get(id);
    if (sa != null && sb != null && sa !== sb) res.nodesChanged.add(id);
  }

  const aEdges = new Set<string>(a ? a.edges.map(e => e.id) : []);
  const bEdges = new Set<string>(b ? b.edges.map(e => e.id) : []);
  for (const id of bEdges) if (!aEdges.has(id)) res.edgesAdded.add(id);
  for (const id of aEdges) if (!bEdges.has(id)) res.edgesRemoved.add(id);

  return res;
}
```

---

## 4) `playground/components/ImportExportPanel.tsx`

```tsx
// playground/components/ImportExportPanel.tsx
// Stage 3L ‚Äî Import/Export UI for session bundles

import React, { useRef, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { makeBundle, validateBundle, downloadJSON, readFileAsText, SessionBundle } from "../../engine/debugger/sessionIO";

interface ImportExportPanelProps {
  history: ExecutionSnapshot[];
  bookmarks: Bookmark[];
  onImport: (bundle: SessionBundle) => void;
  filenameBase?: string; // default MPL_Session
}

export const ImportExportPanel: React.FC<ImportExportPanelProps> = ({ history, bookmarks, onImport, filenameBase = "MPL_Session" }) => {
  const fileRef = useRef<HTMLInputElement>(null);
  const [err, setErr] = useState<string | null>(null);

  const onExport = () => {
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const name = `${filenameBase}_${ts}.json`;
    downloadJSON(name, makeBundle(history, bookmarks));
  };

  const onPick = () => fileRef.current?.click();

  const onFile = async (e: React.ChangeEvent<HTMLInputElement>) => {
    setErr(null);
    const f = e.target.files?.[0];
    if (!f) return;
    try {
      const text = await readFileAsText(f);
      const data = JSON.parse(text);
      if (!validateBundle(data)) throw new Error("Invalid session bundle format");
      onImport(data);
    } catch (ex: any) {
      setErr(ex?.message ?? String(ex));
    } finally {
      if (fileRef.current) fileRef.current.value = "";
    }
  };

  return (
    <div className="mpl-io">
      <div className="mpl-io-row">
        <button className="mpl-btn" onClick={onExport}>‚¨á Export JSON</button>
        <button className="mpl-btn" onClick={onPick}>‚¨Ü Import JSON</button>
        <input ref={fileRef} type="file" accept="application/json,.json" style={{ display: "none" }} onChange={onFile} />
      </div>
      {err && <div className="mpl-io-error">{err}</div>}
    </div>
  );
};
```

---

## 5) `playground/components/BookmarksPanel.tsx`

```tsx
// playground/components/BookmarksPanel.tsx
// Stage 3L ‚Äî Manage bookmarks/annotations

import React, { useMemo, useState } from "react";
import { Bookmark, createBookmark, removeBookmark, updateBookmark } from "../../engine/debugger/bookmarks";

interface BookmarksPanelProps {
  currentIndex: number;
  currentTick: number;
  bookmarks: Bookmark[];
  onChange: (next: Bookmark[]) => void;
  onGoToIndex: (i: number) => void;
}

export const BookmarksPanel: React.FC<BookmarksPanelProps> = ({ currentIndex, currentTick, bookmarks, onChange, onGoToIndex }) => {
  const [label, setLabel] = useState("");
  const [note, setNote] = useState("");

  const sorted = useMemo(() => [...bookmarks].sort((a,b) => a.index - b.index || a.createdAt - b.createdAt), [bookmarks]);

  const add = () => {
    const bm = createBookmark(currentIndex, currentTick, label.trim(), note.trim());
    onChange([ ...bookmarks, bm ]);
    setLabel(""); setNote("");
  };

  const del = (id: string) => onChange(removeBookmark(bookmarks, id));

  const save = (id: string, patch: Partial<Bookmark>) => {
    onChange(bookmarks.map(b => b.id === id ? updateBookmark(b, patch) : b));
  };

  return (
    <div className="mpl-bm">
      <div className="mpl-bm-add">
        <input placeholder="Label" value={label} onChange={e => setLabel(e.target.value)} />
        <input placeholder="Note" value={note} onChange={e => setNote(e.target.value)} />
        <button className="mpl-btn" onClick={add}>üìå Add Bookmark</button>
      </div>

      <div className="mpl-bm-list">
        {sorted.map(b => (
          <div key={b.id} className="mpl-bm-item">
            <div className="mpl-bm-main">
              <button className="mpl-btn" title="Jump" onClick={() => onGoToIndex(b.index)}>‚§¥</button>
              <input value={b.label ?? ""} onChange={e => save(b.id, { label: e.target.value })} />
              <span className="mpl-bm-meta">tick {b.tick} ‚Ä¢ idx {b.index}</span>
            </div>
            <div className="mpl-bm-note">
              <textarea value={b.note ?? ""} onChange={e => save(b.id, { note: e.target.value })} placeholder="Note" />
              <button className="mpl-btn mpl-danger" onClick={() => del(b.id)}>Delete</button>
            </div>
          </div>
        ))}
        {sorted.length === 0 && <div className="mpl-empty">No bookmarks yet</div>}
      </div>
    </div>
  );
};
```

---

## 6) `playground/components/GraphStateView.tsx` (augment with **Diff Mode** classes)

```tsx
// playground/components/GraphStateView.tsx
// Stage 3L ‚Äî Diff visualization layered on top of 3K (ghost overlay retained)

import React, { useCallback, useMemo, useRef, useState, useEffect } from "react";
import { ExecutionSnapshot, GraphData } from "../../engine/debugger/graphTypes";
import { buildGraphFromSnapshot } from "../../engine/debugger/toGraph";
import { computeDiff } from "../../engine/debugger/diff";

interface GraphStateViewProps {
  snapshot: ExecutionSnapshot;         // current (B)
  ghostSnapshot?: ExecutionSnapshot;   // optional (A)
  width?: number; height?: number;
  onSelectMonad?: (id: string) => void;
  neighborFocusMode?: boolean;
  highlightRules?: boolean; highlightWindowTicks?: number; // from 3J
  diffMode?: boolean; // NEW: if true, color‚Äëcode adds/removes/changes
}

function useMeasure(ref: React.RefObject<HTMLElement>) {
  const [size, setSize] = useState<{ width: number; height: number }>({ width: 300, height: 200 });
  useEffect(() => { if (!ref.current) return; const ro = new ResizeObserver(([entry]) => setSize({ width: entry.contentRect.width, height: entry.contentRect.height })); ro.observe(ref.current); return () => ro.disconnect(); }, [ref]);
  return size;
}

export const GraphStateView: React.FC<GraphStateViewProps> = ({ snapshot, ghostSnapshot, width, height, onSelectMonad, neighborFocusMode, highlightRules = true, highlightWindowTicks = 3, diffMode = true }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const size = useMeasure(containerRef);
  const W = width ?? size.width ?? 600; const H = height ?? size.height ?? 400;

  const graph: GraphData = useMemo(() => buildGraphFromSnapshot(snapshot, { nodeRadius: 14, spacing: 80 }), [snapshot]);
  const ghost: GraphData | null = useMemo(() => ghostSnapshot ? buildGraphFromSnapshot(ghostSnapshot, { nodeRadius: 12, spacing: 80 }) : null, [ghostSnapshot]);

  // neighbor degrees for diff signatures
  const degA = useMemo(() => ghost ? degreeMap(ghost) : undefined, [ghost]);
  const degB = useMemo(() => degreeMap(graph), [graph]);
  const diff = useMemo(() => diffMode ? computeDiff(ghost, graph, degA, degB) : null, [ghost, graph, degA, degB, diffMode]);

  // Pan/Zoom
  const [zoom, setZoom] = useState(1); const [offset, setOffset] = useState({ x: 0, y: 0 });
  const dragRef = useRef<{ x: number; y: number } | null>(null);
  const onWheel = useCallback((e: React.WheelEvent) => { e.preventDefault(); const f = Math.exp(-e.deltaY * 0.001); setZoom(z => Math.min(4, Math.max(0.25, z * f))); }, []);
  const onMouseDown = useCallback((e: React.MouseEvent) => { dragRef.current = { x: e.clientX, y: e.clientY }; }, []);
  const onMouseMove = useCallback((e: React.MouseEvent) => { if (!dragRef.current) return; const dx = e.clientX - dragRef.current.x; const dy = e.clientY - dragRef.current.y; dragRef.current = { x: e.clientX, y: e.clientY }; setOffset(o => ({ x: o.x + dx, y: o.y + dy })); }, []);
  const onMouseUp = useCallback(() => { dragRef.current = null; }, []);

  const neighborSet = useMemo(() => { if (!neighborFocusMode) return null as null | Set<string>; const focusId = snapshot.focusMonadId != null ? String(snapshot.focusMonadId) : (graph.nodes.find(n => n.active)?.id ?? null); if (!focusId) return null; const s = new Set<string>(); for (const e of graph.edges) { if (e.source === focusId) s.add(e.target); if (e.target === focusId) s.add(e.source); } s.add(focusId); return s; }, [neighborFocusMode, graph, snapshot.focusMonadId]);

  const isRecent = useCallback((at?: number) => { if (at == null) return false; const dt = snapshot.tick - at; return dt >= 0 && dt <= (highlightWindowTicks ?? 3); }, [snapshot.tick, highlightWindowTicks]);

  return (
    <div ref={containerRef} className="mpl-graph-container" style={{ width: width ? `${width}px` : "100%", height: height ? `${height}px` : "100%" }}>
      <svg className="mpl-graph-svg" width={W} height={H} onWheel={onWheel} onMouseDown={onMouseDown} onMouseMove={onMouseMove} onMouseUp={onMouseUp}>
        <defs>
          <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" /></marker>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="3" result="coloredBlur" /><feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge></filter>
        </defs>

        <g transform={`translate(${W / 2 + offset.x}, ${H / 2 + offset.y}) scale(${zoom})`}>
          {/* Ghost layer (A) */}
          {ghost && (
            <g className="mpl-ghost-layer">
              {ghost.edges.map(e => {
                const a = ghost.nodes.find(n => n.id === e.source)!; const b = ghost.nodes.find(n => n.id === e.target)!;
                const cls = diff && diff.edgesRemoved.has(e.id) ? "mpl-ghost-edge mpl-edge-removed" : "mpl-ghost-edge";
                return <line key={`g-${e.id}`} x1={a.x} y1={a.y} x2={b.x} y2={b.y} className={cls} />;
              })}
              {ghost.nodes.map(n => {
                const cls = diff && diff.nodesRemoved.has(n.id) ? "mpl-ghost-node-circle mpl-node-removed" : "mpl-ghost-node-circle";
                return (
                  <g key={`g-${n.id}`} transform={`translate(${n.x}, ${n.y})`} className="mpl-ghost-node">
                    <circle r={n.radius} className={cls} />
                    <text className="mpl-ghost-node-label" y={n.radius + 12} textAnchor="middle">{n.label ?? n.id}</text>
                  </g>
                );
              })}
            </g>
          )}

          {/* Current layer (B) */}
          {graph.edges.map(e => {
            const a = graph.nodes.find(n => n.id === e.source)!; const b = graph.nodes.find(n => n.id === e.target)!;
            const dimmed = neighborSet && !(neighborSet.has(a.id) && neighborSet.has(b.id));
            const pulsing = !!(highlightRules && e.pulse && isRecent(e.pulse.at));
            const added = !!(diff && diff.edgesAdded.has(e.id));
            const cls = `mpl-edge ${dimmed ? "mpl-dim" : ""} ${pulsing ? "mpl-edge-pulse" : ""} ${added ? "mpl-edge-added" : ""}`;
            return <line key={e.id} x1={a.x} y1={a.y} x2={b.x} y2={b.y} className={cls} />;
          })}

          {graph.nodes.map(n => {
            const dimmed = neighborSet && !neighborSet.has(n.id);
            const fired = !!(highlightRules && isRecent(n.lastRuleAt));
            const added = !!(diff && diff.nodesAdded.has(n.id));
            const changed = !!(diff && diff.nodesChanged.has(n.id));
            const cls = `mpl-node-circle ${n.active ? "mpl-node-active" : ""} ${dimmed ? "mpl-dim" : ""} ${fired ? "mpl-node-fired" : ""} ${added ? "mpl-node-added" : ""} ${changed ? "mpl-node-changed" : ""}`;
            return (
              <g key={n.id} transform={`translate(${n.x}, ${n.y})`} className="mpl-node" onClick={() => onSelectMonad?.(n.id)}>
                <circle r={n.radius} className={cls} filter={(n.active || fired || added || changed) ? "url(#glow)" : undefined} />
                <text className={`mpl-node-label ${dimmed ? "mpl-dim" : ""}`} y={n.radius + 14} textAnchor="middle">{n.label ?? n.id}</text>
              </g>
            );
          })}
        </g>
      </svg>
    </div>
  );
};

function degreeMap(g: GraphData): Map<string, number> {
  const m = new Map<string, number>();
  for (const n of g.nodes) m.set(n.id, 0);
  for (const e of g.edges) {
    m.set(e.source, (m.get(e.source) || 0) + 1);
    m.set(e.target, (m.get(e.target) || 0) + 1);
  }
  return m;
}
```

---

## 7) `playground/components/StateViewer.tsx` (toggle **Diff Mode**)

```tsx
// playground/components/StateViewer.tsx
// Stage 3L ‚Äî add Diff Mode toggle; otherwise same as 3K

import React, { useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { GraphStateView } from "./GraphStateView";

interface StateViewerProps {
  snapshot: ExecutionSnapshot;           // current (B)
  ghostSnapshot?: ExecutionSnapshot;     // optional (A)
  onSelectMonad?: (id: string) => void;
}

type ViewMode = "table" | "graph";

export const StateViewer: React.FC<StateViewerProps> = ({ snapshot, ghostSnapshot, onSelectMonad }) => {
  const [mode, setMode] = useState<ViewMode>("table");
  const [neighborOnly, setNeighborOnly] = useState(false);
  const [showHighlights, setShowHighlights] = useState(true);
  const [windowTicks, setWindowTicks] = useState(3);
  const [diffMode, setDiffMode] = useState(true);

  const rows = useMemo(() => snapshot.monads.map(m => ({ id: String(m.id), neighbors: m.neighbors?.length ?? 0, active: !!(m.active || (snapshot.focusMonadId != null && String(snapshot.focusMonadId) === String(m.id))) })), [snapshot]);

  return (
    <div className="mpl-state-viewer">
      <div className="mpl-toolbar">
        <div className="mpl-seg">
          <button className={`mpl-btn ${mode === "table" ? "active" : ""}`} onClick={() => setMode("table")}>Table</button>
          <button className={`mpl-btn ${mode === "graph" ? "active" : ""}`} onClick={() => setMode("graph")}>Graph</button>
        </div>
        {mode === "graph" && (
          <div className="mpl-toolbar-right">
            <label className="mpl-check"><input type="checkbox" checked={neighborOnly} onChange={e => setNeighborOnly(e.target.checked)} /> Neighbor focus</label>
            <label className="mpl-check"><input type="checkbox" checked={showHighlights} onChange={e => setShowHighlights(e.target.checked)} /> Rule highlights</label>
            <label className="mpl-check">Window
              <select value={windowTicks} onChange={e => setWindowTicks(parseInt(e.target.value))}>
                <option value={1}>1</option><option value={3}>3</option><option value={5}>5</option><option value={10}>10</option>
              </select> ticks
            </label>
            <label className="mpl-check"><input type="checkbox" checked={diffMode} onChange={e => setDiffMode(e.target.checked)} /> Diff mode</label>
          </div>
        )}
      </div>

      {mode === "table" ? (
        <div className="mpl-table-wrap">
          <table className="mpl-table">
            <thead><tr><th>ID</</th><th>Neighbors</th><th>Active</th></tr></thead>
            <tbody>
              {rows.map(r => (
                <tr key={r.id} onClick={() => onSelectMonad?.(r.id)} className={r.active ? "mpl-row-active" : undefined}>
                  <td>{r.id}</td><td>{r.neighbors}</td><td>{r.active ? "‚óè" : ""}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="mpl-graph-wrap">
          <GraphStateView
            snapshot={snapshot}
            ghostSnapshot={ghostSnapshot}
            onSelectMonad={onSelectMonad}
            neighborFocusMode={neighborOnly}
            highlightRules={showHighlights}
            highlightWindowTicks={windowTicks}
            diffMode={diffMode}
          />
        </div>
      )}
    </div>
  );
};
```

---

## 8) `playground/components/DebuggerPanel.tsx` (wire Import/Export + Bookmarks)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3L ‚Äî add Import/Export, Bookmarks panels; preserve 3K timeline + state viewer

import React, { useEffect, useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";
import { TimeScrubber } from "./TimeScrubber";
import { ImportExportPanel } from "./ImportExportPanel";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { BookmarksPanel } from "./BookmarksPanel";
import { SessionBundle } from "../../engine/debugger/sessionIO";

interface DebuggerPanelProps {
  snapshot?: ExecutionSnapshot;   // fallback single snapshot
  history?: ExecutionSnapshot[];  // preferred for time travel
  onFocusMonad?: (id: string) => void;
}

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, history, onFocusMonad }) => {
  const [timeline, setTimeline] = useState<ExecutionSnapshot[]>(() => history ?? (snapshot ? [snapshot] : []));
  const hasHistory = timeline.length > 0;

  useEffect(() => { if (history && history.length) setTimeline(history); }, [history?.length]);
  useEffect(() => { if (!history && snapshot) setTimeline([snapshot]); }, [snapshot?.tick]);

  const [idx, setIdx] = useState(() => Math.max(0, timeline.length - 1));
  useEffect(() => { setIdx(Math.max(0, timeline.length - 1)); }, [timeline.length]);

  const [ghostIdx, setGhostIdx] = useState<number | null>(null);
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);

  const current = useMemo<ExecutionSnapshot | undefined>(() => timeline[Math.max(0, Math.min(idx, timeline.length - 1))], [timeline, idx]);
  const ghost = useMemo<ExecutionSnapshot | undefined>(() => ghostIdx == null ? undefined : timeline[Math.max(0, Math.min(ghostIdx, timeline.length - 1))], [timeline, ghostIdx]);

  const onImport = (bundle: SessionBundle) => {
    setTimeline(bundle.history || []);
    setBookmarks(bundle.bookmarks || []);
    setIdx(Math.max(0, (bundle.history?.length || 1) - 1));
    setGhostIdx(null);
  };

  return (
    <div className="mpl-debugger-panel">
      {/* Import/Export */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session I/O</header>
        <ImportExportPanel history={timeline} bookmarks={bookmarks} onImport={onImport} />
      </section>

      {/* Timeline */}
      {hasHistory && (
        <section className="mpl-section">
          <header className="mpl-section-h">Timeline</header>
          <TimeScrubber timeline={timeline} index={idx} onChangeIndex={setIdx} ghostIndex={ghostIdx} onChangeGhostIndex={setGhostIdx} />
        </section>
      )}

      {/* Bookmarks */}
      <section className="mpl-section">
        <header className="mpl-section-h">Bookmarks</header>
        <BookmarksPanel currentIndex={idx} currentTick={current?.tick ?? idx} bookmarks={bookmarks} onChange={setBookmarks} onGoToIndex={setIdx} />
      </section>

      {/* State */}
      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        {current ? (
          <StateViewer snapshot={current} ghostSnapshot={ghost} onSelectMonad={onFocusMonad} />
        ) : (
          <div className="mpl-empty">No snapshot available</div>
        )}
      </section>
    </div>
  );
};
```

---

## 9) `playground/styles/debugger.css` (additions)

```css
/* Stage 3L ‚Äî Import/Export, Bookmarks, Diff styling */
.mpl-io { display: grid; gap: 8px; }
.mpl-io-row { display: inline-flex; gap: 8px; }
.mpl-io-error { color: #b91c1c; font-size: 12px; }

.mpl-bm { display: grid; gap: 10px; }
.mpl-bm-add { display: grid; grid-template-columns: 1fr 2fr auto; gap: 8px; }
.mpl-bm-add input { padding: 6px 8px; }
.mpl-bm-list { display: grid; gap: 8px; }
.mpl-bm-item { border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; background: #fff; }
.mpl-bm-main { display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center; }
.mpl-bm-note { display: grid; grid-template-columns: 1fr auto; gap: 8px; margin-top: 6px; }
.mpl-bm-note textarea { min-height: 52px; padding: 6px 8px; resize: vertical; }
.mpl-danger { background: #fee2e2; color: #991b1b; }

/* Diff colors */
.mpl-node-added { stroke: #16a34a; fill: #d1fae5; }
.mpl-node-changed { stroke: #f59e0b; fill: #fff7ed; }
.mpl-node-removed { stroke: #dc2626; fill: #fee2e2; }
.mpl-edge-added { stroke: #16a34a; }
.mpl-edge-removed { stroke: #dc2626; }
```

---

## 10) Example page ‚Äî `playground/pages/DebugExample3L.tsx`

```tsx
// playground/pages/DebugExample3L.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3L() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ], focusMonadId: "A" },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "C", sourceId: "A", targetId: "C" } ], focusMonadId: "A" },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "A" } ], focusMonadId: "C" },
  ], []);
  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3L ‚Äî Import/Export ‚Ä¢ Bookmarks ‚Ä¢ Diff</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 11) Notes

* **Export format** is versioned (`version: "3L"`) so you can evolve it later.
* **Diff** is intentionally shallow to keep it fast: it considers neighbor degree + `data` keys. If you need deep value diffs, swap the signature function.
* **Removed items** colorize in the **ghost layer** (A); added/changed are highlighted in current layer (B).
* **Bookmarks** are in‚Äëmemory unless you export; importing loads them back.

---

## 12) Changelog ‚Äî Stage 3L

* New: `sessionIO.ts` (bundle I/O), `bookmarks.ts` (data + helpers), `diff.ts` (A/B compare)
* New UI: `ImportExportPanel.tsx`, `BookmarksPanel.tsx`
* Updated: `GraphStateView` (diff rendering), `StateViewer` (Diff toggle), `DebuggerPanel` (wiring)
* CSS additions for I/O, bookmarks, and diff color coding

```
```
