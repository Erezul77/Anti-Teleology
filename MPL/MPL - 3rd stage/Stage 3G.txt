# MPL – Stage 3G (Delta Traces + Compression + Multi‑Run Compare)

Stage **3G** upgrades traces for **smaller files** and adds a **side‑by‑side comparator** for two runs.

* **Delta frames**: store `xor` vs previous frame, then **row‑RLE** (like 3F) → \~5–20× smaller on typical Life.
* **Compression**: optional **gzip** via the browser’s `CompressionStream` API (and Node zlib). Transparent fallback to **none**.
* **Backward‑compatible**: 3F “full” frames still load.
* **Compare UI**: load **two traces**, scrub/auto‑play, **diff heatmap**, and stats (Δpop, #flips, Jaccard).

---

## Directory Tree (delta)

```
MPL-Stage-3/
├─ package.json
├─ README.md
├─ src/
│  ├─ trace/
│  │  ├─ schema.ts           # UPDATED: add v1.1 fields (enc/comp)
│  │  ├─ rle.ts              # (3F) reused
│  │  ├─ ndjson.ts           # UPDATED: gzip write/read helpers
│  │  ├─ delta.ts            # NEW: xor + row-RLE delta codec
│  │  ├─ record.ts           # UPDATED: delta+compression options
│  │  └─ replay.ts           # UPDATED: apply delta frames
│  ├─ compare/
│  │  └─ metrics.ts          # NEW: diff stats & heatmap buffer
│  └─ web/
│     ├─ compare-main.ts     # NEW: two‑trace visual diff UI
├─ index-3g-compare.html      # NEW: Stage 3G compare page
```

Add to **package.json**:

```json
{
  "scripts": {
    "dev:3g:cmp": "vite --open index-3g-compare.html"
  }
}
```

---

## src/trace/schema.ts (UPDATED — v1.1)

```ts
export type TraceInit = {
  type: 'init';
  schema: 'mpl-trace@1' | 'mpl-trace@1.1';
  width: number; height: number; rule: string;
  topology: 'Moore' | 'VonNeumann'; edges: 'Wrap' | 'Clip';
  seed: number; engine: 'GPU' | 'CPU' | 'Workers';
  tile?: { w: number; h: number };
  notes?: string;
  // NEW in 1.1: recommended defaults for frames (overridable per‑frame)
  enc?: 'full' | 'delta-xor';
  comp?: 'none' | 'gzip';
};

export type TraceFrame = {
  type: 'frame';
  step: number;
  pop: number;
  bbox?: { x0:number;y0:number;x1:number;y1:number };
  // v1: rle_b64 of full grid
  // v1.1: payload_b64 + enc + comp (enc/comp optional to inherit from init)
  rle_b64?: string;
  payload_b64?: string;
  enc?: 'full' | 'delta-xor';
  comp?: 'none' | 'gzip';
};

export type TraceNote = { type: 'note'; step: number; text: string };
export type TraceEvent = TraceInit | TraceFrame | TraceNote;
```

---

## src/trace/ndjson.ts (UPDATED — gzip helpers)

```ts
export class NDJSONWriter {
  private lines: string[] = [];
  write(obj: any){ this.lines.push(JSON.stringify(obj)); }
  async blob(comp: 'none' | 'gzip' = 'none'){
    const text = this.lines.join('\n');
    if (comp==='gzip' && 'CompressionStream' in self){
      const cs = new (self as any).CompressionStream('gzip');
      const stream = new Blob([text]).stream().pipeThrough(cs);
      const buf = await new Response(stream).arrayBuffer();
      return new Blob([buf], { type: 'application/gzip' });
    }
    return new Blob([text], { type: 'application/x-ndjson' });
  }
}

export async function* ndjsonStream(file: File): AsyncGenerator<any> {
  const type = file.type || ''; const isGz = /gzip/.test(type) || /\.gz$/.test(file.name);
  let text: string;
  if (isGz && 'DecompressionStream' in self){
    const ds = new (self as any).DecompressionStream('gzip');
    const stream = file.stream().pipeThrough(ds);
    text = await new Response(stream).text();
  } else {
    text = await file.text();
  }
  for (const line of text.split(/\r?\n/)) if (line.trim()) yield JSON.parse(line);
}
```

---

## src/trace/delta.ts (NEW — xor + row‑RLE)

```ts
import { rleEncode, rleDecode, b64, unb64 } from './rle.js';

export function xorInto(out: Uint8Array, a: Uint8Array, b: Uint8Array){
  for (let i=0;i<a.length;i++) out[i] = (a[i]^b[i]) & 1;
}

export function encodeDelta(prev: Uint8Array, curr: Uint8Array, W:number, H:number){
  const x = new Uint8Array(curr.length); xorInto(x, prev, curr);
  return rleEncode(x, W, H);
}

export function decodeDelta(prev: Uint8Array, rleBytes: Uint8Array, W:number, H:number){
  const x = rleDecode(rleBytes, W, H); const out = new Uint8Array(prev.length);
  for (let i=0;i<out.length;i++) out[i] = (prev[i]^x[i]) & 1; return out;
}

export const toB64 = b64; export const fromB64 = unb64;
```

---

## src/trace/record.ts (UPDATED — delta + compression)

```ts
import { rleEncode, b64 } from './rle.js';
import { encodeDelta, toB64 } from './delta.js';
import type { TraceInit, TraceFrame } from './schema.js';

export type SnapshotSource = { width:number; height:number; readFull(): Promise<Uint8Array>|Uint8Array; stats?(buf:Uint8Array):{pop:number; bbox?:{x0:number;y0:number;x1:number;y1:number}} };

export class Recorder {
  private step = 0; private nextCapture = 0; private prev?: Uint8Array;
  constructor(private src: SnapshotSource, private init: TraceInit, private interval=10){ }

  async captureIfNeeded(writer: { write(o:any): void }){
    if (this.step === 0){ writer.write({ ...this.init, schema: this.init.schema ?? 'mpl-trace@1.1' }); }
    if (this.step >= this.nextCapture){
      const buf = await this.src.readFull();
      const { pop, bbox } = this.src.stats? this.src.stats(buf) : { pop: buf.reduce((a,b)=>a+(b&1),0) } as any;

      const useDelta = (this.init.enc ?? 'delta-xor') === 'delta-xor' && this.prev;
      let frame: TraceFrame;
      if (useDelta){
        const rle = encodeDelta(this.prev!, buf, this.src.width, this.src.height);
        frame = { type:'frame', step:this.step, pop, bbox, payload_b64: toB64(rle), enc:'delta-xor', comp: this.init.comp ?? 'none' };
      } else {
        const rle = rleEncode(buf, this.src.width, this.src.height);
        frame = { type:'frame', step:this.step, pop, bbox, rle_b64: b64(rle), enc:'full', comp: this.init.comp ?? 'none' };
      }
      writer.write(frame); this.prev = buf; this.nextCapture += this.interval;
    }
    this.step++;
  }
}
```

---

## src/trace/replay.ts (UPDATED — apply delta)

```ts
import type { TraceEvent, TraceInit, TraceFrame } from './schema.js';
import { unb64, rleDecode } from './rle.js';
import { fromB64, decodeDelta } from './delta.js';

export class Replay {
  init!: TraceInit; frames: TraceFrame[] = []; idx=0; private prev?: Uint8Array;
  load(evts: TraceEvent[]){
    const init = evts.find(e=> e.type==='init') as TraceInit; if (!init) throw new Error('missing init'); this.init = init;
    this.frames = evts.filter(e=> e.type==='frame') as TraceFrame[]; this.idx = 0; this.prev = undefined;
  }
  hasNext(){ return this.idx < this.frames.length; }
  step(){
    if (!this.hasNext()) return null; const f=this.frames[this.idx++];
    let grid: Uint8Array;
    if (f.payload_b64){
      if ((f.enc ?? this.init.enc) === 'delta-xor'){
        if (!this.prev) throw new Error('delta without prev');
        const bytes = fromB64(f.payload_b64); grid = decodeDelta(this.prev, bytes, this.init.width, this.init.height);
      } else { throw new Error('unknown encoding'); }
    } else if (f.rle_b64){
      const bytes = unb64(f.rle_b64); grid = rleDecode(bytes, this.init.width, this.init.height);
    } else { throw new Error('missing frame data'); }
    this.prev = grid; return { f, grid };
  }
}
```

---

## src/compare/metrics.ts (NEW — stats & diff buffer)

```ts
export function jaccard(aOn:number, bOn:number, inter:number){ const union=aOn+bOn-inter; return union? inter/union : 1; }

export function diffStats(a: Uint8Array, b: Uint8Array){
  let aOn=0, bOn=0, inter=0, flips=0; const N=a.length; const heat=new Uint8Array(N);
  for (let i=0;i<N;i++){ const A=a[i]&1, B=b[i]&1; aOn+=A; bOn+=B; inter+= (A&B); if ((A^B)===1){ flips++; heat[i]=1; } }
  return { aOn, bOn, inter, flips, jacc: jaccard(aOn,bOn,inter), heat };
}
```

---

## src/web/compare-main.ts (NEW — two‑trace visual diff)

```ts
import { Replay } from '../trace/replay.js';
import { diffStats } from '../compare/metrics.js';
import { TiledRenderer } from '../render/tiled-renderer.js';

const $=<T extends HTMLElement>(id:string)=> document.getElementById(id) as T;
const fileA=$('fileA') as HTMLInputElement; const fileB=$('fileB') as HTMLInputElement; const playBtn=$('play'); const stepBtn=$('step'); const info=$('info');
const canvasA=$('gridA') as HTMLCanvasElement; const canvasB=$('gridB') as HTMLCanvasElement; const canvasD=$('gridD') as HTMLCanvasElement;

let repA:Replay|null=null, repB:Replay|null=null; let playing=false; let view={x:0,y:0,zoom:4};
let renA: TiledRenderer, renB: TiledRenderer, renD: TiledRenderer;

function cellsSourceFrom(buf: Uint8Array, W:number, H:number){
  return { gridW:W, gridH:H, version: ()=> 1, readRect: (x0:number,y0:number,x1:number,y1:number)=>{ const w=x1-x0, h=y1-y0; const out=new Uint8Array(w*h); for(let y=0;y<h;y++){ out.set(buf.slice((y0+y)*W+x0, (y0+y)*W+x0+w), y*w); } return out; } };
}

async function loadFile(which:'A'|'B', file: File){
  const text = await file.text(); const evts = text.split(/\r?\n/).filter(Boolean).map(JSON.parse);
  const rep = new Replay(); rep.load(evts as any);
  if (which==='A') repA=rep; else repB=rep;
  if (repA && repB){ if (repA.init.width!==repB.init.width || repA.init.height!==repB.init.height) throw new Error('Trace sizes differ');
    const W=repA.init.width, H=repA.init.height; renA=new TiledRenderer(canvasA, cellsSourceFrom(new Uint8Array(W*H), W,H),64,64); renB=new TiledRenderer(canvasB, cellsSourceFrom(new Uint8Array(W*H), W,H),64,64); renD=new TiledRenderer(canvasD, cellsSourceFrom(new Uint8Array(W*H), W,H),64,64);
  }
}

async function step(){ if (!repA?.hasNext() || !repB?.hasNext()) return; const a=repA.step()!, b=repB.step()!; const W=repA.init.width, H=repA.init.height;
  const { flips, jacc, aOn, bOn, heat } = diffStats(a.grid, b.grid);
  (renA as any).setSource(cellsSourceFrom(a.grid,W,H)); (renB as any).setSource(cellsSourceFrom(b.grid,W,H)); (renD as any).setSource(cellsSourceFrom(heat,W,H));
  await Promise.all([ renA.draw(view, 64), renB.draw(view, 64), renD.draw(view, 64) ]);
  info!.textContent = `step ${a.f.step}/${b.f.step} • Δpop ${bOn-aOn} • flips ${flips} • Jaccard ${jacc.toFixed(3)}`;
}

function loop(){ if(!playing) return; step().then(()=> requestAnimationFrame(loop)); }

fileA.addEventListener('change', ()=>{ const f=fileA.files?.[0]; if(f) loadFile('A', f); });
fileB.addEventListener('change', ()=>{ const f=fileB.files?.[0]; if(f) loadFile('B', f); });
playBtn.addEventListener('click', ()=>{ playing=!playing; playBtn!.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); });
stepBtn.addEventListener('click', ()=>{ if(!playing) step(); });
```

---

## index-3g-compare.html (NEW — compare two traces)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 3G – Compare Traces (Delta + Compression)</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input, select { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    .grids { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; }
    .cap { color:var(--muted); margin:4px 0 8px 0; }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 3G (Delta Traces + Compression + Compare)</h1>
    <small>Load two traces • visualize diffs • stats</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row"><input id="fileA" type="file" accept=".mpltrace,.ndjson,.gz" /> <input id="fileB" type="file" accept=".mpltrace,.ndjson,.gz" /></div>
      <div class="row"><button id="play">▶︎ Play</button> <button id="step">Step</button></div>
      <div class="row"><span id="info">—</span></div>
    </aside>
    <section class="panel">
      <div class="grids">
        <div><div class="cap">A</div><canvas id="gridA" width="480" height="320"></canvas></div>
        <div><div class="cap">B</div><canvas id="gridB" width="480" height="320"></canvas></div>
        <div><div class="cap">Diff (flips)</div><canvas id="gridD" width="480" height="320"></canvas></div>
      </div>
    </section>
  </main>
  <script type="module" src="/src/web/compare-main.ts"></script>
</body>
</html>
```

---

## README addendum (3G)

````md
### 3G – Delta Traces + Compression + Multi‑Run Compare

**What’s new**
- **Delta encoding**: `delta-xor` vs previous → row‑RLE → base64.
- **Compression**: optional GZIP via `CompressionStream` (browser) / zlib (Node). If unsupported, falls back to plain NDJSON.
- **Schema v1.1**: `init` may set default `enc`/`comp`. Each `frame` may override.
- **Compare UI**: load traces A & B, play/step in lockstep, and view **diff** with stats.

**Record (delta + gzip)**
The recorder inherits `enc:'delta-xor'` and `comp:'gzip'` by default in 3G. You can force full frames by setting `enc:'full'`.

**Run compare UI**
```bash
npm run dev:3g:cmp
````

**Back‑compat**

* 3F traces (full frames) continue to load. 3G replay applies delta when present.

```
```
