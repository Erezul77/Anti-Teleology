# MPL Playground â€” Stage 3X Patch (Artifact Capture: Screenshots, Metrics, Traces)

This patch adds firstâ€‘class **Artifacts**: screenshots (PNG via DOM capture), metrics (CSV/JSON), and trace attachments (snapshot/NDJSON). It integrates with the Scenario Runner so scenarios can **capture on demand** and stash files that export cleanly for CI.

**Highlights**

* **Artifacts registry** (localStorage index + perâ€‘item blobs) with tags and links to session/scenario/step
* **DOM â†’ PNG** capture with an inlinedâ€‘style foreignObject renderer (no new deps)
* **Metrics** helpers (rule counts, monad/edge tallies, simple aggregates) â†’ CSV or JSON
* **Scenario step `capture`**: screenshot selectors, dump snapshot/trace, or emit metrics from a plan
* **Artifacts Panel**: browse, filter, preview thumbnails, download/delete, bulk JSON export

> Storage note: data URLs can be large. Keep captures small or swap storage layer to IndexedDB (API kept swappable).

---

## 1) `engine/debugger/artifacts.ts` (new)

```ts
// engine/debugger/artifacts.ts
// Stage 3X â€” Lightweight artifacts registry (localStorage)

export type ArtifactKind = 'image/png'|'application/json'|'text/plain'|'text/csv';

export interface ArtifactMeta {
  id: string;
  kind: ArtifactKind;
  name: string;
  size: number;           // bytes (approx if dataURL)
  createdAt: number;
  tags: string[];
  sessionId?: string;
  scenarioId?: string;
  stepIndex?: number;     // scenario step
  index?: number;         // timeline index when captured
}

export interface ArtifactRecord { meta: ArtifactMeta; data: string } // dataURL for PNG, raw text/JSON string otherwise

const INDEX_KEY = 'mpl_artifacts_index_v1';
const SKEY = (id: string) => `mpl_artifacts_${id}`;

function now(){ return Date.now(); }
function genId(){ return `af_${now()}_${Math.random().toString(36).slice(2,8)}`; }

function readIndex(): ArtifactMeta[] { try { return JSON.parse(localStorage.getItem(INDEX_KEY) || '[]'); } catch { return []; } }
function writeIndex(arr: ArtifactMeta[]){ localStorage.setItem(INDEX_KEY, JSON.stringify(arr)); }

export const Artifacts = {
  list(): ArtifactMeta[] { return readIndex().sort((a,b)=>b.createdAt-a.createdAt); },
  load(id: string): ArtifactRecord | null { const m = readIndex().find(x=>x.id===id); if (!m) return null; const data = localStorage.getItem(SKEY(id)); if (data==null) return null; return { meta: m, data }; },
  save(kind: ArtifactKind, name: string, data: string, tags: string[] = [], refs?: Partial<Pick<ArtifactMeta,'sessionId'|'scenarioId'|'stepIndex'|'index'>>): ArtifactMeta {
    const id = genId();
    const size = kind==='image/png' ? approxDataUrlBytes(data) : new Blob([data]).size;
    const meta: ArtifactMeta = { id, kind, name: sanitize(name), size, createdAt: now(), tags, ...refs };
    const idx = readIndex(); idx.push(meta); writeIndex(idx);
    localStorage.setItem(SKEY(id), data);
    return meta;
  },
  remove(id: string): boolean { const idx = readIndex(); const i = idx.findIndex(x=>x.id===id); if (i<0) return false; idx.splice(i,1); writeIndex(idx); localStorage.removeItem(SKEY(id)); return true; },
  clearAll(){ for (const m of readIndex()) localStorage.removeItem(SKEY(m.id)); writeIndex([]); },
  rename(id: string, name: string){ const idx = readIndex(); const i = idx.findIndex(x=>x.id===id); if (i<0) return; idx[i].name = sanitize(name); writeIndex(idx); },
  retag(id: string, tags: string[]){ const idx = readIndex(); const i = idx.findIndex(x=>x.id===id); if (i<0) return; idx[i].tags = tags; writeIndex(idx); },
  download(id: string){ const rec = Artifacts.load(id); if (!rec) return; const blob = rec.meta.kind==='image/png' ? dataUrlToBlob(rec.data) : new Blob([rec.data], { type: rec.meta.kind }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = safeFilename(rec.meta.name, rec.meta.kind); document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 0); a.remove(); },
};

function approxDataUrlBytes(dataUrl: string){ const i = dataUrl.indexOf(','); if (i<0) return dataUrl.length; const b64 = dataUrl.slice(i+1); return Math.floor(b64.length*3/4); }
function dataUrlToBlob(dataUrl: string){ const [head, b64] = dataUrl.split(','); const mime = /data:(.*?);/.exec(head)?.[1] || 'application/octet-stream'; const bin = atob(b64); const u8 = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return new Blob([u8], { type: mime }); }
function sanitize(s: string){ return s.replace(/[\r\n]+/g,' ').slice(0,180); }
function safeFilename(name: string, kind: ArtifactKind){ const base = name.replace(/\W+/g,'_').replace(/^_+|_+$/g,'') || 'artifact'; const ext = kind==='image/png' ? 'png' : kind==='application/json' ? 'json' : kind==='text/csv' ? 'csv' : 'txt'; return `${base}.${ext}`; }
```

---

## 2) `engine/debugger/domCapture.ts` (new)

```ts
// engine/debugger/domCapture.ts
// Stage 3X â€” Minimal DOM â†’ PNG using SVG foreignObject + inlined computed styles

export async function nodeToPng(node: HTMLElement, opts?: { scale?: number; bg?: string }): Promise<string> {
  const scale = opts?.scale ?? 2;
  const rect = node.getBoundingClientRect();
  const width = Math.max(1, Math.floor(rect.width));
  const height = Math.max(1, Math.floor(rect.height));
  const clone = node.cloneNode(true) as HTMLElement;
  inlineComputedStyles(node, clone);

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  svg.setAttribute('width', String(width));
  svg.setAttribute('height', String(height));
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  const fo = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
  fo.setAttribute('x', '0'); fo.setAttribute('y', '0'); fo.setAttribute('width', String(width)); fo.setAttribute('height', String(height));
  const container = document.createElement('div'); container.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml'); container.style.background = opts?.bg || '#fff'; container.style.width = width+'px'; container.style.height = height+'px'; container.appendChild(clone);
  fo.appendChild(container); svg.appendChild(fo);
  const xml = new XMLSerializer().serializeToString(svg);
  const img = await loadImage('data:image/svg+xml;charset=utf-8,' + encodeURIComponent(xml));
  const canvas = document.createElement('canvas'); canvas.width = Math.floor(width*scale); canvas.height = Math.floor(height*scale);
  const ctx = canvas.getContext('2d')!; ctx.fillStyle = opts?.bg || '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img, 0,0, canvas.width, canvas.height);
  return canvas.toDataURL('image/png');
}

function loadImage(src: string){ return new Promise<HTMLImageElement>((res, rej) => { const img = new Image(); img.onload = () => res(img); img.onerror = rej; img.src = src; }); }

function inlineComputedStyles(src: Element, dst: Element){ const win = src.ownerDocument!.defaultView!; const styles = win.getComputedStyle(src); const styleStr = Array.from(styles).map(k => `${k}:${styles.getPropertyValue(k)};`).join(''); (dst as HTMLElement).setAttribute('style', styleStr);
  const srcKids = Array.from(src.children); const dstKids = Array.from(dst.children); for (let i=0;i<srcKids.length;i++) inlineComputedStyles(srcKids[i], dstKids[i]);
}
```

---

## 3) `engine/debugger/metrics.ts` (new)

```ts
// engine/debugger/metrics.ts
// Stage 3X â€” Simple metrics over timeline

import { ExecutionSnapshot } from './graphTypes';

export type MetricKind = 'ruleCount'|'monadCount'|'edgeCount'|'ticks'|'ruleHistogram';
export interface MetricSpec { id: string; kind: MetricKind; ruleId?: string; label?: string }
export interface MetricRow { id: string; value: number }
export interface MetricBundle { rows: MetricRow[]; hist?: Record<string, number> }

export function computeMetrics(history: ExecutionSnapshot[], specs: MetricSpec[]): MetricBundle {
  const rows: MetricRow[] = [];
  const hist: Record<string, number> = {};
  for (const s of specs) {
    switch (s.kind) {
      case 'ticks': rows.push({ id: s.id, value: history.length }); break;
      case 'monadCount': rows.push({ id: s.id, value: uniqMonads(history).size }); break;
      case 'edgeCount': rows.push({ id: s.id, value: countEdges(history) }); break;
      case 'ruleCount': rows.push({ id: s.id, value: countRule(history, s.ruleId || '') }); break;
      case 'ruleHistogram': Object.entries(histogramRules(history)).forEach(([r,c]) => hist[r]=(hist[r]||0)+c); break;
    }
  }
  return { rows, hist: Object.keys(hist).length?hist:undefined };
}

export function toCSV(m: MetricBundle): string {
  const head = ['id','value'];
  const lines = [head.join(',')];
  for (const r of m.rows) lines.push([csv(r.id), csv(r.value)].join(','));
  if (m.hist) { lines.push(''); lines.push('ruleId,count'); for (const [k,v] of Object.entries(m.hist)) lines.push([csv(k), csv(v)].join(',')); }
  return lines.join('\n');
}

function csv(v: any){ const s = String(v); return /[",\n]/.test(s) ? '"'+s.replace(/"/g,'""')+'"' : s; }

function uniqMonads(h: ExecutionSnapshot[]): Set<string> { const set = new Set<string>(); for (const s of h || []) for (const m of (s.monads||[])) set.add(String((m as any).id)); return set; }
function countEdges(h: ExecutionSnapshot[]): number { let c=0; for (const s of h||[]) for (const m of (s.monads||[])) c += Array.isArray((m as any).neighbors) ? (m as any).neighbors.length : 0; return c; }
function countRule(h: ExecutionSnapshot[], id: string): number { let c=0; for (const s of h||[]) c += (s.rulesFired||[]).filter(r=>r.ruleId===id).length; return c; }
function histogramRules(h: ExecutionSnapshot[]): Record<string, number> { const map: Record<string, number> = {}; for (const s of h||[]) for (const r of (s.rulesFired||[])) map[r.ruleId]=(map[r.ruleId]||0)+1; return map; }
```

---

## 4) `engine/debugger/scenarioRunner.ts` (augment: capture step)

```ts
// Stage 3X â€” Add 'capture' step routed to RunnerEnv.capture helpers

// ...existing imports and types...
export type CaptureWhat = 'dom'|'snapshot'|'trace'|'metrics';
export type CaptureStep = { kind: 'capture'; what: CaptureWhat; name?: string; tags?: string[]; selector?: string; metrics?: import('./metrics').MetricSpec[] };

// Extend Step union
export type Step =
  | { kind: 'openSession'; title: string; index?: number }
  | { kind: 'setIndex'; index: number }
  | { kind: 'step'; delta: number }
  | { kind: 'runMacro'; macroId: string; label?: string }
  | { kind: 'assert'; assertion: Assertion }
  | CaptureStep;

// Extend StepResult
export interface StepResult { kind: Step['kind']; ok: boolean; label?: string; atIndex?: number; logs?: string[]; assertions?: AsrtResult[]; artifacts?: string[] }

// Extend RunnerEnv
export interface RunnerEnv {
  state: StateAdapter;
  actions: ActionsContext;
  loadByTitle: (title: string) => VaultSessionMeta | null;
  capture?: {
    domPng?: (selector: string, name: string, tags?: string[]) => Promise<string | null>; // returns artifact id
    snapshotJSON?: (name: string, tags?: string[]) => string | null;
    traceNDJSON?: (name: string, tags?: string[]) => string | null;
    metricsCSV?: (name: string, specs: import('./metrics').MetricSpec[], tags?: string[]) => string | null;
  }
}

// Inside runScenario loop, add:
if ((step as any).kind === 'capture') {
  const c = step as CaptureStep; const arts: string[] = [];
  if (c.what === 'dom' && env.capture?.domPng && c.selector) {
    const id = await env.capture.domPng(c.selector, c.name || `DOM @ ${env.state.getIndex()}`, c.tags || []); if (id) arts.push(id);
  } else if (c.what === 'snapshot' && env.capture?.snapshotJSON) {
    const id = env.capture.snapshotJSON(c.name || `Snapshot @ ${env.state.getIndex()}`, c.tags || []); if (id) arts.push(id);
  } else if (c.what === 'trace' && env.capture?.traceNDJSON) {
    const id = env.capture.traceNDJSON(c.name || `Trace`, c.tags || []); if (id) arts.push(id);
  } else if (c.what === 'metrics' && env.capture?.metricsCSV) {
    const id = env.capture.metricsCSV(c.name || `Metrics`, c.metrics || [], c.tags || []); if (id) arts.push(id);
  }
  stepsOut.push({ kind: step.kind, ok: arts.length>0, atIndex: env.state.getIndex(), artifacts: arts });
  continue;
}
```

---

## 5) `playground/components/ArtifactsPanel.tsx` (new)

```tsx
// playground/components/ArtifactsPanel.tsx
// Stage 3X â€” Browse/filter/preview artifacts

import React, { useMemo, useState } from 'react';
import { Artifacts, ArtifactMeta } from '../../engine/debugger/artifacts';

export const ArtifactsPanel: React.FC = () => {
  const [items, setItems] = useState<ArtifactMeta[]>(Artifacts.list());
  const [q, setQ] = useState('');
  const [kind, setKind] = useState<'all'|ArtifactMeta['kind']>('all');

  const refresh = () => setItems(Artifacts.list());
  const view = useMemo(() => items.filter(m => {
    const okKind = kind==='all' || m.kind===kind; const qq = q.trim().toLowerCase();
    const okText = !qq || m.name.toLowerCase().includes(qq) || m.tags.some(t=>t.toLowerCase().includes(qq));
    return okKind && okText;
  }), [items, q, kind]);

  return (
    <div className="mpl-artifacts">
      <div className="mpl-art-bar">
        <input placeholder="Search name or tag" value={q} onChange={e=>setQ(e.target.value)} />
        <select value={kind} onChange={e=>setKind(e.target.value as any)}>
          <option value="all">all</option>
          <option value="image/png">image/png</option>
          <option value="application/json">application/json</option>
          <option value="text/plain">text/plain</option>
          <option value="text/csv">text/csv</option>
        </select>
        <button className="mpl-btn" onClick={refresh}>â†» Refresh</button>
        <button className="mpl-btn mpl-danger" onClick={()=>{ if (confirm('Delete ALL artifacts?')) { Artifacts.clearAll(); refresh(); } }}>Clear all</button>
      </div>

      <div className="mpl-art-list">
        {view.map(m => (
          <div key={m.id} className="mpl-art-item">
            <div className="mpl-art-meta">
              <div className="mpl-art-title">{m.name}</div>
              <div className="mpl-art-sub">{new Date(m.createdAt).toLocaleString()} â€¢ {m.kind} â€¢ {(m.size/1024).toFixed(1)} KB</div>
              <div className="mpl-art-tags">{m.tags.map(t => <span key={t} className="mpl-chip">{t}</span>)}</div>
            </div>
            <div className="mpl-art-actions">
              <button className="mpl-btn" onClick={()=>Artifacts.download(m.id)}>â¬‡ Download</button>
              <button className="mpl-btn" onClick={()=>{ const n = prompt('Rename', m.name); if (n!=null) { Artifacts.rename(m.id, n); refresh(); } }}>Rename</button>
              <button className="mpl-btn mpl-danger" onClick={()=>{ Artifacts.remove(m.id); refresh(); }}>Delete</button>
            </div>
            <div className="mpl-art-preview">
              {m.kind==='image/png' ? <img src={Artifacts.load(m.id)?.data} alt={m.name} /> : m.kind==='application/json' ? <pre>{truncate(Artifacts.load(m.id)?.data || '', 2000)}</pre> : <pre>{truncate(Artifacts.load(m.id)?.data || '', 2000)}</pre>}
            </div>
          </div>
        ))}
        {view.length===0 && <div className="mpl-empty">No artifacts match</div>}
      </div>
    </div>
  );
};

function truncate(s: string, n: number){ return s.length>n ? s.slice(0, n) + '\nâ€¦' : s; }
```

---

## 6) `playground/components/DebuggerPanel.tsx` (wire Quick Capture + Artifacts + Scenario hooks)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3X â€” Add Quick Capture, wire runnerEnv.capture, and expose Artifacts panel

// ... keep all imports from 3U/3V/3W ...
import { Artifacts } from '../../engine/debugger/artifacts';
import { nodeToPng } from '../../engine/debugger/domCapture';
import { computeMetrics, toCSV, MetricSpec } from '../../engine/debugger/metrics';
import { ArtifactsPanel } from './ArtifactsPanel';

// inside component body
const rootRef = React.useRef<HTMLDivElement>(null);

// Quick capture state
const [selector, setSelector] = React.useState<string>('.mpl-debugger-panel');
const [shotName, setShotName] = React.useState<string>('State screenshot');

async function quickScreenshot() {
  const root = rootRef.current; if (!root) return;
  const el = root.querySelector(selector) as HTMLElement; if (!el) { console.warn('selector not found', selector); return; }
  const dataUrl = await nodeToPng(el, { scale: 2, bg: '#fff' });
  Artifacts.save('image/png', `${shotName} @ ${idx}`, dataUrl, ['screenshot'], {});
}

function dumpSnapshot(){
  const snap = current || null; const json = JSON.stringify(snap, null, 2);
  Artifacts.save('application/json', `Snapshot @ ${idx}`, json, ['snapshot'], { index: idx });
}

function dumpTraceNDJSON(){
  const lines = (timeline||[]).map(o => JSON.stringify(o)).join('\n');
  Artifacts.save('text/plain', 'trace.ndjson', lines, ['trace']);
}

function dumpMetrics(){
  const specs: MetricSpec[] = [ { id: 'ticks', kind: 'ticks' }, { id: 'monads', kind: 'monadCount' }, { id: 'edges', kind: 'edgeCount' }, { id: 'R1', kind: 'ruleCount', ruleId: 'R1' }, { id: 'rules', kind: 'ruleHistogram' } ];
  const m = computeMetrics(timeline, specs);
  const csv = toCSV(m); Artifacts.save('text/csv', 'metrics.csv', csv, ['metrics']);
  Artifacts.save('application/json', 'metrics.json', JSON.stringify(m, null, 2), ['metrics']);
}

// Extend runnerState/env from 3V/3W wiring
const runnerEnv = React.useMemo(() => ({
  state: runnerState,
  actions: actionsCtx,
  loadByTitle: (title: string) => Vault.list().find(m => m.title === title) || null,
  capture: {
    domPng: async (sel: string, name: string, tags?: string[]) => {
      const el = rootRef.current?.querySelector(sel) as HTMLElement; if (!el) return null;
      const dataUrl = await nodeToPng(el, { scale: 2, bg: '#fff' });
      const meta = Artifacts.save('image/png', name, dataUrl, tags || [], { index: idx });
      return meta.id;
    },
    snapshotJSON: (name: string, tags?: string[]) => { const json = JSON.stringify(current || null, null, 2); return Artifacts.save('application/json', name, json, tags || [], { index: idx }).id; },
    traceNDJSON: (name: string, tags?: string[]) => { const nd = (timeline||[]).map(o => JSON.stringify(o)).join('\n'); return Artifacts.save('text/plain', name.endsWith('.ndjson')?name:name+'.ndjson', nd, tags || []).id; },
    metricsCSV: (name: string, specs, tags?: string[]) => { const m = computeMetrics(timeline, specs || []); const csv = toCSV(m); return Artifacts.save('text/csv', name.endsWith('.csv')?name:name+'.csv', csv, tags || []).id; },
  }
}), [runnerState, actionsCtx, idx, current, timeline]);

// In JSX wrapper div, attach ref
return (
  <div className="mpl-debugger-panel" ref={rootRef}>
    {/* Session I/O as before ... */}

    {/* Quick Capture */}
    <section className="mpl-section">
      <header className="mpl-section-h">Quick Capture</header>
      <div className="mpl-capture">
        <input value={selector} onChange={e=>setSelector(e.target.value)} placeholder="CSS selector (e.g., .mpl-section:has(.TimeScrubber))" />
        <input value={shotName} onChange={e=>setShotName(e.target.value)} placeholder="Screenshot name" />
        <button className="mpl-btn" onClick={quickScreenshot}>ðŸ“¸ Screenshot</button>
        <button className="mpl-btn" onClick={dumpSnapshot}>ðŸ§© Snapshot JSON</button>
        <button className="mpl-btn" onClick={dumpTraceNDJSON}>ðŸ§µ Trace NDJSON</button>
        <button className="mpl-btn" onClick={dumpMetrics}>ðŸ“ˆ Metrics</button>
      </div>
    </section>

    {/* Scenarios (existing) */}
    <section className="mpl-section">
      <header className="mpl-section-h">Scenarios</header>
      <ScenarioRunnerPanel actions={actionsCtx as any} state={runnerState} />
    </section>

    {/* Scenario Matrix (existing) */}
    <section className="mpl-section">
      <header className="mpl-section-h">Scenario Matrix</header>
      <ScenarioMatrixPanel runnerEnv={runnerEnv as any} />
    </section>

    {/* Artifacts */}
    <section className="mpl-section">
      <header className="mpl-section-h">Artifacts</header>
      <ArtifactsPanel />
    </section>

    {/* ...rest of the panel stays as wired in 3Uâ€“3W ... */}
  </div>
);
```

---

## 7) `playground/styles/debugger.css` (additions)

```css
/* Stage 3X â€” Artifacts & Capture */
.mpl-capture { display: grid; grid-template-columns: 2fr 1.6fr auto auto auto auto; gap: 8px; align-items: center; }

.mpl-art-bar { display: grid; grid-template-columns: 1fr auto auto auto; gap: 8px; align-items: center; margin-bottom: 8px; }
.mpl-art-list { display: grid; gap: 8px; }
.mpl-art-item { border: 1px solid #e5e7eb; border-radius: 10px; background: #fff; padding: 8px; display: grid; grid-template-columns: 1fr auto; gap: 8px; }
.mpl-art-meta { display: grid; gap: 4px; }
.mpl-art-title { font-weight: 700; }
.mpl-art-sub { font-size: 12px; color: #6b7280; }
.mpl-art-actions { display: flex; gap: 8px; align-items: center; }
.mpl-art-preview { grid-column: span 2; border-top: 1px dashed #e5e7eb; padding-top: 8px; }
.mpl-art-preview img { max-width: 100%; height: auto; border-radius: 8px; border: 1px solid #e5e7eb; }
.mpl-art-preview pre { max-height: 280px; overflow: auto; background: #0b1021; color: #e5e7eb; padding: 8px; border-radius: 8px; }
```

---

## 8) Example â€” `playground/pages/DebugExample3X.tsx`

```tsx
// playground/pages/DebugExample3X.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3X() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3X â€” Artifact Capture: Screenshots, Metrics, Traces</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 9) Scenario step examples (copy/paste)

* **Screenshot the timeline scrubber**

```json
{"kind":"capture","what":"dom","selector":".mpl-section:has(.mpl-timescrubber), .mpl-section:nth-of-type(2)","name":"Scrubber @ ${index}","tags":["scenario","shot"]}
```

* **Dump current snapshot JSON**

```json
{"kind":"capture","what":"snapshot","name":"Snapshot @ ${index}","tags":["scenario"]}
```

* **Emit metrics CSV**

```json
{"kind":"capture","what":"metrics","name":"metrics.csv","metrics":[{"id":"ticks","kind":"ticks"},{"id":"R1","kind":"ruleCount","ruleId":"R1"},{"id":"monads","kind":"monadCount"}],"tags":["scenario","metrics"]}
```

---

## 10) Notes

* **DOM capture limitations:** external fonts/images must be sameâ€‘origin; styles are inlined via computed styles but pseudoâ€‘elements and videos arenâ€™t captured.
* **Size limits:** localStorage \~5MB; for heavy PNGs swap `Artifacts` storage to IndexedDB but keep the same API.
* **CI uploads:** Use the Artifacts panel to download assets, or script exports via scenario captures.
* **Security:** This is all local. Thereâ€™s no remote upload in this patch.

---

## 11) Changelog â€” Stage 3X

* New engine: `artifacts.ts`, `domCapture.ts`, `metrics.ts`
* Updated engine: `scenarioRunner.ts` (capture step & runner hooks)
* New UI: `ArtifactsPanel.tsx`
* Updated UI: `DebuggerPanel.tsx` (Quick Capture + artifacts + runner capture wiring)
* CSS: capture row + artifacts browser

```
```
