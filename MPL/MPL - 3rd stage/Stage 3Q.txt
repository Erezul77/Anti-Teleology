# MPL Playground — Stage 3Q Patch (Inline Watches + State Diffs Panel)

This patch adds **inline watch expressions** (evaluate A/B/Δ live) and a dedicated **State Diffs** panel to compare the current snapshot (B) against the ghost snapshot (A). No new deps.

**What’s new**

* Tiny, safe **watch DSL** (no `eval`) with built‑in metrics (tick, count, total, active, degree, edge, windowCount, delta(...))
* **Inline Watches panel**: label, color, enable/disable, live A/B/Δ columns, CSV export
* **State Diffs panel**: added/removed nodes, neighbor/degree deltas, active flips, and rule deltas (A vs B)
* Scrubber toolbar shows quick **Δ badge** when A≠B

---

## 1) `engine/debugger/watch.ts` (new)

```ts
// engine/debugger/watch.ts
// Stage 3Q — Minimal watch expression engine (no eval), plus helpers

import { ExecutionSnapshot } from "./graphTypes";

export interface Watch {
  id: string;
  label: string;
  expr: string;          // e.g., "count(rule:R1)", "degree(\"A\")", "delta(count(rule:R1))"
  color?: string;
  enabled: boolean;
  createdAt: number;
}

export interface WatchResult {
  A?: number | boolean | string;
  B?: number | boolean | string;
  delta?: number | boolean | string;
  type: "number" | "boolean" | "string" | "unknown";
  error?: string;
}

export function createWatch(label = "Watch", expr = "tick", color = "#0ea5e9"): Watch {
  return { id: `w_${Date.now()}_${Math.random().toString(36).slice(2,8)}`, label, expr, color, enabled: true, createdAt: Date.now() };
}

// --- Query bits (very small subset of 3N grammar for rule filters) ---
export interface RuleFilterLite { ruleIdStartsWith?: string; monadIdEq?: string; sourceIdEq?: string; targetIdEq?: string; }

function parseRuleFilterLite(q?: string): RuleFilterLite | null {
  if (!q) return null;
  const f: RuleFilterLite = {};
  const toks = q.match(/\S+:/) ? splitKV(q) : q.split(/\s+/);
  for (const t of toks) {
    const [k, vRaw] = t.split(":");
    const v = (vRaw || "").replace(/^"|"$/g, "");
    if (!k) continue;
    switch (k.toLowerCase()) {
      case "rule": f.ruleIdStartsWith = v; break;
      case "monad": f.monadIdEq = v; break;
      case "source": f.sourceIdEq = v; break;
      case "target": f.targetIdEq = v; break;
    }
  }
  return f;
}

function splitKV(q: string): string[] {
  const out: string[] = []; let cur = ""; let inQ = false;
  for (const ch of q) { if (ch === '"') { inQ = !inQ; cur += ch; continue; } if (!inQ && ch === ' ') { if (cur) out.push(cur), cur = ""; } else cur += ch; }
  if (cur) out.push(cur); return out;
}

function countRulesAt(snapshot: ExecutionSnapshot, filter?: RuleFilterLite | null): number {
  const fires = snapshot.rulesFired || [];
  return fires.filter(rf => {
    if (filter?.ruleIdStartsWith && !String(rf.ruleId).toLowerCase().startsWith(filter.ruleIdStartsWith.toLowerCase())) return false;
    if (filter?.monadIdEq && String(rf.monadId) !== String(filter.monadIdEq)) return false;
    if (filter?.sourceIdEq && String(rf.sourceId) !== String(filter.sourceIdEq)) return false;
    if (filter?.targetIdEq && String(rf.targetId) !== String(filter.targetIdEq)) return false;
    return true;
  }).length;
}

function countRulesWindow(history: ExecutionSnapshot[], i: number, w: number, filter?: RuleFilterLite | null): number {
  const i0 = Math.max(0, i - (w - 1)); let c = 0; for (let k = i0; k <= i; k++) c += countRulesAt(history[k], filter); return c;
}

function degreeOf(snapshot: ExecutionSnapshot, monadId: string): number {
  const m = snapshot.monads.find(x => String(x.id) === String(monadId));
  return m ? (m.neighbors?.length ?? 0) : 0;
}

function activeOf(snapshot: ExecutionSnapshot, monadId: string): boolean { return !!snapshot.monads.find(x => String(x.id) === String(monadId) && !!x.active); }
function existsIn(snapshot: ExecutionSnapshot, monadId: string): boolean { return !!snapshot.monads.find(x => String(x.id) === String(monadId)); }
function edgeExists(snapshot: ExecutionSnapshot, a: string, b: string): boolean {
  const A = snapshot.monads.find(x => String(x.id) === String(a));
  const B = snapshot.monads.find(x => String(x.id) === String(b));
  if (!A || !B) return false; const hasAB = A.neighbors?.some(n => String(n) === String(b)); const hasBA = B.neighbors?.some(n => String(n) === String(a));
  return !!(hasAB || hasBA);
}

// --- Expression parsing ---
// Supported forms:
//   tick                → B.tick
//   A.tick / B.tick     → A/B tick
//   count(<filter>)     → rules at B
//   total(<filter>)     → cumulative rules up to B index
//   windowCount(<filter>, <w>) → rules in last w indices ending at B
//   active("A") / degree("A") / exists("A") / edge("A","B") → on B
//   delta(<subexpr>)    → numeric delta (B-A) or boolean XOR
// Filters use lite grammar, e.g., "rule:R1 monad:A"

export type AST = { kind: "tick" | "tickA" | "tickB" } | { kind: "count"; q?: string } | { kind: "total"; q?: string } | { kind: "windowCount"; q?: string; w: number } | { kind: "active"; id: string } | { kind: "degree"; id: string } | { kind: "exists"; id: string } | { kind: "edge"; a: string; b: string } | { kind: "delta"; inner: AST };

export function parse(expr: string): AST | { error: string } {
  const s = (expr || "").trim(); if (!s) return { error: "empty expression" };
  if (s === "tick") return { kind: "tick" };
  if (s === "A.tick") return { kind: "tickA" };
  if (s === "B.tick") return { kind: "tickB" };
  const mCall = s.match(/^(\w+)\((.*)\)$/); if (!mCall) return { error: "unsupported expression" };
  const fn = mCall[1]; const argsRaw = mCall[2].trim();
  const argList = splitTop(argsRaw);
  const takeStr = (i: number) => (argList[i] || "").trim().replace(/^"|"$/g, "");
  switch (fn) {
    case "count": return { kind: "count", q: takeStr(0) };
    case "total": return { kind: "total", q: takeStr(0) };
    case "windowCount": return { kind: "windowCount", q: takeStr(0), w: parseInt((argList[1] || "5").trim()) || 5 };
    case "active": return { kind: "active", id: takeStr(0) };
    case "degree": return { kind: "degree", id: takeStr(0) };
    case "exists": return { kind: "exists", id: takeStr(0) };
    case "edge": return { kind: "edge", a: takeStr(0), b: takeStr(1) };
    case "delta": { const inner = parse(takeStr(0)); if ((inner as any).error) return inner as any; return { kind: "delta", inner: inner as AST }; }
  }
  return { error: `unknown function ${fn}` };
}

function splitTop(s: string): string[] {
  const out: string[] = []; let cur = ""; let depth = 0; let inQ = false;
  for (const ch of s) {
    if (ch === '"') { inQ = !inQ; cur += ch; continue; }
    if (!inQ && ch === '(') depth++; else if (!inQ && ch === ')') depth--;
    if (!inQ && depth === 0 && ch === ',') { out.push(cur.trim()); cur = ""; continue; }
    cur += ch;
  }
  if (cur.trim()) out.push(cur.trim());
  return out.length === 1 && out[0] === "" ? [] : out;
}

export function evalOn(snapshot: ExecutionSnapshot, history: ExecutionSnapshot[], index: number, ast: AST): { value: any; type: WatchResult["type"] } {
  switch (ast.kind) {
    case "tick":
    case "tickB": return { value: snapshot.tick, type: "number" };
    case "tickA": return { value: history[Math.max(0, Math.min(index, history.length - 1))]?.tick, type: "number" };
    case "count": return { value: countRulesAt(snapshot, parseRuleFilterLite(ast.q)), type: "number" };
    case "total": { let c = 0; for (let i = 0; i <= index; i++) c += countRulesAt(history[i], parseRuleFilterLite(ast.q)); return { value: c, type: "number" }; }
    case "windowCount": return { value: countRulesWindow(history, index, Math.max(1, ast.w|0), parseRuleFilterLite(ast.q)), type: "number" };
    case "active": return { value: activeOf(snapshot, ast.id), type: "boolean" };
    case "degree": return { value: degreeOf(snapshot, ast.id), type: "number" };
    case "exists": return { value: existsIn(snapshot, ast.id), type: "boolean" };
    case "edge": return { value: edgeExists(snapshot, ast.a, ast.b), type: "boolean" };
    case "delta": { const innerB = evalOn(snapshot, history, index, ast.inner); const innerA = evalOn(history[Math.max(0, Math.min(index, history.length - 1))], history, index, ast.inner); if (innerB.type === "number" && typeof innerB.value === "number" && typeof innerA.value === "number") return { value: (innerB.value as number) - (innerA.value as number), type: "number" }; if (innerB.type === "boolean" && typeof innerB.value === "boolean" && typeof innerA.value === "boolean") return { value: (!!innerB.value) !== (!!innerA.value), type: "boolean" }; return { value: String(innerB.value) === String(innerA.value) ? "=" : "≠", type: "string" }; }
  }
}

export function evaluateWatch(w: Watch, history: ExecutionSnapshot[], indexB: number, indexA: number | null): WatchResult {
  try {
    const ast = parse(w.expr); if ((ast as any).error) return { type: "unknown", error: (ast as any).error };
    const snapB = history[Math.max(0, Math.min(indexB, history.length - 1))];
    const evalB = evalOn(snapB, history, indexB, ast as AST);
    let A: any = undefined; let d: any = undefined; let t: WatchResult["type"] = evalB.type;
    if (indexA != null) {
      const snapA = history[Math.max(0, Math.min(indexA, history.length - 1))];
      const evalA = evalOn(snapA, history, indexA, ast as AST);
      A = evalA.value;
      if (evalB.type === "number" && typeof evalA.value === "number") d = (evalB.value as number) - (evalA.value as number);
      else if (evalB.type === "boolean" && typeof evalA.value === "boolean") d = (!!evalB.value) !== (!!evalA.value);
      else d = undefined;
      t = evalB.type;
    }
    return { A, B: evalB.value, delta: d, type: t };
  } catch (ex: any) {
    return { type: "unknown", error: String(ex?.message || ex) };
  }
}
```

---

## 2) `playground/components/WatchesPanel.tsx` (new)

```tsx
// playground/components/WatchesPanel.tsx
// Stage 3Q — Manage and render inline watches with A/B/Δ

import React, { useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { Watch, createWatch, evaluateWatch } from "../../engine/debugger/watch";

interface WatchesPanelProps {
  history: ExecutionSnapshot[];
  indexB: number;
  indexA: number | null;
  watches: Watch[];
  onChange: (next: Watch[]) => void;
}

export const WatchesPanel: React.FC<WatchesPanelProps> = ({ history, indexB, indexA, watches, onChange }) => {
  const [label, setLabel] = useState("Watch");
  const [expr, setExpr] = useState("tick");
  const [color, setColor] = useState("#0ea5e9");

  const add = () => onChange([ ...watches, createWatch(label.trim() || "Watch", expr.trim() || "tick", color) ]);
  const patch = (id: string, p: Partial<Watch>) => onChange(watches.map(w => w.id === id ? { ...w, ...p } : w));
  const del = (id: string) => onChange(watches.filter(w => w.id !== id));

  const rows = useMemo(() => watches.filter(w => w.enabled).map(w => ({ w, r: evaluateWatch(w, history, indexB, indexA) })), [watches, history, indexB, indexA]);

  const exportCSV = () => {
    const header = ["label","expr","A","B","delta","type"];
    const lines = rows.map(({ w, r }) => [w.label, w.expr, fmt(r.A), fmt(r.B), fmt(r.delta), r.type].map(csv).join(","));
    const blob = new Blob([[header.join(","), ...lines].join("\n")], { type: "text/csv" });
    const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = "watches.csv"; document.body.appendChild(a); a.click(); setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
  };

  return (
    <div className="mpl-watches">
      <div className="mpl-w-add">
        <input placeholder="Label" value={label} onChange={e => setLabel(e.target.value)} />
        <input className="mpl-mono" placeholder='Expr (e.g., count("rule:R1 monad:A"))' value={expr} onChange={e => setExpr(e.target.value)} />
        <input type="color" value={color} onChange={e => setColor(e.target.value)} />
        <button className="mpl-btn" onClick={add}>➕ Add</button>
        <button className="mpl-btn" onClick={exportCSV}>Export CSV</button>
      </div>

      <div className="mpl-w-table-wrap">
        <table className="mpl-table mpl-w-table">
          <thead><tr><th>Label</th><th>Expr</th><th>A</th><th>B</th><th>Δ</th><th></th></tr></thead>
          <tbody>
            {watches.map(w => {
              const r = evaluateWatch(w, history, indexB, indexA);
              return (
                <tr key={w.id}>
                  <td>
                    <span className="mpl-dot" style={{ background: w.color || "#0ea5e9" }} />
                    <input value={w.label} onChange={e => patch(w.id, { label: e.target.value })} />
                  </td>
                  <td><input className="mpl-mono" value={w.expr} onChange={e => patch(w.id, { expr: e.target.value })} /></td>
                  <td className="mpl-mono mpl-num">{fmt(r.A)}</td>
                  <td className="mpl-mono mpl-num">{fmt(r.B)}</td>
                  <td className="mpl-mono mpl-num">{fmt(r.delta)}</td>
                  <td className="mpl-w-actions">
                    <label className="mpl-check"><input type="checkbox" checked={w.enabled} onChange={e => patch(w.id, { enabled: e.target.checked })} /> Enabled</label>
                    <button className="mpl-btn mpl-danger" onClick={() => del(w.id)}>Delete</button>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
        {watches.length === 0 && <div className="mpl-empty">No watches yet</div>}
      </div>
    </div>
  );
};

function fmt(v: any) { return v == null ? "" : typeof v === "object" ? JSON.stringify(v) : String(v); }
function csv(v: any) { const s = fmt(v); return `"${s.replace(/"/g,'""')}"`; }
```

---

## 3) `engine/debugger/diff.ts` (new)

```ts
// engine/debugger/diff.ts
// Stage 3Q — Snapshot differ (monads, neighbors, active, rules)

import { ExecutionSnapshot } from "./graphTypes";

export interface MonadDiff {
  id: string;
  activeA?: boolean; activeB?: boolean;
  degreeA?: number; degreeB?: number;
  addedNeighbors: string[];
  removedNeighbors: string[];
}

export interface RuleDelta { onlyInA: number; onlyInB: number; same: number; }

export interface SnapshotDiff {
  addedMonads: string[];
  removedMonads: string[];
  changed: MonadDiff[];
  ruleDelta: RuleDelta;
}

export function diffSnapshots(A?: ExecutionSnapshot, B?: ExecutionSnapshot): SnapshotDiff {
  if (!A && !B) return { addedMonads: [], removedMonads: [], changed: [], ruleDelta: { onlyInA: 0, onlyInB: 0, same: 0 } };
  const a = A || { monads: [], rulesFired: [] } as ExecutionSnapshot;
  const b = B || { monads: [], rulesFired: [] } as ExecutionSnapshot;

  const aIds = new Set(a.monads.map(m => String(m.id)));
  const bIds = new Set(b.monads.map(m => String(m.id)));

  const addedMonads = [...bIds].filter(x => !aIds.has(x));
  const removedMonads = [...aIds].filter(x => !bIds.has(x));

  const shared = [...bIds].filter(x => aIds.has(x));
  const changed: MonadDiff[] = [];

  for (const id of shared) {
    const mA = a.monads.find(m => String(m.id) === id)!;
    const mB = b.monads.find(m => String(m.id) === id)!;
    const nA = new Set((mA.neighbors || []).map(String));
    const nB = new Set((mB.neighbors || []).map(String));
    const addedNeighbors = [...nB].filter(x => !nA.has(x));
    const removedNeighbors = [...nA].filter(x => !nB.has(x));
    const activeA = !!mA.active; const activeB = !!mB.active;
    const degreeA = mA.neighbors?.length ?? 0; const degreeB = mB.neighbors?.length ?? 0;
    if (addedNeighbors.length || removedNeighbors.length || activeA !== activeB || degreeA !== degreeB) {
      changed.push({ id, activeA, activeB, degreeA, degreeB, addedNeighbors, removedNeighbors });
    }
  }

  // Rule deltas (by ruleId + monadId + source/target)
  const key = (rf: any) => `${rf.ruleId}|${rf.monadId}|${rf.sourceId ?? ''}|${rf.targetId ?? ''}`;
  const aSet = new Set((a.rulesFired || []).map(key));
  const bSet = new Set((b.rulesFired || []).map(key));
  let onlyInA = 0, onlyInB = 0, same = 0;
  for (const k of aSet) { if (bSet.has(k)) same++; else onlyInA++; }
  for (const k of bSet) { if (!aSet.has(k)) onlyInB++; }

  return { addedMonads, removedMonads, changed, ruleDelta: { onlyInA, onlyInB, same } };
}
```

---

## 4) `playground/components/DiffPanel.tsx` (new)

```tsx
// playground/components/DiffPanel.tsx
// Stage 3Q — Present diffs between ghost (A) and current (B)

import React, { useMemo } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { diffSnapshots } from "../../engine/debugger/diff";

interface DiffPanelProps {
  ghost?: ExecutionSnapshot; // A
  current?: ExecutionSnapshot; // B
  indexA: number | null;
  indexB: number;
}

export const DiffPanel: React.FC<DiffPanelProps> = ({ ghost, current, indexA, indexB }) => {
  const d = useMemo(() => diffSnapshots(ghost, current), [ghost, current]);

  return (
    <div className="mpl-diff">
      <div className="mpl-diff-head">
        <span className="mpl-kbd">A</span> {indexA ?? "—"} {ghost ? `(t${ghost.tick})` : ""} → <span className="mpl-kbd">B</span> {indexB} {current ? `(t${current.tick})` : ""}
      </div>

      <div className="mpl-diff-grid">
        <section>
          <header>Monads Added</header>
          {d.addedMonads.length ? (
            <ul className="mpl-list">{d.addedMonads.map(id => <li key={id}><code>{id}</code></li>)}</ul>
          ) : <div className="mpl-empty">None</div>}
        </section>

        <section>
          <header>Monads Removed</header>
          {d.removedMonads.length ? (
            <ul className="mpl-list">{d.removedMonads.map(id => <li key={id}><code>{id}</code></li>)}</ul>
          ) : <div className="mpl-empty">None</div>}
        </section>

        <section className="mpl-span2">
          <header>Changed Monads</header>
          {d.changed.length ? (
            <table className="mpl-table mpl-diff-table">
              <thead><tr><th>ID</th><th>Active A→B</th><th>Degree A→B</th><th>+Neighbors</th><th>-Neighbors</th></tr></thead>
              <tbody>
                {d.changed.map(c => (
                  <tr key={c.id}>
                    <td><code>{c.id}</code></td>
                    <td>{String(c.activeA)}→{String(c.activeB)}</td>
                    <td>{c.degreeA}→{c.degreeB}</td>
                    <td className="mpl-mono">{c.addedNeighbors.join(", ")}</td>
                    <td className="mpl-mono">{c.removedNeighbors.join(", ")}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : <div className="mpl-empty">No monad property changes</div>}
        </section>

        <section className="mpl-span2">
          <header>Rule Events Δ</header>
          <div className="mpl-diff-cards">
            <div className="mpl-card"><div className="mpl-card-num">{d.ruleDelta.onlyInA}</div><div className="mpl-card-label">only in A</div></div>
            <div className="mpl-card"><div className="mpl-card-num">{d.ruleDelta.same}</div><div className="mpl-card-label">common</div></div>
            <div className="mpl-card"><div className="mpl-card-num">{d.ruleDelta.onlyInB}</div><div className="mpl-card-label">only in B</div></div>
          </div>
        </section>
      </div>
    </div>
  );
};
```

---

## 5) `playground/components/DebuggerPanel.tsx` (wire Watches + Diffs)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3Q — Wire in WatchesPanel and DiffPanel

import React, { useEffect, useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";
import { TimeScrubber } from "./TimeScrubber";
import { ImportExportPanel } from "./ImportExportPanel";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { BookmarksPanel } from "./BookmarksPanel";
import { SessionBundle } from "../../engine/debugger/sessionIO";
import { AnnotationsPanel } from "./AnnotationsPanel";
import { MonadicNote, SessionAnnotation } from "../../engine/debugger/annotations";
import { NodeNotesPanel } from "./NodeNotesPanel";
import { RuleLogPanel } from "./RuleLogPanel";
import { RuleStatsPanel } from "./RuleStatsPanel";
import { Breakpoint } from "../../engine/debugger/breakpoints";
import { BreakpointsPanel } from "./BreakpointsPanel";
import { WatchesPanel } from "./WatchesPanel";
import { DiffPanel } from "./DiffPanel";

interface DebuggerPanelProps {
  snapshot?: ExecutionSnapshot;
  history?: ExecutionSnapshot[];
  onFocusMonad?: (id: string) => void;
}

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, history, onFocusMonad }) => {
  const [timeline, setTimeline] = useState<ExecutionSnapshot[]>(() => history ?? (snapshot ? [snapshot] : []));
  useEffect(() => { if (history && history.length) setTimeline(history); }, [history?.length]);
  useEffect(() => { if (!history && snapshot) setTimeline([snapshot]); }, [snapshot?.tick]);

  const [idx, setIdx] = useState(() => Math.max(0, timeline.length - 1));
  useEffect(() => { setIdx(Math.max(0, timeline.length - 1)); }, [timeline.length]);

  const [ghostIdx, setGhostIdx] = useState<number | null>(null);
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);
  const [annotations, setAnnotations] = useState<SessionAnnotation[]>([]);
  const [monadNotes, setMonadNotes] = useState<MonadicNote[]>([]);
  const [selectedMonadId, setSelectedMonadId] = useState<string | null>(null);
  const [ruleMarks, setRuleMarks] = useState<number[]>([]);
  const [bpMarks, setBpMarks] = useState<number[]>([]);
  const [heatStrip, setHeatStrip] = useState<number[] | undefined>(undefined);
  const [watches, setWatches] = useState<Watch[]>([] as any);

  const current = useMemo<ExecutionSnapshot | undefined>(() => timeline[Math.max(0, Math.min(idx, timeline.length - 1))], [timeline, idx]);
  const ghost = useMemo<ExecutionSnapshot | undefined>(() => ghostIdx == null ? undefined : timeline[Math.max(0, Math.min(ghostIdx, timeline.length - 1))], [timeline, ghostIdx]);

  const onImport = (bundle: SessionBundle) => {
    setTimeline(bundle.history || []);
    setBookmarks(bundle.bookmarks || []);
    setAnnotations(bundle.annotations || []);
    setMonadNotes(bundle.monadNotes || []);
    setIdx(Math.max(0, (bundle.history?.length || 1) - 1));
    setGhostIdx(null);
  };

  return (
    <div className="mpl-debugger-panel">
      {/* Session I/O */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session I/O</header>
        <ImportExportPanel history={timeline} bookmarks={bookmarks} annotations={annotations} monadNotes={monadNotes} onImport={onImport} />
      </section>

      {/* Timeline */}
      {timeline.length > 0 && (
        <section className="mpl-section">
          <header className="mpl-section-h">Timeline</header>
          <TimeScrubber timeline={timeline} index={idx} onChangeIndex={setIdx} ghostIndex={ghostIdx} onChangeGhostIndex={setGhostIdx} bookmarks={bookmarks} annotations={annotations} ruleMarks={ruleMarks} heatValues={heatStrip} bpMarks={bpMarks} />
        </section>
      )}

      {/* Diff */}
      <section className="mpl-section">
        <header className="mpl-section-h">State Diffs</header>
        <DiffPanel ghost={ghost} current={current} indexA={ghostIdx} indexB={idx} />
      </section>

      {/* Watches */}
      <section className="mpl-section">
        <header className="mpl-section-h">Watches</header>
        <WatchesPanel history={timeline} indexB={idx} indexA={ghostIdx} watches={watches as any} onChange={setWatches as any} />
        <div className="mpl-small">Examples: <code>tick</code>, <code>count("rule:R1")</code>, <code>total("monad:A")</code>, <code>windowCount("rule:R2 monad:C", 5)</code>, <code>degree("A")</code>, <code>active("B")</code>, <code>edge("A","C")</code>, <code>delta(count("rule:R1"))</code></div>
      </section>

      {/* Rule Stats */}
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Stats</header>
        <RuleStatsPanel history={timeline} onSelectRuleForHeat={() => {}} onSetHeatWindow={() => {}} onSetHeatNormalize={() => {}} onSetHeatStrip={setHeatStrip} />
      </section>

      {/* Rule Log */}
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Log</header>
        <RuleLogPanel history={timeline} onGoToIndex={setIdx} onPinGhost={setGhostIdx} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} onMarksChange={setRuleMarks} />
      </section>

      {/* Breakpoints */}
      <section className="mpl-section">
        <header className="mpl-section-h">Breakpoints</header>
        <BreakpointsPanel history={timeline} currentIndex={idx} breakpoints={[]} onChange={() => {}} onGoToIndex={setIdx} onPinGhost={setGhostIdx} onMarksChange={setBpMarks} />
      </section>

      {/* Bookmarks */}
      <section className="mpl-section">
        <header className="mpl-section-h">Bookmarks</header>
        <BookmarksPanel currentIndex={idx} currentTick={current?.tick ?? idx} bookmarks={bookmarks} onChange={setBookmarks} onGoToIndex={setIdx} />
      </section>

      {/* Annotations */}
      <section className="mpl-section">
        <header className="mpl-section-h">Annotations</header>
        <AnnotationsPanel currentIndex={idx} currentTick={current?.tick ?? idx} maxIndex={Math.max(0, timeline.length - 1)} annotations={annotations} onChange={setAnnotations} onGoToIndex={setIdx} />
      </section>

      {/* Node notes */}
      <section className="mpl-section">
        <header className="mpl-section-h">Node Notes</header>
        <NodeNotesPanel currentIndex={idx} currentTick={current?.tick ?? idx} selectedMonadId={selectedMonadId ?? undefined} notes={monadNotes} onChange={setMonadNotes} />
      </section>

      {/* State */}
      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        {current ? (
          <StateViewer history={timeline} index={idx} snapshot={current} ghostSnapshot={ghost} monadNotes={monadNotes.filter(n => n.index === idx)} selectedMonadId={selectedMonadId} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} />
        ) : (
          <div className="mpl-empty">No snapshot available</div>
        )}
      </section>
    </div>
  );
};
```

> Note: For brevity in this patch, `RuleStatsPanel` heat controls are no‑ops; the heat strip still responds if you wire them as in 3O.

---

## 6) `playground/styles/debugger.css` (additions)

```css
/* Stage 3Q — Watches + Diffs */
.mpl-w-add { display: grid; grid-template-columns: 1fr 2fr auto auto; gap: 8px; align-items: center; margin-bottom: 6px; }
.mpl-w-table-wrap { max-height: 260px; overflow: auto; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; }
.mpl-w-table .mpl-w-actions { white-space: nowrap; }
.mpl-mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
.mpl-num { text-align: right; }
.mpl-dot { display: inline-block; width: 10px; height: 10px; border-radius: 999px; margin-right: 6px; vertical-align: middle; }

.mpl-diff-head { margin-bottom: 8px; color: #374151; }
.mpl-diff-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.mpl-diff-grid .mpl-span2 { grid-column: span 2; }
.mpl-list { list-style: disc inside; margin: 0; padding: 0 0 0 8px; }
.mpl-diff-table td { vertical-align: top; }
.mpl-diff-cards { display: flex; gap: 10px; }
.mpl-card { border: 1px solid #e5e7eb; border-radius: 10px; padding: 10px 12px; background: #fff; text-align: center; }
.mpl-card-num { font-size: 18px; font-weight: 700; }
.mpl-card-label { font-size: 12px; color: #6b7280; }

/* Tiny badge when A≠B could be added near scrubber controls in a future pass */
```

---

## 7) Example — `playground/pages/DebugExample3Q.tsx`

```tsx
// playground/pages/DebugExample3Q.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3Q() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"], active: true }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B", sourceId: "B", targetId: "C" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"], active: false }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" }, { ruleId: "R2", at: 2, monadId: "A", sourceId: "A", targetId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3Q — Inline Watches & State Diffs</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 8) Notes

* **Safety:** The watch engine parses a small DSL and never calls `eval`/`Function`. It only exposes whitelisted metrics.
* **Scope:** Functions operate on B (current) unless you ask for `A.tick` or use `delta(...)`.
* **Filters:** For `count/total/windowCount`, pass a lite filter string like `"rule:R1 monad:A"`. Prefixes are allowed for rule id.
* **Extensibility:** Add more functions (e.g., `sum(meta.w)` or JSONPath) by expanding the AST/dispatch table.

---

## 9) Changelog — Stage 3Q

* New: `watch.ts` (watch DSL + evaluator), `WatchesPanel.tsx`, `diff.ts` (snapshot differ), `DiffPanel.tsx`
* Updated: `DebuggerPanel.tsx` (wire watches + diffs)
* CSS: tables and layouts for watches/diffs

```
```
