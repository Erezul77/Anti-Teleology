# MPL Playground — Stage 3O Patch (Rule‑Level Stats + Heatmaps)

This patch layers **rule analytics** and **heatmap visualizations** on top of 3I–3N:

* **Rule Stats:** totals per rule, per‑tick series, per‑monad hit counts
* **Graph Heatmap:** color nodes by recent rule activity (all rules or one rule)
* **Timeline Heat Strip:** intensity band showing activity over time
* **Stats Panel:** sortable table with mini sparklines; click a rule to drive the heatmap & timeline
* No new deps (pure TS + React + SVG)

---

## 1) `engine/debugger/ruleStats.ts` (new)

```ts
// engine/debugger/ruleStats.ts
// Stage 3O — Rule aggregations + node heat helpers

import { ExecutionSnapshot, RuleFire } from "./graphTypes";

export interface RuleSeries {
  total: number;
  perIndex: number[];                         // length = history.length
  perMonad: Map<string, number>;              // monadId -> count
}

export interface RuleStats {
  ruleIds: string[];
  byRule: Map<string, RuleSeries>;
  all: RuleSeries;                            // aggregated across all rules
}

export function buildRuleStats(history: ExecutionSnapshot[]): RuleStats {
  const N = history.length;
  const byRule = new Map<string, RuleSeries>();
  const ensure = (ruleId: string): RuleSeries => {
    let rs = byRule.get(ruleId);
    if (!rs) { rs = { total: 0, perIndex: new Array(N).fill(0), perMonad: new Map() }; byRule.set(ruleId, rs); }
    return rs;
  };

  const all: RuleSeries = { total: 0, perIndex: new Array(N).fill(0), perMonad: new Map() };

  for (let i = 0; i < N; i++) {
    const s = history[i];
    const fires = s.rulesFired || [];
    all.perIndex[i] += fires.length;
    all.total += fires.length;
    for (const rf of fires) {
      const id = rf.ruleId;
      const rs = ensure(id);
      rs.total += 1;
      rs.perIndex[i] += 1;
      const k = String(rf.monadId);
      rs.perMonad.set(k, (rs.perMonad.get(k) || 0) + 1);
      all.perMonad.set(k, (all.perMonad.get(k) || 0) + 1);
    }
  }

  const ruleIds = [...byRule.keys()].sort();
  return { ruleIds, byRule, all };
}

export interface HeatOptions {
  windowSize?: number;               // number of indices to look back (default 5)
  ruleId?: string | null;            // undefined/null => ALL rules
  normalize?: "local" | "global";   // local: max within current window; global: max over history
}

export interface NodeHeat { [monadId: string]: number; } // 0..1 after normalization

export function computeNodeHeat(history: ExecutionSnapshot[], stats: RuleStats, index: number, opts?: HeatOptions): NodeHeat {
  const N = history.length; if (N === 0) return {};
  const i0 = Math.max(0, index - ((opts?.windowSize ?? 5) - 1));
  const i1 = Math.min(N - 1, index);
  const ruleId = opts?.ruleId ?? null;

  const acc = new Map<string, number>();
  for (let i = i0; i <= i1; i++) {
    const fires = history[i].rulesFired || [];
    for (const rf of fires) {
      if (ruleId && rf.ruleId !== ruleId) continue;
      const k = String(rf.monadId);
      acc.set(k, (acc.get(k) || 0) + 1);
    }
  }

  // normalization
  let maxVal = 0;
  if (opts?.normalize === "global") {
    if (ruleId) {
      const rs = stats.byRule.get(ruleId);
      if (rs) { for (const v of rs.perMonad.values()) maxVal = Math.max(maxVal, v); }
    } else {
      for (const v of stats.all.perMonad.values()) maxVal = Math.max(maxVal, v);
    }
  } else {
    for (const v of acc.values()) maxVal = Math.max(maxVal, v);
  }

  const out: NodeHeat = {};
  if (maxVal <= 0) return out;
  for (const [k, v] of acc.entries()) out[k] = v / maxVal;
  return out;
}

export function normalizeSeriesToUnit(xs: number[]): number[] {
  let m = 0; for (const v of xs) m = Math.max(m, v);
  return m > 0 ? xs.map(v => v / m) : xs.map(() => 0);
}
```

---

## 2) `playground/components/HeatLegend.tsx` (new)

```tsx
// playground/components/HeatLegend.tsx
// Stage 3O — Simple HSL gradient legend for node heat

import React from "react";

export const HeatLegend: React.FC<{ minLabel?: string; maxLabel?: string }> = ({ minLabel = "low", maxLabel = "high" }) => {
  return (
    <div className="mpl-heat-legend">
      <div className="mpl-heat-bar" />
      <div className="mpl-heat-labels"><span>{minLabel}</span><span>{maxLabel}</span></div>
    </div>
  );
};
```

---

## 3) `playground/components/GraphStateView.tsx` (augment: node heat overlay)

```tsx
// playground/components/GraphStateView.tsx
// Stage 3O — Add node heat coloring (HSL 220→0 by intensity)

import React, { useCallback, useMemo, useRef, useState, useEffect } from "react";
import { ExecutionSnapshot, GraphData } from "../../engine/debugger/graphTypes";
import { buildGraphFromSnapshot } from "../../engine/debugger/toGraph";
import { MonadicNote } from "../../engine/debugger/annotations";

interface GraphStateViewProps {
  snapshot: ExecutionSnapshot;
  ghostSnapshot?: ExecutionSnapshot;
  width?: number; height?: number;
  onSelectMonad?: (id: string) => void;
  neighborFocusMode?: boolean;
  highlightRules?: boolean; highlightWindowTicks?: number;
  diffMode?: boolean;
  monadNotes?: MonadicNote[];
  selectedMonadId?: string | null;
  nodeHeat?: { [monadId: string]: number }; // 0..1 intensity
}

function useMeasure(ref: React.RefObject<HTMLElement>) {
  const [size, setSize] = useState<{ width: number; height: number }>({ width: 300, height: 200 });
  useEffect(() => { if (!ref.current) return; const ro = new ResizeObserver(([entry]) => setSize({ width: entry.contentRect.width, height: entry.contentRect.height })); ro.observe(ref.current); return () => ro.disconnect(); }, [ref]);
  return size;
}

function heatColor(v?: number): string | undefined {
  if (v == null) return undefined;
  const t = Math.max(0, Math.min(1, v));
  const hue = 220 - 220 * t; // 220 (blue) → 0 (red)
  const sat = 85; const light = 50 - 10 * t; // slightly darker when hot
  return `hsl(${hue}, ${sat}%, ${light}%)`;
}

export const GraphStateView: React.FC<GraphStateViewProps> = ({ snapshot, ghostSnapshot, width, height, onSelectMonad, neighborFocusMode, highlightRules = true, highlightWindowTicks = 3, diffMode = true, monadNotes = [], selectedMonadId = null, nodeHeat = {} }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const size = useMeasure(containerRef);
  const W = width ?? size.width ?? 600; const H = height ?? size.height ?? 400;

  const graph: GraphData = useMemo(() => buildGraphFromSnapshot(snapshot, { nodeRadius: 14, spacing: 80 }), [snapshot]);
  const ghost: GraphData | null = useMemo(() => ghostSnapshot ? buildGraphFromSnapshot(ghostSnapshot, { nodeRadius: 12, spacing: 80 }) : null, [ghostSnapshot]);

  const notesByNode = useMemo(() => {
    const map = new Map<string, MonadicNote[]>();
    for (const n of monadNotes) { const k = String(n.monadId); const arr = map.get(k) || []; arr.push(n); map.set(k, arr); }
    return map;
  }, [monadNotes]);

  // Pan/Zoom
  const [zoom, setZoom] = useState(1); const [offset, setOffset] = useState({ x: 0, y: 0 });
  const dragRef = useRef<{ x: number; y: number } | null>(null);
  const onWheel = useCallback((e: React.WheelEvent) => { e.preventDefault(); const f = Math.exp(-e.deltaY * 0.001); setZoom(z => Math.min(4, Math.max(0.25, z * f))); }, []);
  const onMouseDown = useCallback((e: React.MouseEvent) => { dragRef.current = { x: e.clientX, y: e.clientY }; }, []);
  const onMouseMove = useCallback((e: React.MouseEvent) => { if (!dragRef.current) return; const dx = e.clientX - dragRef.current.x; const dy = e.clientY - dragRef.current.y; dragRef.current = { x: e.clientX, y: e.clientY }; setOffset(o => ({ x: o.x + dx, y: o.y + dy })); }, []);
  const onMouseUp = useCallback(() => { dragRef.current = null; }, []);

  const neighborSet = useMemo(() => { if (!neighborFocusMode) return null as null | Set<string>; const focusId = snapshot.focusMonadId != null ? String(snapshot.focusMonadId) : (graph.nodes.find(n => n.active)?.id ?? null); if (!focusId) return null; const s = new Set<string>(); for (const e of graph.edges) { if (e.source === focusId) s.add(e.target); if (e.target === focusId) s.add(e.source); } s.add(focusId); return s; }, [neighborFocusMode, graph, snapshot.focusMonadId]);
  const isRecent = useCallback((at?: number) => { if (at == null) return false; const dt = snapshot.tick - at; return dt >= 0 && dt <= (highlightWindowTicks ?? 3); }, [snapshot.tick, highlightWindowTicks]);

  return (
    <div ref={containerRef} className="mpl-graph-container" style={{ width: width ? `${width}px` : "100%", height: height ? `${height}px` : "100%" }}>
      <svg className="mpl-graph-svg" width={W} height={H} onWheel={onWheel} onMouseDown={onMouseDown} onMouseMove={onMouseMove} onMouseUp={onMouseUp}>
        <defs>
          <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" /></marker>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="3" result="coloredBlur" /><feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge></filter>
        </defs>

        <g transform={`translate(${W / 2 + offset.x}, ${H / 2 + offset.y}) scale(${zoom})`}>
          {/* Ghost layer */}
          {ghost && (
            <g className="mpl-ghost-layer">
              {ghost.edges.map(e => { const a = ghost.nodes.find(n => n.id === e.source)!; const b = ghost.nodes.find(n => n.id === e.target)!; return <line key={`g-${e.id}`} x1={a.x} y1={a.y} x2={b.x} y2={b.y} className="mpl-ghost-edge" />; })}
              {ghost.nodes.map(n => (
                <g key={`g-${n.id}`} transform={`translate(${n.x}, ${n.y})`} className="mpl-ghost-node">
                  <circle r={n.radius} className="mpl-ghost-node-circle" />
                  <text className="mpl-ghost-node-label" y={n.radius + 12} textAnchor="middle">{n.label ?? n.id}</text>
                </g>
              ))}
            </g>
          )}

          {/* Current layer */}
          {graph.edges.map(e => { const a = graph.nodes.find(n => n.id === e.source)!; const b = graph.nodes.find(n => n.id === e.target)!; const dimmed = neighborSet && !(neighborSet.has(a.id) && neighborSet.has(b.id)); return <line key={e.id} x1={a.x} y1={a.y} x2={b.x} y2={b.y} className={`mpl-edge ${dimmed ? "mpl-dim" : ""}`} />; })}

          {graph.nodes.map(n => {
            const dimmed = neighborSet && !neighborSet.has(n.id);
            const fired = !!(highlightRules && isRecent(n.lastRuleAt));
            const selected = selectedMonadId != null && String(selectedMonadId) === n.id;
            const nodeNotes = notesByNode.get(n.id) || [];
            const heat = nodeHeat[n.id];
            const fill = heatColor(heat);
            return (
              <g key={n.id} transform={`translate(${n.x}, ${n.y})`} className="mpl-node" onClick={() => onSelectMonad?.(n.id)}>
                <circle r={n.radius} className={`mpl-node-circle ${n.active ? "mpl-node-active" : ""} ${dimmed ? "mpl-dim" : ""} ${fired ? "mpl-node-fired" : ""} ${selected ? "mpl-node-selected" : ""}`} filter={(n.active || fired || selected) ? "url(#glow)" : undefined} fill={fill} />
                <text className={`mpl-node-label ${dimmed ? "mpl-dim" : ""}`} y={n.radius + 14} textAnchor="middle">{n.label ?? n.id}</text>
                {nodeNotes.length > 0 && (
                  <g className="mpl-node-note-badge" transform={`translate(${n.radius * 0.9}, ${-n.radius * 0.9})`}>
                    <circle r={9} className="mpl-note-circle" />
                    <text textAnchor="middle" dominantBaseline="central" className="mpl-note-text">✎</text>
                    <title>{nodeNotes.map(m => (m.title ? `${m.title}: ` : "") + m.text).join("\n")}</title>
                  </g>
                )}
              </g>
            );
          })}
        </g>
      </svg>
    </div>
  );
};
```

---

## 4) `playground/components/RuleStatsPanel.tsx` (new)

```tsx
// playground/components/RuleStatsPanel.tsx
// Stage 3O — Rule totals, per-tick sparkline, and actions to drive heatmap/timeline

import React, { useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { RuleStats, buildRuleStats, normalizeSeriesToUnit } from "../../engine/debugger/ruleStats";

interface RuleStatsPanelProps {
  history: ExecutionSnapshot[];
  onSelectRuleForHeat: (ruleId: string | null) => void; // null => ALL
  onSetHeatWindow: (w: number) => void;
  onSetHeatNormalize: (n: "local" | "global") => void;
  onSetHeatStrip: (values: number[]) => void;          // 0..1 per index
}

export const RuleStatsPanel: React.FC<RuleStatsPanelProps> = ({ history, onSelectRuleForHeat, onSetHeatWindow, onSetHeatNormalize, onSetHeatStrip }) => {
  const stats = useMemo<RuleStats>(() => buildRuleStats(history), [history]);
  const [sortBy, setSortBy] = useState<"rule" | "total">("total");
  const [windowSize, setWindowSize] = useState(5);
  const [norm, setNorm] = useState<"local" | "global">("local");

  const rows = useMemo(() => {
    const entries = [...stats.byRule.entries()].map(([ruleId, rs]) => ({ ruleId, total: rs.total, series: rs.perIndex }));
    entries.sort((a, b) => sortBy === "rule" ? a.ruleId.localeCompare(b.ruleId) : b.total - a.total);
    return entries;
  }, [stats, sortBy]);

  const choose = (ruleId: string | null) => {
    onSelectRuleForHeat(ruleId);
    const series = ruleId ? stats.byRule.get(ruleId)?.perIndex ?? [] : stats.all.perIndex;
    onSetHeatStrip(normalizeSeriesToUnit(series));
  };

  return (
    <div className="mpl-rulestats">
      <div className="mpl-rs-controls">
        <label>Sort
          <select value={sortBy} onChange={e => setSortBy(e.target.value as any)}>
            <option value="total">by total</option>
            <option value="rule">by rule id</option>
          </select>
        </label>
        <label>Window
          <select value={windowSize} onChange={e => { const v = parseInt(e.target.value); setWindowSize(v); onSetHeatWindow(v); }}>
            <option value={3}>3</option><option value={5}>5</option><option value={10}>10</option><option value={20}>20</option>
          </select>
          ticks
        </label>
        <label>Normalize
          <select value={norm} onChange={e => { const v = e.target.value as any; setNorm(v); onSetHeatNormalize(v); }}>
            <option value="local">local</option>
            <option value="global">global</option>
          </select>
        </label>
        <button className="mpl-btn" onClick={() => choose(null)}>Heat: ALL</button>
      </div>

      <div className="mpl-rs-table-wrap">
        <table className="mpl-table mpl-rs-table">
          <thead><tr><th>Rule</th><th>Total</th><th>Activity</th><th></th></tr></thead>
          <tbody>
            {rows.map(({ ruleId, total, series }) => (
              <tr key={ruleId}>
                <td><code>{ruleId}</code></td>
                <td>{total}</td>
                <td><Sparkline data={series} /></td>
                <td><button className="mpl-btn" onClick={() => choose(ruleId)}>Heat: {ruleId}</button></td>
              </tr>
            ))}
          </tbody>
        </table>
        {rows.length === 0 && <div className="mpl-empty">No rule data</div>}
      </div>
    </div>
  );
};

const Sparkline: React.FC<{ data: number[] }> = ({ data }) => {
  const W = 120, H = 28, P = 2;
  const n = data.length;
  const xs = normalizeSeriesToUnit(data);
  const pts = xs.map((v, i) => {
    const x = P + (n <= 1 ? 0 : (i * (W - 2 * P)) / (n - 1));
    const y = H - P - v * (H - 2 * P);
    return `${x},${y}`;
  }).join(" ");
  return (
    <svg width={W} height={H} className="mpl-sparkline"><polyline points={pts} className="mpl-sparkline-line" /></svg>
  );
};
```

---

## 5) `playground/components/StateViewer.tsx` (heat controls → GraphStateView)

```tsx
// playground/components/StateViewer.tsx
// Stage 3O — Graph heat controls (rule/all, window, normalize)

import React, { useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { GraphStateView } from "./GraphStateView";
import { MonadicNote } from "../../engine/debugger/annotations";
import { RuleStats, buildRuleStats, computeNodeHeat } from "../../engine/debugger/ruleStats";
import { HeatLegend } from "./HeatLegend";

interface StateViewerProps {
  history: ExecutionSnapshot[];            // needed for heat
  index: number;                           // current timeline index
  snapshot: ExecutionSnapshot;             // current (B)
  ghostSnapshot?: ExecutionSnapshot;       // optional (A)
  monadNotes?: MonadicNote[];              // notes for current index
  selectedMonadId?: string | null;
  onSelectMonad?: (id: string) => void;
  heatRuleId?: string | null;              // controlled from panel
  heatWindow?: number;                     // ticks
  heatNormalize?: "local" | "global";
}

type ViewMode = "table" | "graph";

export const StateViewer: React.FC<StateViewerProps> = ({ history, index, snapshot, ghostSnapshot, monadNotes = [], selectedMonadId = null, onSelectMonad, heatRuleId = null, heatWindow = 5, heatNormalize = "local" }) => {
  const [mode, setMode] = useState<ViewMode>("graph");
  const [neighborOnly, setNeighborOnly] = useState(false);
  const [showHighlights, setShowHighlights] = useState(true);
  const [windowTicks, setWindowTicks] = useState(3);
  const [diffMode, setDiffMode] = useState(true);

  const stats = useMemo<RuleStats>(() => buildRuleStats(history), [history]);
  const nodeHeat = useMemo(() => computeNodeHeat(history, stats, index, { ruleId: heatRuleId ?? undefined, windowSize: heatWindow, normalize: heatNormalize }), [history, stats, index, heatRuleId, heatWindow, heatNormalize]);

  const rows = useMemo(() => snapshot.monads.map(m => ({ id: String(m.id), neighbors: m.neighbors?.length ?? 0, active: !!(m.active || (snapshot.focusMonadId != null && String(snapshot.focusMonadId) === String(m.id))) })), [snapshot]);

  return (
    <div className="mpl-state-viewer">
      <div className="mpl-toolbar">
        <div className="mpl-seg">
          <button className={`mpl-btn ${mode === "table" ? "active" : ""}`} onClick={() => setMode("table")}>Table</button>
          <button className={`mpl-btn ${mode === "graph" ? "active" : ""}`} onClick={() => setMode("graph")}>Graph</button>
        </div>
        {mode === "graph" && (
          <div className="mpl-toolbar-right">
            <label className="mpl-check"><input type="checkbox" checked={neighborOnly} onChange={e => setNeighborOnly(e.target.checked)} /> Neighbor focus</label>
            <label className="mpl-check"><input type="checkbox" checked={showHighlights} onChange={e => setShowHighlights(e.target.checked)} /> Rule highlights</label>
            <label className="mpl-check">Window
              <select value={windowTicks} onChange={e => setWindowTicks(parseInt(e.target.value))}><option value={1}>1</option><option value={3}>3</option><option value={5}>5</option><option value={10}>10</option></select> ticks
            </label>
            <label className="mpl-check"><input type="checkbox" checked={diffMode} onChange={e => setDiffMode(e.target.checked)} /> Diff mode</label>
          </div>
        )}
      </div>

      {mode === "table" ? (
        <div className="mpl-table-wrap">
          <table className="mpl-table">
            <thead><tr><th>ID</th><th>Neighbors</th><th>Active</th></tr></thead>
            <tbody>
              {rows.map(r => (
                <tr key={r.id} onClick={() => onSelectMonad?.(r.id)} className={r.active ? "mpl-row-active" : undefined}>
                  <td>{r.id}</td><td>{r.neighbors}</td><td>{r.active ? "●" : ""}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="mpl-graph-wrap">
          <GraphStateView
            snapshot={snapshot}
            ghostSnapshot={ghostSnapshot}
            onSelectMonad={onSelectMonad}
            neighborFocusMode={neighborOnly}
            highlightRules={showHighlights}
            highlightWindowTicks={windowTicks}
            diffMode={diffMode}
            monadNotes={monadNotes}
            selectedMonadId={selectedMonadId}
            nodeHeat={nodeHeat}
          />
          <HeatLegend />
        </div>
      )}
    </div>
  );
};
```

---

## 6) `playground/components/TimeScrubber.tsx` (heat strip under rail)

```tsx
// playground/components/TimeScrubber.tsx
// Stage 3O — accept `heatValues` (0..1 per index) and draw a strip under the rail

import React, { useEffect, useMemo, useRef, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { SessionAnnotation } from "../../engine/debugger/annotations";

interface TimeScrubberProps {
  timeline: ExecutionSnapshot[];
  index: number; onChangeIndex: (i: number) => void;
  ghostIndex: number | null; onChangeGhostIndex: (i: number | null) => void;
  bookmarks?: Bookmark[];
  annotations?: SessionAnnotation[];
  ruleMarks?: number[];
  heatValues?: number[]; // NEW: normalized 0..1 array, length==timeline.length (optional)
}

export const TimeScrubber: React.FC<TimeScrubberProps> = ({ timeline, index, onChangeIndex, ghostIndex, onChangeGhostIndex, bookmarks = [], annotations = [], ruleMarks = [], heatValues }) => {
  const N = timeline.length; const min = 0; const max = Math.max(0, N - 1);
  const [playing, setPlaying] = useState(false);
  const [speed, setSpeed] = useState(1); const [loop, setLoop] = useState(true);
  const timerRef = useRef<number | null>(null); const railRef = useRef<HTMLDivElement>(null);

  useEffect(() => { if (index > max) onChangeIndex(max); }, [N]);
  useEffect(() => { if (!playing) return; const ms = 600 / (speed || 1); const id = window.setInterval(() => onChangeIndex(index < max ? index + 1 : (loop ? min : max)), ms); timerRef.current = id as unknown as number; return () => { if (timerRef.current) window.clearInterval(timerRef.current); timerRef.current = null; }; }, [playing, speed, index, max, loop, onChangeIndex]);

  const tick = timeline[index]?.tick ?? index; const aTick = ghostIndex != null ? (timeline[ghostIndex]?.tick ?? ghostIndex) : null;
  const toPct = (i: number) => (max === min ? 0 : (i - min) / (max - min));
  const onRailClick = (e: React.MouseEvent) => { if (!railRef.current) return; const rect = railRef.current.getBoundingClientRect(); const frac = (e.clientX - rect.left) / rect.width; const i = Math.round(min + frac * (max - min)); onChangeIndex(i); };

  return (
    <div className="mpl-timescrubber">
      <div className="mpl-ts-row">
        <div className="mpl-ts-controls">
          <button className="mpl-btn" onClick={() => onChangeIndex(min)} title="Start">⏮</button>
          <button className="mpl-btn" onClick={() => onChangeIndex(Math.max(min, index - 1))} title="Step back">◀</button>
          <button className="mpl-btn" onClick={() => setPlaying(p => !p)} title={playing ? "Pause" : "Play"}>{playing ? "⏸" : "▶"}</button>
          <button className="mpl-btn" onClick={() => onChangeIndex(Math.min(max, index + 1))} title="Step forward">▶</button>
          <button className="mpl-btn" onClick={() => onChangeIndex(max)} title="End">⏭</button>
        </div>
        <div className="mpl-ts-speed">
          <label>Speed
            <select value={speed} onChange={e => setSpeed(parseFloat(e.target.value))}>
              <option value={0.25}>0.25×</option><option value={0.5}>0.5×</option><option value={1}>1×</option><option value={2}>2×</option><option value={4}>4×</option>
            </select>
          </label>
          <label className="mpl-check"><input type="checkbox" checked={loop} onChange={e => setLoop(e.target.checked)} /> Loop</label>
        </div>
      </div>

      {heatValues && heatValues.length === N && (
        <div className="mpl-ts-heat">
          {heatValues.map((v, i) => (
            <div key={`h-${i}`} className="mpl-ts-heat-cell" style={{ left: `${toPct(i) * 100}%`, width: `${(toPct(i + 1) - toPct(i)) * 100}%`, opacity: Math.max(0.05, Math.min(1, v)) }} />
          ))}
        </div>
      )}

      <div className="mpl-ts-rail" ref={railRef} onClick={onRailClick}>
        {annotations.filter(a => a.endIndex != null && a.endIndex! > a.index).map(a => (
          <div key={`band-${a.id}`} className="mpl-ts-band" style={{ left: `${toPct(a.index) * 100}%`, width: `${(toPct(a.endIndex!) - toPct(a.index)) * 100}%`, background: a.color || "#999" }} title={`${a.label} (${a.index}→${a.endIndex})`} />
        ))}
        {bookmarks.map((b, k) => (
          <div key={`bm-${k}`} className="mpl-ts-mark bm" style={{ left: `${toPct(b.index) * 100}%` }} title={b.label || `idx ${b.index}`} onClick={e => { e.stopPropagation(); onChangeIndex(b.index); }} />
        ))}
        {annotations.filter(a => a.endIndex == null).map(a => (
          <div key={`ann-${a.id}`} className="mpl-ts-mark ann" style={{ left: `${toPct(a.index) * 100}%`, background: a.color || "#111" }} title={a.label} onClick={e => { e.stopPropagation(); onChangeIndex(a.index); }} />
        ))}
        {ruleMarks.map((i, k) => (
          <div key={`rl-${k}-${i}`} className="mpl-ts-mark rl" style={{ left: `${toPct(i) * 100}%` }} title={`rule @ ${i}`} onClick={e => { e.stopPropagation(); onChangeIndex(i); }} />
        ))}
        {ghostIndex != null && (
          <div className="mpl-ts-ghost-pin" style={{ left: `${toPct(ghostIndex) * 100}%` }} title={`A @ ${ghostIndex}`} />
        )}
        <div className="mpl-ts-handle" style={{ left: `${toPct(index) * 100}%` }} />
      </div>

      <div className="mpl-ts-meta">
        <span>Index: {index}/{max}</span><span>Tick: {tick}</span><span>A: {ghostIndex != null ? `${ghostIndex}/${max}${aTick != null ? ` (t${aTick})` : ""}` : "—"}</span>
      </div>
    </div>
  );
};
```

---

## 7) `playground/components/DebuggerPanel.tsx` (wire stats + heat)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3O — hook up RuleStatsPanel and pass heat settings into viewer & scrubber

import React, { useEffect, useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";
import { TimeScrubber } from "./TimeScrubber";
import { ImportExportPanel } from "./ImportExportPanel";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { BookmarksPanel } from "./BookmarksPanel";
import { SessionBundle } from "../../engine/debugger/sessionIO";
import { AnnotationsPanel } from "./AnnotationsPanel";
import { MonadicNote, SessionAnnotation } from "../../engine/debugger/annotations";
import { NodeNotesPanel } from "./NodeNotesPanel";
import { RuleLogPanel } from "./RuleLogPanel";
import { RuleStatsPanel } from "./RuleStatsPanel";

interface DebuggerPanelProps {
  snapshot?: ExecutionSnapshot;
  history?: ExecutionSnapshot[];
  onFocusMonad?: (id: string) => void;
}

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, history, onFocusMonad }) => {
  const [timeline, setTimeline] = useState<ExecutionSnapshot[]>(() => history ?? (snapshot ? [snapshot] : []));
  useEffect(() => { if (history && history.length) setTimeline(history); }, [history?.length]);
  useEffect(() => { if (!history && snapshot) setTimeline([snapshot]); }, [snapshot?.tick]);

  const [idx, setIdx] = useState(() => Math.max(0, timeline.length - 1));
  useEffect(() => { setIdx(Math.max(0, timeline.length - 1)); }, [timeline.length]);

  const [ghostIdx, setGhostIdx] = useState<number | null>(null);
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);
  const [annotations, setAnnotations] = useState<SessionAnnotation[]>([]);
  const [monadNotes, setMonadNotes] = useState<MonadicNote[]>([]);
  const [selectedMonadId, setSelectedMonadId] = useState<string | null>(null);
  const [ruleMarks, setRuleMarks] = useState<number[]>([]);

  // Heat controls
  const [heatRuleId, setHeatRuleId] = useState<string | null>(null); // null => ALL
  const [heatWindow, setHeatWindow] = useState<number>(5);
  const [heatNormalize, setHeatNormalize] = useState<"local" | "global">("local");
  const [heatStrip, setHeatStrip] = useState<number[] | undefined>(undefined);

  const current = useMemo<ExecutionSnapshot | undefined>(() => timeline[Math.max(0, Math.min(idx, timeline.length - 1))], [timeline, idx]);
  const ghost = useMemo<ExecutionSnapshot | undefined>(() => ghostIdx == null ? undefined : timeline[Math.max(0, Math.min(ghostIdx, timeline.length - 1))], [timeline, ghostIdx]);

  const onImport = (bundle: SessionBundle) => {
    setTimeline(bundle.history || []);
    setBookmarks(bundle.bookmarks || []);
    setAnnotations(bundle.annotations || []);
    setMonadNotes(bundle.monadNotes || []);
    setIdx(Math.max(0, (bundle.history?.length || 1) - 1));
    setGhostIdx(null);
  };

  return (
    <div className="mpl-debugger-panel">
      {/* Session I/O */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session I/O</header>
        <ImportExportPanel history={timeline} bookmarks={bookmarks} annotations={annotations} monadNotes={monadNotes} onImport={onImport} />
      </section>

      {/* Timeline */}
      {timeline.length > 0 && (
        <section className="mpl-section">
          <header className="mpl-section-h">Timeline</header>
          <TimeScrubber timeline={timeline} index={idx} onChangeIndex={setIdx} ghostIndex={ghostIdx} onChangeGhostIndex={setGhostIdx} bookmarks={bookmarks} annotations={annotations} ruleMarks={ruleMarks} heatValues={heatStrip} />
        </section>
      )}

      {/* Rule Stats */}
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Stats</header>
        <RuleStatsPanel history={timeline} onSelectRuleForHeat={setHeatRuleId} onSetHeatWindow={setHeatWindow} onSetHeatNormalize={setHeatNormalize} onSetHeatStrip={setHeatStrip} />
      </section>

      {/* Rule Log */}
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Log</header>
        <RuleLogPanel history={timeline} onGoToIndex={setIdx} onPinGhost={setGhostIdx} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} onMarksChange={setRuleMarks} />
      </section>

      {/* Bookmarks */}
      <section className="mpl-section">
        <header className="mpl-section-h">Bookmarks</header>
        <BookmarksPanel currentIndex={idx} currentTick={current?.tick ?? idx} bookmarks={bookmarks} onChange={setBookmarks} onGoToIndex={setIdx} />
      </section>

      {/* Annotations */}
      <section className="mpl-section">
        <header className="mpl-section-h">Annotations</header>
        <AnnotationsPanel currentIndex={idx} currentTick={current?.tick ?? idx} maxIndex={Math.max(0, timeline.length - 1)} annotations={annotations} onChange={setAnnotations} onGoToIndex={setIdx} />
      </section>

      {/* Node notes */}
      <section className="mpl-section">
        <header className="mpl-section-h">Node Notes</header>
        <NodeNotesPanel currentIndex={idx} currentTick={current?.tick ?? idx} selectedMonadId={selectedMonadId ?? undefined} notes={monadNotes} onChange={setMonadNotes} />
      </section>

      {/* State */}
      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        {current ? (
          <StateViewer
            history={timeline}
            index={idx}
            snapshot={current}
            ghostSnapshot={ghost}
            monadNotes={monadNotes.filter(n => n.index === idx)}
            selectedMonadId={selectedMonadId}
            onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }}
            heatRuleId={heatRuleId}
            heatWindow={heatWindow}
            heatNormalize={heatNormalize}
          />
        ) : (
          <div className="mpl-empty">No snapshot available</div>
        )}
      </section>
    </div>
  );
};
```

---

## 8) `playground/styles/debugger.css` (additions)

```css
/* Stage 3O — Heat legend, sparkline, heat strip */
.mpl-heat-legend { margin-top: 8px; }
.mpl-heat-bar { height: 8px; border-radius: 8px; background: linear-gradient(90deg, hsl(220,85%,50%) 0%, hsl(0,85%,40%) 100%); }
.mpl-heat-labels { display: flex; justify-content: space-between; font-size: 12px; color: #555; margin-top: 2px; }

.mpl-sparkline { display: block; }
.mpl-sparkline-line { fill: none; stroke: #111; stroke-width: 1.4; }

.mpl-rs-controls { display: inline-flex; gap: 12px; align-items: center; margin-bottom: 8px; }
.mpl-rs-table-wrap { max-height: 260px; overflow: auto; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; }

/* Time scrubber heat strip */
.mpl-ts-heat { position: relative; height: 6px; background: #f3f4f6; border-radius: 6px; margin-bottom: 6px; overflow: hidden; }
.mpl-ts-heat-cell { position: absolute; top: 0; bottom: 0; background: hsl(0, 85%, 45%); }
```

---

## 9) Example — `playground/pages/DebugExample3O.tsx`

```tsx
// playground/pages/DebugExample3O.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3O() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B" }, { ruleId: "R1", at: 1, monadId: "A" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" }, { ruleId: "R1", at: 2, monadId: "C" } ] },
    { tick: 3, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R2", at: 3, monadId: "A" } ] },
    { tick: 4, monads: [ { id: "A", neighbors: ["C", "D"] }, { id: "C", neighbors: ["A", "D"] }, { id: "D", neighbors: ["A", "C"] } ], rulesFired: [ { ruleId: "R1", at: 4, monadId: "D" }, { ruleId: "R2", at: 4, monadId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3O — Rule Stats & Heatmaps</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 10) Notes

* **Heat color** maps 0→blue to 1→red; intensity uses either a local window max (default) or global max over the entire session.
* **Window** controls how many indices back to aggregate (default 5). For real time, keep this small; for retrospective analysis, try 10–20.
* **Rule selection**: “Heat: ALL” uses aggregate activity; clicking a rule row focuses the heatmap + updates the timeline heat strip with that rule’s per‑tick activity (normalized).
* **Performance**: `buildRuleStats` is O(N + total\_fires). For long sessions, memoize at the caller or compute on append.

---

## 11) Changelog — Stage 3O

* New: `ruleStats.ts` (aggregations + heat helpers), `HeatLegend.tsx`, `RuleStatsPanel.tsx`
* Updated: `GraphStateView` (node heat overlay), `StateViewer` (heat controls + legend), `TimeScrubber` (heat strip), `DebuggerPanel` (wiring)
* CSS: heat legend, sparkline, timeline heat strip

```
```
