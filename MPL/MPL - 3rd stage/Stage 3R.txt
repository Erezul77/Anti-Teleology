# MPL Playground — Stage 3R Patch (Session Search + Global Timeline Queries)

This patch adds a **session‑wide search** that spans rules, annotations, bookmarks, monad notes, watches, and breakpoints — and turns any query into **global timeline marks** you can jump through.

**Highlights**

* Single **Search Bar** with a compact DSL; instant results with faceting
* Searches across **Rule events**, **Annotations**, **Bookmarks**, **Node Notes**, **Watches** (labels/expr), **Breakpoints** (labels/query)
* Toggle **Group by index** vs **Flat list**
* **Next/Prev** match navigation + **timeline marks**
* Saved searches with labels & colors; CSV export
* No new deps

---

## 1) `engine/debugger/sessionSearch.ts` (new)

```ts
// engine/debugger/sessionSearch.ts
// Stage 3R — Session-wide search & index set builder

import { ExecutionSnapshot } from "./graphTypes";
import { Breakpoint } from "./breakpoints";
import { MonadicNote, SessionAnnotation } from "./annotations";
import { Watch } from "./watch";
import { buildRuleLog, parseQuery, filterRuleLog, applyNegatives } from "./ruleLog";

export type HitKind = "rule" | "annotation" | "bookmark" | "note" | "watch" | "breakpoint";

export interface Bookmark { index: number; label?: string }

export interface SearchQuery {
  raw: string;            // original string
  text?: string;          // free text (case-insensitive)
  kinds?: HitKind[];      // restrict to kinds
  monad?: string;         // monad id (string compare)
  tickMin?: number;       // inclusive
  tickMax?: number;       // inclusive
  indexMin?: number;      // inclusive
  indexMax?: number;      // inclusive
  // rule-specific parsed filters via ruleLog.parseQuery
  ruleFilter?: ReturnType<typeof parseQuery>;
}

export interface SearchHit {
  kind: HitKind;
  index: number;          // timeline index
  title: string;          // primary label
  detail?: string;        // secondary (small)
}

// Lightweight parser: supports tokens
// kind:<rule|annotation|bookmark|note|watch|breakpoint>
// monad:<id>
// tick:a..b, index:a..b
// text:"quoted words" or bare words
// plus pass-through for rule filters (rule:, source:, target:, edge:...) which feed ruleFilter
export function parseSessionQuery(q: string): SearchQuery {
  const out: SearchQuery = { raw: q };
  const toks = q.match(/\S+:/) ? splitKV(q) : q.split(/\s+/).filter(Boolean);
  const ruleParts: string[] = [];
  for (const rawTok of toks) {
    const tok = rawTok.trim();
    if (!tok) continue;
    const neg = tok.startsWith("-");
    const t = neg ? tok.slice(1) : tok; // NOTE: session search ignores global negatives; rule negatives still work inside ruleFilter
    const [k, vRaw] = t.includes(":") ? [t.slice(0, t.indexOf(":")), t.slice(t.indexOf(":") + 1)] : ["text", t];
    const v = vRaw.replace(/^"|"$/g, "");
    switch (k.toLowerCase()) {
      case "kind": {
        const ks = v.split(",").map(x => x.trim().toLowerCase()) as HitKind[];
        out.kinds = ks.filter(Boolean);
        break;
      }
      case "monad": out.monad = v; break;
      case "tick": { const m = v.match(/^(\d+)(?:\.\.(\d+))?$/); if (m) { out.tickMin = m[1] ? Number(m[1]) : undefined; out.tickMax = m[2] ? Number(m[2]) : undefined; } break; }
      case "index": { const m = v.match(/^(\d+)(?:\.\.(\d+))?$/); if (m) { out.indexMin = m[1] ? Number(m[1]) : undefined; out.indexMax = m[2] ? Number(m[2]) : undefined; } break; }
      case "rule": case "source": case "target": case "edge": case "text": default:
        // Pass-through for rule filters; collect others into text
        if (["rule","source","target","edge","text"].includes(k.toLowerCase())) ruleParts.push(`${k}:${v}`);
        else out.text = [out.text, `${k}:${v}`].filter(Boolean).join(" ");
    }
  }
  out.ruleFilter = parseQuery(ruleParts.join(" "));
  return out;
}

function splitKV(q: string): string[] {
  const out: string[] = []; let cur = ""; let inQ = false;
  for (const ch of q) { if (ch === '"') { inQ = !inQ; cur += ch; continue; } if (!inQ && ch === ' ') { if (cur) out.push(cur), cur = ""; } else cur += ch; }
  if (cur) out.push(cur); return out;
}

export interface SearchSpace {
  history: ExecutionSnapshot[];
  bookmarks: Bookmark[];
  annotations: SessionAnnotation[];
  notes: MonadicNote[];
  watches: Watch[];
  breakpoints: Breakpoint[];
}

export function runSessionSearch(space: SearchSpace, q: SearchQuery): { hits: SearchHit[]; indices: number[] } {
  const { history, bookmarks, annotations, notes, watches, breakpoints } = space;
  const hits: SearchHit[] = [];
  const want = (k: HitKind) => !q.kinds || q.kinds.includes(k);
  const text = (q.text || "").toLowerCase();
  const inTickRange = (tick: number, index: number) => {
    if (q.tickMin != null && tick < q.tickMin) return false;
    if (q.tickMax != null && tick > q.tickMax) return false;
    if (q.indexMin != null && index < q.indexMin) return false;
    if (q.indexMax != null && index > q.indexMax) return false;
    return true;
  };

  // 1) Rules via rule log
  if (want("rule")) {
    const log = buildRuleLog(history);
    const base = filterRuleLog(log, q.ruleFilter?.filter || {} as any);
    const items = q.ruleFilter?.negatives ? applyNegatives(base, q.ruleFilter.negatives) : base;
    for (const it of items) {
      const snap = history[it.index];
      if (!inTickRange(snap?.tick ?? it.index, it.index)) continue;
      if (q.monad && String(it.monadId) !== String(q.monad)) continue;
      if (text) {
        const hay = `${it.ruleId} ${JSON.stringify(it.meta || {})}`.toLowerCase();
        if (!hay.includes(text)) continue;
      }
      hits.push({ kind: "rule", index: it.index, title: `Rule ${it.ruleId}`, detail: `monad ${it.monadId}${it.sourceId!=null?` ${it.sourceId}→${it.targetId}`:''} @ tick ${it.at}` });
    }
  }

  // 2) Annotations
  if (want("annotation")) {
    for (const a of annotations) {
      const i = a.index; const tick = history[i]?.tick ?? i; if (!inTickRange(tick, i)) continue;
      const hay = `${a.label || ''} ${a.text || ''}`.toLowerCase();
      if (text && !hay.includes(text)) continue;
      hits.push({ kind: "annotation", index: i, title: a.label || "Annotation", detail: a.text });
      if (a.endIndex != null) { // include the end point as well for navigation
        const j = a.endIndex; const t2 = history[j]?.tick ?? j; if (inTickRange(t2, j)) {
          const h2 = `${a.label || ''} ${a.text || ''}`.toLowerCase(); if (!text || h2.includes(text)) hits.push({ kind: "annotation", index: j, title: a.label || "Annotation (end)", detail: a.text });
        }
      }
    }
  }

  // 3) Bookmarks
  if (want("bookmark")) {
    for (const b of bookmarks) {
      const i = b.index; const tick = history[i]?.tick ?? i; if (!inTickRange(tick, i)) continue;
      const hay = `${b.label || ''}`.toLowerCase(); if (text && !hay.includes(text)) continue;
      hits.push({ kind: "bookmark", index: i, title: b.label || `Bookmark @ ${i}` });
    }
  }

  // 4) Monadic notes (per-index)
  if (want("note")) {
    for (const n of notes) {
      const i = n.index; const tick = history[i]?.tick ?? i; if (!inTickRange(tick, i)) continue;
      if (q.monad && String(n.monadId) !== String(q.monad)) continue;
      const hay = `${n.title || ''} ${n.text || ''}`.toLowerCase(); if (text && !hay.includes(text)) continue;
      hits.push({ kind: "note", index: i, title: n.title || `Note for ${n.monadId}`, detail: n.text });
    }
  }

  // 5) Watches (search labels / expr only; results jump to current index)
  if (want("watch)) {
    for (const w of watches) {
      const hay = `${w.label} ${w.expr}`.toLowerCase(); if (text && !hay.includes(text)) continue;
      // Use all indices (so user can jump around). We add a single hit at the current end for now.
      const j = Math.max(0, history.length - 1);
      hits.push({ kind: "watch", index: j, title: w.label || "Watch", detail: w.expr });
    }
  }

  // 6) Breakpoints (labels/query only)
  if (want("breakpoint")) {
    for (const bp of breakpoints) {
      const hay = `${bp.label} ${bp.query}`.toLowerCase(); if (text && !hay.includes(text)) continue;
      // Put a hit at first matching index if possible; otherwise index 0
      let j = 0;
      try {
        const { filter, negatives } = parseQuery(bp.query || "");
        const base = filterRuleLog(buildRuleLog(history), filter);
        const items = negatives ? applyNegatives(base, negatives) : base;
        if (items[0]) j = items[0].index;
      } catch {}
      hits.push({ kind: "breakpoint", index: j, title: bp.label || "Breakpoint", detail: bp.query });
    }
  }

  // Sort by index, then kind
  hits.sort((a, b) => a.index - b.index || a.kind.localeCompare(b.kind));

  // Build unique index set
  const set = new Set<number>(); for (const h of hits) set.add(h.index);
  const indices = [...set].sort((a, b) => a - b);
  return { hits, indices };
}
```

> ⚠️ Typing note: If your project already defines `Bookmark` elsewhere, remove the local interface above and import it instead.

---

## 2) `playground/components/SessionSearchPanel.tsx` (new)

```tsx
// playground/components/SessionSearchPanel.tsx
// Stage 3R — Unified session search with saved queries & jump actions

import React, { useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { SessionAnnotation, MonadicNote } from "../../engine/debugger/annotations";
import { Breakpoint } from "../../engine/debugger/breakpoints";
import { Watch } from "../../engine/debugger/watch";
import { Bookmark } from "../../engine/debugger/bookmarks"; // if you have a module; otherwise use the local shape {index,label?}
import { parseSessionQuery, runSessionSearch, HitKind } from "../../engine/debugger/sessionSearch";

export interface SavedSearch { id: string; label: string; color?: string; query: string; }

interface SessionSearchPanelProps {
  history: ExecutionSnapshot[];
  bookmarks: Bookmark[];
  annotations: SessionAnnotation[];
  notes: MonadicNote[];
  watches: Watch[];
  breakpoints: Breakpoint[];
  onGoToIndex: (i: number) => void;
  onMarksChange?: (indices: number[]) => void; // emit index set to mark on the scrubber
}

export const SessionSearchPanel: React.FC<SessionSearchPanelProps> = ({ history, bookmarks, annotations, notes, watches, breakpoints, onGoToIndex, onMarksChange }) => {
  const [query, setQuery] = useState("text:\"\" kind:rule,annotation,bookmark,note");
  const [saved, setSaved] = useState<SavedSearch[]>([]);
  const [groupByIndex, setGroupByIndex] = useState(true);

  const space = useMemo(() => ({ history, bookmarks, annotations, notes, watches, breakpoints }), [history, bookmarks, annotations, notes, watches, breakpoints]);
  const parsed = useMemo(() => parseSessionQuery(query), [query]);
  const { hits, indices } = useMemo(() => runSessionSearch(space, parsed), [space, parsed]);

  React.useEffect(() => { onMarksChange?.(indices); }, [indices.length]);

  const addSaved = () => setSaved([...saved, { id: `sv_${Date.now()}`, label: `Search #${saved.length + 1}`, color: randomColor(), query }]);
  const runSaved = (s: SavedSearch) => setQuery(s.query);
  const delSaved = (id: string) => setSaved(saved.filter(x => x.id !== id));

  const grouped = useMemo(() => {
    if (!groupByIndex) return null;
    const map = new Map<number, typeof hits>();
    for (const h of hits) { const arr = map.get(h.index) || []; arr.push(h); map.set(h.index, arr); }
    return [...map.entries()].sort((a,b) => a[0]-b[0]);
  }, [hits, groupByIndex]);

  const exportCSV = () => {
    const header = ["index","kind","title","detail"]; const lines = hits.map(h => [h.index, h.kind, h.title, h.detail||""].map(csv).join(","));
    const blob = new Blob([[header.join(","), ...lines].join("\n")], { type: "text/csv" });
    const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = "session_search.csv"; document.body.appendChild(a); a.click(); setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
  };

  return (
    <div className="mpl-session-search">
      <form className="mpl-ss-bar" onSubmit={e => e.preventDefault()}>
        <input value={query} onChange={e => setQuery(e.target.value)} placeholder='e.g., text:"activation" monad:A tick:10..40 kind:rule,note index:0..200 rule:R1' />
        <button className="mpl-btn" type="button" onClick={() => setQuery("")}>Clear</button>
        <label className="mpl-check"><input type="checkbox" checked={groupByIndex} onChange={e => setGroupByIndex(e.target.checked)} /> Group by index</label>
        <button className="mpl-btn" type="button" onClick={addSaved}>Save</button>
        <button className="mpl-btn" type="button" onClick={exportCSV}>Export CSV</button>
      </form>

      {saved.length > 0 && (
        <div className="mpl-ss-saved">
          {saved.map(s => (
            <span key={s.id} className="mpl-chip" style={{ background: s.color || undefined }} title={s.query} onClick={() => runSaved(s)}>
              {s.label} <b>↻</b>
              <i className="mpl-x" onClick={(e) => { e.stopPropagation(); delSaved(s.id); }}>×</i>
            </span>
          ))}
        </div>
      )}

      {/* Results */}
      <div className="mpl-ss-results">
        {groupByIndex ? (
          grouped!.map(([i, arr]) => (
            <div key={`g-${i}`} className="mpl-ss-group">
              <div className="mpl-ss-group-h">
                <button className="mpl-btn" onClick={() => onGoToIndex(i)}>Jump</button>
                <span className="mpl-ss-idx">Index {i} • tick {history[i]?.tick ?? i}</span>
                <span className="mpl-ss-count">{arr.length} hit{arr.length>1?'s':''}</span>
              </div>
              <ul>
                {arr.map((h, k) => (
                  <li key={k} className={`k-${h.kind}`}>
                    <b>{labelFor(h.kind)}</b> <span>{h.title}</span>
                    {h.detail ? <small className="mpl-dim"> — {h.detail}</small> : null}
                  </li>
                ))}
              </ul>
            </div>
          ))
        ) : (
          <table className="mpl-table mpl-ss-table">
            <thead><tr><th>Index</th><th>Kind</th><th>Title</th><th>Detail</th><th></th></tr></thead>
            <tbody>
              {hits.map((h, k) => (
                <tr key={k}>
                  <td>{h.index}</td>
                  <td>{labelFor(h.kind)}</td>
                  <td>{h.title}</td>
                  <td className="mpl-mono">{h.detail}</td>
                  <td><button className="mpl-btn" onClick={() => onGoToIndex(h.index)}>Jump</button></td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
        {hits.length === 0 && <div className="mpl-empty">No matches</div>}
      </div>
    </div>
  );
};

function labelFor(k: HitKind) { return k.charAt(0).toUpperCase() + k.slice(1); }
function csv(v: any) { const s = v == null ? "" : String(v); return `"${s.replace(/"/g,'""')}"`; }
function randomColor() { const h = Math.floor(Math.random()*360); return `hsl(${h}, 90%, 90%)`; }
```

---

## 3) `playground/components/DebuggerPanel.tsx` (wire Session Search + search marks)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3R — Wire SessionSearchPanel and feed search marks to the scrubber

import React, { useEffect, useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";
import { TimeScrubber } from "./TimeScrubber";
import { ImportExportPanel } from "./ImportExportPanel";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { BookmarksPanel } from "./BookmarksPanel";
import { SessionBundle } from "../../engine/debugger/sessionIO";
import { AnnotationsPanel } from "./AnnotationsPanel";
import { MonadicNote, SessionAnnotation } from "../../engine/debugger/annotations";
import { NodeNotesPanel } from "./NodeNotesPanel";
import { RuleLogPanel } from "./RuleLogPanel";
import { RuleStatsPanel } from "./RuleStatsPanel";
import { Breakpoint } from "../../engine/debugger/breakpoints";
import { BreakpointsPanel } from "./BreakpointsPanel";
import { WatchesPanel } from "./WatchesPanel";
import { DiffPanel } from "./DiffPanel";
import { SessionSearchPanel } from "./SessionSearchPanel";
import { Watch } from "../../engine/debugger/watch";

interface DebuggerPanelProps {
  snapshot?: ExecutionSnapshot;
  history?: ExecutionSnapshot[];
  onFocusMonad?: (id: string) => void;
}

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, history, onFocusMonad }) => {
  const [timeline, setTimeline] = useState<ExecutionSnapshot[]>(() => history ?? (snapshot ? [snapshot] : []));
  useEffect(() => { if (history && history.length) setTimeline(history); }, [history?.length]);
  useEffect(() => { if (!history && snapshot) setTimeline([snapshot]); }, [snapshot?.tick]);

  const [idx, setIdx] = useState(() => Math.max(0, timeline.length - 1));
  useEffect(() => { setIdx(Math.max(0, timeline.length - 1)); }, [timeline.length]);

  const [ghostIdx, setGhostIdx] = useState<number | null>(null);
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);
  const [annotations, setAnnotations] = useState<SessionAnnotation[]>([]);
  const [monadNotes, setMonadNotes] = useState<MonadicNote[]>([]);
  const [selectedMonadId, setSelectedMonadId] = useState<string | null>(null);
  const [ruleMarks, setRuleMarks] = useState<number[]>([]);
  const [bpMarks, setBpMarks] = useState<number[]>([]);
  const [heatStrip, setHeatStrip] = useState<number[] | undefined>(undefined);
  const [watches, setWatches] = useState<Watch[]>([]);
  const [searchMarks, setSearchMarks] = useState<number[]>([]);
  const [breakpoints, setBreakpoints] = useState<Breakpoint[]>([]);

  const current = useMemo<ExecutionSnapshot | undefined>(() => timeline[Math.max(0, Math.min(idx, timeline.length - 1))], [timeline, idx]);
  const ghost = useMemo<ExecutionSnapshot | undefined>(() => ghostIdx == null ? undefined : timeline[Math.max(0, Math.min(ghostIdx, timeline.length - 1))], [timeline, ghostIdx]);

  const onImport = (bundle: SessionBundle) => {
    setTimeline(bundle.history || []);
    setBookmarks(bundle.bookmarks || []);
    setAnnotations(bundle.annotations || []);
    setMonadNotes(bundle.monadNotes || []);
    setIdx(Math.max(0, (bundle.history?.length || 1) - 1));
    setGhostIdx(null);
  };

  return (
    <div className="mpl-debugger-panel">
      {/* Session I/O */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session I/O</header>
        <ImportExportPanel history={timeline} bookmarks={bookmarks} annotations={annotations} monadNotes={monadNotes} onImport={onImport} />
      </section>

      {/* Timeline */}
      {timeline.length > 0 && (
        <section className="mpl-section">
          <header className="mpl-section-h">Timeline</header>
          <TimeScrubber timeline={timeline} index={idx} onChangeIndex={setIdx} ghostIndex={ghostIdx} onChangeGhostIndex={setGhostIdx} bookmarks={bookmarks} annotations={annotations} ruleMarks={ruleMarks} heatValues={heatStrip} bpMarks={bpMarks} searchMarks={searchMarks} />
        </section>
      )}

      {/* Session Search */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session Search</header>
        <SessionSearchPanel history={timeline} bookmarks={bookmarks} annotations={annotations} notes={monadNotes} watches={watches} breakpoints={breakpoints} onGoToIndex={setIdx} onMarksChange={setSearchMarks} />
      </section>

      {/* Diffs + Watches (from 3Q) */}
      <section className="mpl-section">
        <header className="mpl-section-h">State Diffs</header>
        <DiffPanel ghost={ghost} current={current} indexA={ghostIdx} indexB={idx} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Watches</header>
        <WatchesPanel history={timeline} indexB={idx} indexA={ghostIdx} watches={watches} onChange={setWatches} />
      </section>

      {/* Rule Stats + Rule Log */}
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Stats</header>
        <RuleStatsPanel history={timeline} onSelectRuleForHeat={() => {}} onSetHeatWindow={() => {}} onSetHeatNormalize={() => {}} onSetHeatStrip={setHeatStrip} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Log</header>
        <RuleLogPanel history={timeline} onGoToIndex={setIdx} onPinGhost={setGhostIdx} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} onMarksChange={setRuleMarks} />
      </section>

      {/* Breakpoints */}
      <section className="mpl-section">
        <header className="mpl-section-h">Breakpoints</header>
        <BreakpointsPanel history={timeline} currentIndex={idx} breakpoints={breakpoints} onChange={setBreakpoints} onGoToIndex={setIdx} onPinGhost={setGhostIdx} onMarksChange={setBpMarks} />
      </section>

      {/* Notes, Annotations, Bookmarks */}
      <section className="mpl-section">
        <header className="mpl-section-h">Node Notes</header>
        <NodeNotesPanel currentIndex={idx} currentTick={current?.tick ?? idx} selectedMonadId={selectedMonadId ?? undefined} notes={monadNotes} onChange={setMonadNotes} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Annotations</header>
        <AnnotationsPanel currentIndex={idx} currentTick={current?.tick ?? idx} maxIndex={Math.max(0, timeline.length - 1)} annotations={annotations} onChange={setAnnotations} onGoToIndex={setIdx} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Bookmarks</header>
        <BookmarksPanel currentIndex={idx} currentTick={current?.tick ?? idx} bookmarks={bookmarks} onChange={setBookmarks} onGoToIndex={setIdx} />
      </section>

      {/* State */}
      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        {current ? (
          <StateViewer history={timeline} index={idx} snapshot={current} ghostSnapshot={ghost} monadNotes={monadNotes.filter(n => n.index === idx)} selectedMonadId={selectedMonadId} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} />
        ) : (
          <div className="mpl-empty">No snapshot available</div>
        )}
      </section>
    </div>
  );
};
```

> Note: `TimeScrubber` gains a new optional `searchMarks` prop in section 4 below.

---

## 4) `playground/components/TimeScrubber.tsx` (add search markers)

```tsx
// playground/components/TimeScrubber.tsx
// Stage 3R — accept searchMarks and render them on the rail

// ...existing imports & props...
interface TimeScrubberProps {
  // existing props...
  searchMarks?: number[]; // NEW: indices matching current session search
}

export const TimeScrubber: React.FC<TimeScrubberProps> = ({ /* existing props */, searchMarks = [] }) => {
  // ...existing body...
  return (
    <div className="mpl-timescrubber">
      {/* existing controls & heat strip */}
      <div className="mpl-ts-rail" ref={railRef} onClick={onRailClick}>
        {/* existing bands, bookmarks, annotations, ruleMarks, bpMarks */}
        {searchMarks.map((i, k) => (
          <div key={`sr-${k}-${i}`} className="mpl-ts-mark sr" style={{ left: `${toPct(i) * 100}%` }} title={`search @ ${i}`} onClick={e => { e.stopPropagation(); onChangeIndex(i); }} />
        ))}
        {/* existing ghost & handle */}
      </div>
      {/* existing meta */}
    </div>
  );
};
```

---

## 5) `playground/styles/debugger.css` (additions)

```css
/* Stage 3R — Session search UI */
.mpl-session-search { display: grid; gap: 10px; }
.mpl-ss-bar { display: grid; grid-template-columns: 1fr auto auto auto auto; gap: 8px; align-items: center; }
.mpl-ss-saved { display: flex; flex-wrap: wrap; gap: 6px; }
.mpl-ss-results { display: grid; gap: 10px; }
.mpl-ss-group { border: 1px solid #e5e7eb; border-radius: 10px; background: #fff; padding: 8px; }
.mpl-ss-group-h { display: flex; gap: 10px; align-items: center; margin-bottom: 6px; }
.mpl-ss-idx { font-weight: 600; }
.mpl-ss-count { font-size: 12px; color: #6b7280; }
.mpl-ss-group ul { margin: 0; padding: 0 0 0 8px; }
.mpl-ss-group li { list-style: disc; }
.mpl-ss-table { max-height: 300px; overflow: auto; }

/* Rail marker for search */
.mpl-ts-mark.sr { background: #f59e0b; box-shadow: 0 0 0 1px rgba(255,255,255,0.9); }

/* Small x in saved chips */
.mpl-chip .mpl-x { margin-left: 6px; cursor: pointer; font-style: normal; }
```

---

## 6) Example — `playground/pages/DebugExample3R.tsx`

```tsx
// playground/pages/DebugExample3R.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3R() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B", sourceId: "B", targetId: "C" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" }, { ruleId: "R2", at: 2, monadId: "A", sourceId: "A", targetId: "C" } ] },
    { tick: 3, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 3, monadId: "A" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3R — Session Search + Global Timeline</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 7) Query cheatsheet

* `text:"activation"` — matches across annotations/bookmarks/notes/watch/breakpoint text
* `kind:rule` or `kind:rule,annotation` — restrict categories
* `rule:R1 monad:A` — rule filter (prefix OK), can combine with `text:foo`
* `tick:10..30` or `index:100..200` — range limits
* `monad:C` — limit to entries about a specific monad (rule events & monad notes)

---

## 8) Changelog — Stage 3R

* New: `sessionSearch.ts` (parser + engine)
* New: `SessionSearchPanel.tsx` (UI + saved searches)
* Updated: `TimeScrubber.tsx` (search marks), `DebuggerPanel.tsx` (wiring)
* CSS: search UI & rail markers

```
```
