# MPL Playground ‚Äî Stage 3M Patch (Session Annotations, Timeline Labels & Quick‚ÄëJumps)

This patch layers **session annotations**, **timeline labels/markers**, **quick‚Äëjump controls**, and **per‚Äëmonad notes** on top of 3I‚Äì3L. It‚Äôs dependency‚Äëfree and backwards‚Äëcompatible with 3L session bundles.

**What you get**

* Session‚Äëlevel **Annotations** (point or range) with color, label, note
* **Markers** on the time scrubber (bookmarks + annotations), range bands, click‚Äëto‚Äëjump
* **Quick‚Äëjumps & shortcuts** (‚Üê/‚Üí, Ctrl+‚Üê/‚Üí, G/X/B)
* **Per‚Äëmonad notes** for the current tick (badges on nodes + SVG tooltip)
* **Import/Export** extended to include annotations + monad notes (auto‚Äëreads old 3L)

---

## 1) `engine/debugger/annotations.ts`

```ts
// engine/debugger/annotations.ts
// Stage 3M ‚Äî Session annotations (point & range) + per‚Äëmonad notes

export type AnnotationType = "flag" | "phase" | "issue" | "milestone" | "note" | "range";

export interface SessionAnnotation {
  id: string;            // uid
  type: AnnotationType;  // "flag" etc.; use "range" when endIndex/endTick present
  color?: string;        // CSS color (e.g., #DC2626)
  label: string;         // short label for timeline marker
  note?: string;         // longer description
  index: number;         // start index in timeline
  tick: number;          // start tick
  endIndex?: number;     // inclusive end, for ranges
  endTick?: number;      // end tick (optional)
  createdAt: number;     // epoch ms
}

export interface MonadicNote {
  id: string;            // uid
  index: number;         // timeline index
  tick: number;          // tick at index
  monadId: string;       // node id at that tick
  title?: string;
  text: string;          // note content
  color?: string;        // badge color
  createdAt: number;
}

export function createAnnotation(index: number, tick: number, label: string, type: AnnotationType = "flag", color = "#111", note = ""): SessionAnnotation {
  return { id: `ann_${Date.now()}_${Math.random().toString(36).slice(2,8)}`, type, color, label, note, index, tick, createdAt: Date.now() };
}

export function updateAnnotation(a: SessionAnnotation, patch: Partial<SessionAnnotation>): SessionAnnotation {
  return { ...a, ...patch };
}

export function removeAnnotation(list: SessionAnnotation[], id: string): SessionAnnotation[] {
  return list.filter(a => a.id !== id);
}

export function createMonadicNote(index: number, tick: number, monadId: string, text: string, title = "", color = "#111"): MonadicNote {
  return { id: `mn_${Date.now()}_${Math.random().toString(36).slice(2,8)}`, index, tick, monadId: String(monadId), title, text, color, createdAt: Date.now() };
}

export function updateMonadicNote(n: MonadicNote, patch: Partial<MonadicNote>): MonadicNote { return { ...n, ...patch }; }
export function removeMonadicNote(list: MonadicNote[], id: string): MonadicNote[] { return list.filter(n => n.id !== id); }
```

---

## 2) `engine/debugger/sessionIO.ts` (extend for 3M; reads 3L too)

```ts
// engine/debugger/sessionIO.ts
// Stage 3M ‚Äî Import/Export of history + bookmarks + annotations + monad notes

import { ExecutionSnapshot } from "./graphTypes";
import { Bookmark } from "./bookmarks";
import { MonadicNote, SessionAnnotation } from "./annotations";

export type SessionVersion = "3L" | "3M";

export interface SessionBundle3M {
  version: SessionVersion;   // "3M" (preferred) or "3L" (legacy)
  createdAt: number;         // epoch ms
  history: ExecutionSnapshot[];
  bookmarks?: Bookmark[];
  annotations?: SessionAnnotation[]; // 3M
  monadNotes?: MonadicNote[];        // 3M
}

export type SessionBundle = SessionBundle3M; // union kept simple

export function makeBundle(history: ExecutionSnapshot[], bookmarks?: Bookmark[], annotations?: SessionAnnotation[], monadNotes?: MonadicNote[]): SessionBundle {
  return { version: "3M", createdAt: Date.now(), history, bookmarks, annotations, monadNotes };
}

export function validateBundle(obj: unknown): obj is SessionBundle {
  if (!obj || typeof obj !== "object") return false as const;
  const b = obj as any;
  if ((b.version !== "3M" && b.version !== "3L") || !Array.isArray(b.history)) return false;
  for (const s of b.history) { if (typeof s !== "object" || typeof s.tick !== "number" || !Array.isArray(s.monads)) return false; }
  if (b.bookmarks && !Array.isArray(b.bookmarks)) return false;
  if (b.annotations && !Array.isArray(b.annotations)) return false;
  if (b.monadNotes && !Array.isArray(b.monadNotes)) return false;
  return true;
}

export function downloadJSON(filename: string, data: any) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = filename; document.body.appendChild(a); a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

export async function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => { const r = new FileReader(); r.onload = () => resolve(String(r.result || "")); r.onerror = reject; r.readAsText(file); });
}
```

---

## 3) `playground/components/ImportExportPanel.tsx` (augment)

```tsx
// playground/components/ImportExportPanel.tsx
// Stage 3M ‚Äî Export/Import now includes annotations + monad notes

import React, { useRef, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { MonadicNote, SessionAnnotation } from "../../engine/debugger/annotations";
import { makeBundle, validateBundle, downloadJSON, readFileAsText, SessionBundle } from "../../engine/debugger/sessionIO";

interface ImportExportPanelProps {
  history: ExecutionSnapshot[];
  bookmarks: Bookmark[];
  annotations: SessionAnnotation[];
  monadNotes: MonadicNote[];
  onImport: (bundle: SessionBundle) => void;
  filenameBase?: string;
}

export const ImportExportPanel: React.FC<ImportExportPanelProps> = ({ history, bookmarks, annotations, monadNotes, onImport, filenameBase = "MPL_Session" }) => {
  const fileRef = useRef<HTMLInputElement>(null);
  const [err, setErr] = useState<string | null>(null);

  const onExport = () => {
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    downloadJSON(`${filenameBase}_${ts}.json`, makeBundle(history, bookmarks, annotations, monadNotes));
  };

  const onPick = () => fileRef.current?.click();
  const onFile = async (e: React.ChangeEvent<HTMLInputElement>) => {
    setErr(null); const f = e.target.files?.[0]; if (!f) return;
    try { const text = await readFileAsText(f); const data = JSON.parse(text); if (!validateBundle(data)) throw new Error("Invalid session bundle format"); onImport(data); }
    catch (ex: any) { setErr(ex?.message ?? String(ex)); }
    finally { if (fileRef.current) fileRef.current.value = ""; }
  };

  return (
    <div className="mpl-io">
      <div className="mpl-io-row">
        <button className="mpl-btn" onClick={onExport}>‚¨á Export JSON</button>
        <button className="mpl-btn" onClick={onPick}>‚¨Ü Import JSON</button>
        <input ref={fileRef} type="file" accept="application/json,.json" style={{ display: "none" }} onChange={onFile} />
      </div>
      {err && <div className="mpl-io-error">{err}</div>}
    </div>
  );
};
```

---

## 4) `playground/components/AnnotationsPanel.tsx` (new)

```tsx
// playground/components/AnnotationsPanel.tsx
// Stage 3M ‚Äî Manage session annotations (point & range)

import React, { useMemo, useState } from "react";
import { SessionAnnotation, createAnnotation, removeAnnotation, updateAnnotation } from "../../engine/debugger/annotations";

interface AnnotationsPanelProps {
  currentIndex: number; currentTick: number;
  maxIndex: number;
  annotations: SessionAnnotation[];
  onChange: (next: SessionAnnotation[]) => void;
  onGoToIndex: (i: number) => void;
}

export const AnnotationsPanel: React.FC<AnnotationsPanelProps> = ({ currentIndex, currentTick, maxIndex, annotations, onChange, onGoToIndex }) => {
  const [label, setLabel] = useState("");
  const [note, setNote] = useState("");
  const [color, setColor] = useState("#111111");
  const [isRange, setIsRange] = useState(false);
  const [endIdx, setEndIdx] = useState<number>(currentIndex);

  const sorted = useMemo(() => [...annotations].sort((a,b) => a.index - b.index || a.createdAt - b.createdAt), [annotations]);

  const add = () => {
    const a = createAnnotation(currentIndex, currentTick, label.trim() || "A", isRange ? "range" : "flag", color, note.trim());
    if (isRange) { a.endIndex = Math.max(currentIndex, endIdx); if (a.endIndex !== undefined) a.endTick = a.endIndex; }
    onChange([ ...annotations, a ]);
    setLabel(""); setNote("");
  };

  const del = (id: string) => onChange(removeAnnotation(annotations, id));
  const save = (id: string, patch: Partial<SessionAnnotation>) => onChange(annotations.map(x => x.id === id ? updateAnnotation(x, patch) : x));

  return (
    <div className="mpl-ann">
      <div className="mpl-ann-add">
        <input placeholder="Label" value={label} onChange={e => setLabel(e.target.value)} />
        <input placeholder="Note" value={note} onChange={e => setNote(e.target.value)} />
        <input type="color" value={color} onChange={e => setColor(e.target.value)} title="Color" />
        <label className="mpl-check"><input type="checkbox" checked={isRange} onChange={e => setIsRange(e.target.checked)} /> Range</label>
        {isRange && (
          <label>End idx <input type="number" min={currentIndex} max={maxIndex} value={endIdx} onChange={e => setEndIdx(parseInt(e.target.value || ""+currentIndex))} /></label>
        )}
        <button className="mpl-btn" onClick={add}>üè∑ Add Annotation</button>
      </div>

      <div className="mpl-ann-list">
        {sorted.map(a => (
          <div key={a.id} className="mpl-ann-item">
            <div className="mpl-ann-main">
              <span className="mpl-ann-color" style={{ background: a.color || "#111" }} />
              <input value={a.label} onChange={e => save(a.id, { label: e.target.value })} />
              <span className="mpl-ann-meta">idx {a.index}{a.endIndex != null ? `‚Üí${a.endIndex}` : ""} ‚Ä¢ tick {a.tick}{a.endTick != null ? `‚Üí${a.endTick}` : ""}</span>
              <button className="mpl-btn" title="Jump" onClick={() => onGoToIndex(a.index)}>‚§¥</button>
              <button className="mpl-btn mpl-danger" onClick={() => del(a.id)}>Delete</button>
            </div>
            <div className="mpl-ann-note">
              <textarea value={a.note ?? ""} onChange={e => save(a.id, { note: e.target.value })} placeholder="Annotation note" />
            </div>
          </div>
        ))}
        {sorted.length === 0 && <div className="mpl-empty">No annotations yet</div>}
      </div>
    </div>
  );
};
```

---

## 5) `playground/components/NodeNotesPanel.tsx` (new)

```tsx
// playground/components/NodeNotesPanel.tsx
// Stage 3M ‚Äî Manage per‚Äëmonad notes at the current index

import React, { useMemo, useState } from "react";
import { MonadicNote, createMonadicNote, removeMonadicNote, updateMonadicNote } from "../../engine/debugger/annotations";

interface NodeNotesPanelProps {
  currentIndex: number; currentTick: number;
  selectedMonadId?: string | null;      // set by graph selection
  notes: MonadicNote[];
  onChange: (next: MonadicNote[]) => void;
}

export const NodeNotesPanel: React.FC<NodeNotesPanelProps> = ({ currentIndex, currentTick, selectedMonadId, notes, onChange }) => {
  const [monadId, setMonadId] = useState<string>(selectedMonadId ? String(selectedMonadId) : "");
  const [title, setTitle] = useState("");
  const [text, setText] = useState("");
  const [color, setColor] = useState("#111111");

  // sync input with selection
  React.useEffect(() => { if (selectedMonadId != null) setMonadId(String(selectedMonadId)); }, [selectedMonadId]);

  const atIndex = useMemo(() => notes.filter(n => n.index === currentIndex), [notes, currentIndex]);

  const add = () => {
    if (!monadId) return;
    const n = createMonadicNote(currentIndex, currentTick, monadId, text.trim(), title.trim(), color);
    onChange([ ...notes, n ]);
    setTitle(""); setText("");
  };

  const del = (id: string) => onChange(removeMonadicNote(notes, id));
  const save = (id: string, patch: Partial<MonadicNote>) => onChange(notes.map(x => x.id === id ? updateMonadicNote(x, patch) : x));

  return (
    <div className="mpl-nn">
      <div className="mpl-nn-add">
        <input placeholder="Monad ID" value={monadId} onChange={e => setMonadId(e.target.value)} />
        <input placeholder="Title (optional)" value={title} onChange={e => setTitle(e.target.value)} />
        <input placeholder="Note text" value={text} onChange={e => setText(e.target.value)} />
        <input type="color" value={color} onChange={e => setColor(e.target.value)} title="Color" />
        <button className="mpl-btn" onClick={add}>üìù Add Note</button>
      </div>

      <div className="mpl-nn-list">
        {atIndex.map(n => (
          <div key={n.id} className="mpl-nn-item">
            <div className="mpl-nn-main">
              <span className="mpl-nn-color" style={{ background: n.color || "#111" }} />
              <input value={n.monadId} onChange={e => save(n.id, { monadId: e.target.value })} />
              <input value={n.title ?? ""} onChange={e => save(n.id, { title: e.target.value })} placeholder="Title" />
              <button className="mpl-btn mpl-danger" onClick={() => del(n.id)}>Delete</button>
            </div>
            <div className="mpl-nn-note">
              <textarea value={n.text} onChange={e => save(n.id, { text: e.target.value })} />
            </div>
          </div>
        ))}
        {atIndex.length === 0 && <div className="mpl-empty">No notes for this tick</div>}
      </div>
    </div>
  );
};
```

---

## 6) `playground/components/TimeScrubber.tsx` (markers + bands)

```tsx
// playground/components/TimeScrubber.tsx
// Stage 3M ‚Äî Timeline markers (bookmarks + annotations) and bands for ranges

import React, { useEffect, useMemo, useRef, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { SessionAnnotation } from "../../engine/debugger/annotations";

interface TimeScrubberProps {
  timeline: ExecutionSnapshot[];
  index: number; onChangeIndex: (i: number) => void;
  ghostIndex: number | null; onChangeGhostIndex: (i: number | null) => void;
  bookmarks?: Bookmark[];
  annotations?: SessionAnnotation[];
}

export const TimeScrubber: React.FC<TimeScrubberProps> = ({ timeline, index, onChangeIndex, ghostIndex, onChangeGhostIndex, bookmarks = [], annotations = [] }) => {
  const N = timeline.length; const min = 0; const max = Math.max(0, N - 1);
  const [playing, setPlaying] = useState(false);
  const [speed, setSpeed] = useState(1); const [loop, setLoop] = useState(true);
  const timerRef = useRef<number | null>(null);
  const railRef = useRef<HTMLDivElement>(null);

  useEffect(() => { if (index > max) onChangeIndex(max); }, [N]);

  useEffect(() => {
    if (!playing) return;
    const ms = 600 / (speed || 1);
    const id = window.setInterval(() => onChangeIndex(index < max ? index + 1 : (loop ? min : max)), ms);
    timerRef.current = id as unknown as number; return () => { if (timerRef.current) window.clearInterval(timerRef.current); timerRef.current = null; };
  }, [playing, speed, index, max, loop, onChangeIndex]);

  const tick = timeline[index]?.tick ?? index;
  const aTick = ghostIndex != null ? (timeline[ghostIndex]?.tick ?? ghostIndex) : null;

  const toPct = (i: number) => (max === min ? 0 : (i - min) / (max - min));
  const onRailClick = (e: React.MouseEvent) => {
    if (!railRef.current) return; const rect = railRef.current.getBoundingClientRect();
    const frac = (e.clientX - rect.left) / rect.width; const i = Math.round(min + frac * (max - min)); onChangeIndex(i);
  };

  return (
    <div className="mpl-timescrubber">
      <div className="mpl-ts-row">
        <div className="mpl-ts-controls">
          <button className="mpl-btn" onClick={() => onChangeIndex(min)} title="Start">‚èÆ</button>
          <button className="mpl-btn" onClick={() => onChangeIndex(Math.max(min, index - 1))} title="Step back">‚óÄ</button>
          <button className="mpl-btn" onClick={() => setPlaying(p => !p)} title={playing ? "Pause" : "Play"}>{playing ? "‚è∏" : "‚ñ∂"}</button>
          <button className="mpl-btn" onClick={() => onChangeIndex(Math.min(max, index + 1))} title="Step forward">‚ñ∂</button>
          <button className="mpl-btn" onClick={() => onChangeIndex(max)} title="End">‚è≠</button>
        </div>
        <div className="mpl-ts-speed">
          <label>Speed
            <select value={speed} onChange={e => setSpeed(parseFloat(e.target.value))}>
              <option value={0.25}>0.25√ó</option><option value={0.5}>0.5√ó</option><option value={1}>1√ó</option><option value={2}>2√ó</option><option value={4}>4√ó</option>
            </select>
          </label>
          <label className="mpl-check"><input type="checkbox" checked={loop} onChange={e => setLoop(e.target.checked)} /> Loop</label>
        </div>
      </div>

      {/* Rail with markers & bands */}
      <div className="mpl-ts-rail" ref={railRef} onClick={onRailClick}>
        {/* Range bands */}
        {annotations.filter(a => a.endIndex != null && a.endIndex! > a.index).map(a => (
          <div key={`band-${a.id}`} className="mpl-ts-band" style={{ left: `${toPct(a.index) * 100}%`, width: `${(toPct(a.endIndex!) - toPct(a.index)) * 100}%`, background: a.color || "#999" }} title={`${a.label} (${a.index}‚Üí${a.endIndex})`} />
        ))}
        {/* Bookmark markers */}
        {bookmarks.map((b, k) => (
          <div key={`bm-${k}`} className="mpl-ts-mark bm" style={{ left: `${toPct(b.index) * 100}%` }} title={b.label || `idx ${b.index}`} onClick={e => { e.stopPropagation(); onChangeIndex(b.index); }} />
        ))}
        {/* Annotation point markers */}
        {annotations.filter(a => a.endIndex == null).map(a => (
          <div key={`ann-${a.id}`} className="mpl-ts-mark ann" style={{ left: `${toPct(a.index) * 100}%`, background: a.color || "#111" }} title={a.label} onClick={e => { e.stopPropagation(); onChangeIndex(a.index); }} />
        ))}
        {/* Ghost pin marker */}
        {ghostIndex != null && (
          <div className="mpl-ts-ghost-pin" style={{ left: `${toPct(ghostIndex) * 100}%` }} title={`A @ ${ghostIndex}`} />
        )}
        {/* Current index handle */}
        <div className="mpl-ts-handle" style={{ left: `${toPct(index) * 100}%` }} />
      </div>

      <div className="mpl-ts-meta">
        <span>Index: {index}/{max}</span>
        <span>Tick: {tick}</span>
        <span>A: {ghostIndex != null ? `${ghostIndex}/${max}${aTick != null ? ` (t${aTick})` : ""}` : "‚Äî"}</span>
      </div>
    </div>
  );
};
```

---

## 7) `playground/components/GraphStateView.tsx` (node note badges + tooltip)

```tsx
// playground/components/GraphStateView.tsx
// Stage 3M ‚Äî Render per‚Äëmonad note badges + SVG <title> tooltip; selection highlight

import React, { useCallback, useMemo, useRef, useState, useEffect } from "react";
import { ExecutionSnapshot, GraphData } from "../../engine/debugger/graphTypes";
import { buildGraphFromSnapshot } from "../../engine/debugger/toGraph";
import { MonadicNote } from "../../engine/debugger/annotations";

interface GraphStateViewProps {
  snapshot: ExecutionSnapshot;         // current (B)
  ghostSnapshot?: ExecutionSnapshot;   // optional (A)
  width?: number; height?: number;
  onSelectMonad?: (id: string) => void;
  neighborFocusMode?: boolean;
  highlightRules?: boolean; highlightWindowTicks?: number;
  diffMode?: boolean;
  monadNotes?: MonadicNote[];          // notes at current index
  selectedMonadId?: string | null;     // external selection
}

function useMeasure(ref: React.RefObject<HTMLElement>) {
  const [size, setSize] = useState<{ width: number; height: number }>({ width: 300, height: 200 });
  useEffect(() => { if (!ref.current) return; const ro = new ResizeObserver(([entry]) => setSize({ width: entry.contentRect.width, height: entry.contentRect.height })); ro.observe(ref.current); return () => ro.disconnect(); }, [ref]);
  return size;
}

export const GraphStateView: React.FC<GraphStateViewProps> = ({ snapshot, ghostSnapshot, width, height, onSelectMonad, neighborFocusMode, highlightRules = true, highlightWindowTicks = 3, diffMode = true, monadNotes = [], selectedMonadId = null }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const size = useMeasure(containerRef);
  const W = width ?? size.width ?? 600; const H = height ?? size.height ?? 400;

  const graph: GraphData = useMemo(() => buildGraphFromSnapshot(snapshot, { nodeRadius: 14, spacing: 80 }), [snapshot]);
  const ghost: GraphData | null = useMemo(() => ghostSnapshot ? buildGraphFromSnapshot(ghostSnapshot, { nodeRadius: 12, spacing: 80 }) : null, [ghostSnapshot]);

  const notesByNode = useMemo(() => {
    const map = new Map<string, MonadicNote[]>();
    for (const n of monadNotes) { const k = String(n.monadId); const arr = map.get(k) || []; arr.push(n); map.set(k, arr); }
    return map;
  }, [monadNotes]);

  // Basic pan/zoom
  const [zoom, setZoom] = useState(1); const [offset, setOffset] = useState({ x: 0, y: 0 });
  const dragRef = useRef<{ x: number; y: number } | null>(null);
  const onWheel = useCallback((e: React.WheelEvent) => { e.preventDefault(); const f = Math.exp(-e.deltaY * 0.001); setZoom(z => Math.min(4, Math.max(0.25, z * f))); }, []);
  const onMouseDown = useCallback((e: React.MouseEvent) => { dragRef.current = { x: e.clientX, y: e.clientY }; }, []);
  const onMouseMove = useCallback((e: React.MouseEvent) => { if (!dragRef.current) return; const dx = e.clientX - dragRef.current.x; const dy = e.clientY - dragRef.current.y; dragRef.current = { x: e.clientX, y: e.clientY }; setOffset(o => ({ x: o.x + dx, y: o.y + dy })); }, []);
  const onMouseUp = useCallback(() => { dragRef.current = null; }, []);

  const neighborSet = useMemo(() => { if (!neighborFocusMode) return null as null | Set<string>; const focusId = snapshot.focusMonadId != null ? String(snapshot.focusMonadId) : (graph.nodes.find(n => n.active)?.id ?? null); if (!focusId) return null; const s = new Set<string>(); for (const e of graph.edges) { if (e.source === focusId) s.add(e.target); if (e.target === focusId) s.add(e.source); } s.add(focusId); return s; }, [neighborFocusMode, graph, snapshot.focusMonadId]);

  const isRecent = useCallback((at?: number) => { if (at == null) return false; const dt = snapshot.tick - at; return dt >= 0 && dt <= (highlightWindowTicks ?? 3); }, [snapshot.tick, highlightWindowTicks]);

  return (
    <div ref={containerRef} className="mpl-graph-container" style={{ width: width ? `${width}px` : "100%", height: height ? `${height}px` : "100%" }}>
      <svg className="mpl-graph-svg" width={W} height={H} onWheel={onWheel} onMouseDown={onMouseDown} onMouseMove={onMouseMove} onMouseUp={onMouseUp}>
        <defs>
          <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" /></marker>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="3" result="coloredBlur" /><feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge></filter>
        </defs>

        <g transform={`translate(${W / 2 + offset.x}, ${H / 2 + offset.y}) scale(${zoom})`}>
          {/* Ghost layer */}
          {ghost && (
            <g className="mpl-ghost-layer">
              {ghost.edges.map(e => { const a = ghost.nodes.find(n => n.id === e.source)!; const b = ghost.nodes.find(n => n.id === e.target)!; return <line key={`g-${e.id}`} x1={a.x} y1={a.y} x2={b.x} y2={b.y} className="mpl-ghost-edge" />; })}
              {ghost.nodes.map(n => (
                <g key={`g-${n.id}`} transform={`translate(${n.x}, ${n.y})`} className="mpl-ghost-node">
                  <circle r={n.radius} className="mpl-ghost-node-circle" />
                  <text className="mpl-ghost-node-label" y={n.radius + 12} textAnchor="middle">{n.label ?? n.id}</text>
                </g>
              ))}
            </g>
          )}

          {/* Current layer */}
          {graph.edges.map(e => { const a = graph.nodes.find(n => n.id === e.source)!; const b = graph.nodes.find(n => n.id === e.target)!; const dimmed = neighborSet && !(neighborSet.has(a.id) && neighborSet.has(b.id)); return <line key={e.id} x1={a.x} y1={a.y} x2={b.x} y2={b.y} className={`mpl-edge ${dimmed ? "mpl-dim" : ""}`} />; })}

          {graph.nodes.map(n => {
            const dimmed = neighborSet && !neighborSet.has(n.id);
            const fired = !!(highlightRules && isRecent(n.lastRuleAt));
            const selected = selectedMonadId != null && String(selectedMonadId) === n.id;
            const nodeNotes = notesByNode.get(n.id) || [];
            return (
              <g key={n.id} transform={`translate(${n.x}, ${n.y})`} className="mpl-node" onClick={() => onSelectMonad?.(n.id)}>
                <circle r={n.radius} className={`mpl-node-circle ${n.active ? "mpl-node-active" : ""} ${dimmed ? "mpl-dim" : ""} ${fired ? "mpl-node-fired" : ""} ${selected ? "mpl-node-selected" : ""}`} filter={(n.active || fired || selected) ? "url(#glow)" : undefined} />
                <text className={`mpl-node-label ${dimmed ? "mpl-dim" : ""}`} y={n.radius + 14} textAnchor="middle">{n.label ?? n.id}</text>
                {nodeNotes.length > 0 && (
                  <g className="mpl-node-note-badge" transform={`translate(${n.radius * 0.9}, ${-n.radius * 0.9})`}>
                    <circle r={9} className="mpl-note-circle" fill={nodeNotes[0].color || "#111"} />
                    <text textAnchor="middle" dominantBaseline="central" className="mpl-note-text">‚úé</text>
                    <title>{nodeNotes.map(m => (m.title ? `${m.title}: ` : "") + m.text).join("\n")}</title>
                  </g>
                )}
              </g>
            );
          })}
        </g>
      </svg>
    </div>
  );
};
```

---

## 8) `playground/components/StateViewer.tsx` (pass monad notes + selection)

```tsx
// playground/components/StateViewer.tsx
// Stage 3M ‚Äî propagate monad notes + selected monad into GraphStateView

import React, { useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { GraphStateView } from "./GraphStateView";
import { MonadicNote } from "../../engine/debugger/annotations";

interface StateViewerProps {
  snapshot: ExecutionSnapshot;           // current (B)
  ghostSnapshot?: ExecutionSnapshot;     // optional (A)
  monadNotes?: MonadicNote[];            // notes for current index
  selectedMonadId?: string | null;
  onSelectMonad?: (id: string) => void;
}

type ViewMode = "table" | "graph";

export const StateViewer: React.FC<StateViewerProps> = ({ snapshot, ghostSnapshot, monadNotes = [], selectedMonadId = null, onSelectMonad }) => {
  const [mode, setMode] = useState<ViewMode>("table");
  const [neighborOnly, setNeighborOnly] = useState(false);
  const [showHighlights, setShowHighlights] = useState(true);
  const [windowTicks, setWindowTicks] = useState(3);
  const [diffMode, setDiffMode] = useState(true);

  const rows = useMemo(() => snapshot.monads.map(m => ({ id: String(m.id), neighbors: m.neighbors?.length ?? 0, active: !!(m.active || (snapshot.focusMonadId != null && String(snapshot.focusMonadId) === String(m.id))) })), [snapshot]);

  return (
    <div className="mpl-state-viewer">
      <div className="mpl-toolbar">
        <div className="mpl-seg">
          <button className={`mpl-btn ${mode === "table" ? "active" : ""}`} onClick={() => setMode("table")}>Table</button>
          <button className={`mpl-btn ${mode === "graph" ? "active" : ""}`} onClick={() => setMode("graph")}>Graph</button>
        </div>
        {mode === "graph" && (
          <div className="mpl-toolbar-right">
            <label className="mpl-check"><input type="checkbox" checked={neighborOnly} onChange={e => setNeighborOnly(e.target.checked)} /> Neighbor focus</label>
            <label className="mpl-check"><input type="checkbox" checked={showHighlights} onChange={e => setShowHighlights(e.target.checked)} /> Rule highlights</label>
            <label className="mpl-check">Window
              <select value={windowTicks} onChange={e => setWindowTicks(parseInt(e.target.value))}><option value={1}>1</option><option value={3}>3</option><option value={5}>5</option><option value={10}>10</option></select> ticks
            </label>
            <label className="mpl-check"><input type="checkbox" checked={diffMode} onChange={e => setDiffMode(e.target.checked)} /> Diff mode</label>
          </div>
        )}
      </div>

      {mode === "table" ? (
        <div className="mpl-table-wrap">
          <table className="mpl-table">
            <thead><tr><th>ID</th><th>Neighbors</th><th>Active</th></tr></thead>
            <tbody>
              {rows.map(r => (
                <tr key={r.id} onClick={() => onSelectMonad?.(r.id)} className={r.active ? "mpl-row-active" : undefined}>
                  <td>{r.id}</td><td>{r.neighbors}</td><td>{r.active ? "‚óè" : ""}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="mpl-graph-wrap">
          <GraphStateView
            snapshot={snapshot}
            ghostSnapshot={ghostSnapshot}
            onSelectMonad={onSelectMonad}
            neighborFocusMode={neighborOnly}
            highlightRules={showHighlights}
            highlightWindowTicks={windowTicks}
            diffMode={diffMode}
            monadNotes={monadNotes}
            selectedMonadId={selectedMonadId}
          />
        </div>
      )}
    </div>
  );
};
```

---

## 9) `playground/components/DebuggerPanel.tsx` (wire everything + shortcuts)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3M ‚Äî Debugger panel with annotations, node notes, markers, and shortcuts

import React, { useEffect, useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";
import { TimeScrubber } from "./TimeScrubber";
import { ImportExportPanel } from "./ImportExportPanel";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { BookmarksPanel } from "./BookmarksPanel";
import { SessionBundle } from "../../engine/debugger/sessionIO";
import { AnnotationsPanel } from "./AnnotationsPanel";
import { MonadicNote, SessionAnnotation } from "../../engine/debugger/annotations";
import { NodeNotesPanel } from "./NodeNotesPanel";

interface DebuggerPanelProps {
  snapshot?: ExecutionSnapshot;   // fallback single snapshot
  history?: ExecutionSnapshot[];  // preferred for time travel
  onFocusMonad?: (id: string) => void;
}

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, history, onFocusMonad }) => {
  const [timeline, setTimeline] = useState<ExecutionSnapshot[]>(() => history ?? (snapshot ? [snapshot] : []));
  useEffect(() => { if (history && history.length) setTimeline(history); }, [history?.length]);
  useEffect(() => { if (!history && snapshot) setTimeline([snapshot]); }, [snapshot?.tick]);

  const [idx, setIdx] = useState(() => Math.max(0, timeline.length - 1));
  useEffect(() => { setIdx(Math.max(0, timeline.length - 1)); }, [timeline.length]);

  const [ghostIdx, setGhostIdx] = useState<number | null>(null);
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);
  const [annotations, setAnnotations] = useState<SessionAnnotation[]>([]);
  const [monadNotes, setMonadNotes] = useState<MonadicNote[]>([]);
  const [selectedMonadId, setSelectedMonadId] = useState<string | null>(null);

  const current = useMemo<ExecutionSnapshot | undefined>(() => timeline[Math.max(0, Math.min(idx, timeline.length - 1))], [timeline, idx]);
  const ghost = useMemo<ExecutionSnapshot | undefined>(() => ghostIdx == null ? undefined : timeline[Math.max(0, Math.min(ghostIdx, timeline.length - 1))], [timeline, ghostIdx]);

  // Import/Export
  const onImport = (bundle: SessionBundle) => {
    setTimeline(bundle.history || []);
    setBookmarks(bundle.bookmarks || []);
    setAnnotations(bundle.annotations || []);
    setMonadNotes(bundle.monadNotes || []);
    setIdx(Math.max(0, (bundle.history?.length || 1) - 1));
    setGhostIdx(null);
  };

  // Keyboard shortcuts
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.target && (e.target as HTMLElement).tagName.match(/INPUT|TEXTAREA|SELECT/)) return; // avoid when typing
      if (e.key === "ArrowLeft") { setIdx(i => Math.max(0, i - 1)); e.preventDefault(); }
      if (e.key === "ArrowRight") { setIdx(i => Math.min(timeline.length - 1, i + 1)); e.preventDefault(); }
      if ((e.ctrlKey || e.metaKey) && e.key === "ArrowLeft") {
        // prev bookmark
        const prev = [...bookmarks].filter(b => b.index < idx).sort((a,b) => b.index - a.index)[0]; if (prev) setIdx(prev.index);
      }
      if ((e.ctrlKey || e.metaKey) && e.key === "ArrowRight") {
        const next = [...bookmarks].filter(b => b.index > idx).sort((a,b) => a.index - b.index)[0]; if (next) setIdx(next.index);
      }
      if (e.key.toLowerCase() === "g") { setGhostIdx(idx); }
      if (e.key.toLowerCase() === "x") { setGhostIdx(null); }
      if (e.key.toLowerCase() === "b") {
        // quick unnamed bookmark
        setBookmarks(bs => ([ ...bs, { id: `bm_${Date.now()}`, index: idx, tick: current?.tick ?? idx, label: "" as any, note: "", createdAt: Date.now() } as any ]));
      }
    };
    window.addEventListener("keydown", handler); return () => window.removeEventListener("keydown", handler);
  }, [idx, timeline.length, bookmarks, current?.tick]);

  // Notes for current index
  const notesAtIndex = useMemo(() => monadNotes.filter(n => n.index === idx), [monadNotes, idx]);

  return (
    <div className="mpl-debugger-panel">
      {/* Session I/O */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session I/O</header>
        <ImportExportPanel history={timeline} bookmarks={bookmarks} annotations={annotations} monadNotes={monadNotes} onImport={onImport} />
      </section>

      {/* Timeline + markers */}
      {timeline.length > 0 && (
        <section className="mpl-section">
          <header className="mpl-section-h">Timeline</header>
          <TimeScrubber timeline={timeline} index={idx} onChangeIndex={setIdx} ghostIndex={ghostIdx} onChangeGhostIndex={setGhostIdx} bookmarks={bookmarks} annotations={annotations} />
        </section>
      )}

      {/* Bookmarks */}
      <section className="mpl-section">
        <header className="mpl-section-h">Bookmarks</header>
        <BookmarksPanel currentIndex={idx} currentTick={current?.tick ?? idx} bookmarks={bookmarks} onChange={setBookmarks} onGoToIndex={setIdx} />
      </section>

      {/* Annotations */}
      <section className="mpl-section">
        <header className="mpl-section-h">Annotations</header>
        <AnnotationsPanel currentIndex={idx} currentTick={current?.tick ?? idx} maxIndex={Math.max(0, timeline.length - 1)} annotations={annotations} onChange={setAnnotations} onGoToIndex={setIdx} />
      </section>

      {/* Node notes */}
      <section className="mpl-section">
        <header className="mpl-section-h">Node Notes</header>
        <NodeNotesPanel currentIndex={idx} currentTick={current?.tick ?? idx} selectedMonadId={selectedMonadId ?? undefined} notes={monadNotes} onChange={setMonadNotes} />
      </section>

      {/* State */}
      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        {current ? (
          <StateViewer snapshot={current} ghostSnapshot={ghost} monadNotes={notesAtIndex} selectedMonadId={selectedMonadId} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} />
        ) : (
          <div className="mpl-empty">No snapshot available</div>
        )}
      </section>
    </div>
  );
};
```

---

## 10) `playground/styles/debugger.css` (additions)

```css
/* Stage 3M ‚Äî Markers, bands, node notes, selection */
.mpl-ts-rail { position: relative; height: 18px; background: #eee; border-radius: 10px; cursor: pointer; }
.mpl-ts-handle { position: absolute; top: -4px; width: 8px; height: 26px; background: #111; border-radius: 4px; transform: translateX(-50%); }
.mpl-ts-ghost-pin { position: absolute; top: -6px; width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 10px solid #6b7280; transform: translateX(-50%); }
.mpl-ts-mark { position: absolute; top: 2px; width: 6px; height: 14px; border-radius: 2px; transform: translateX(-50%); background: #111; }
.mpl-ts-mark.bm { background: #2563eb; }
.mpl-ts-mark.ann { box-shadow: 0 0 0 2px rgba(255,255,255,0.6); }
.mpl-ts-band { position: absolute; top: 0; height: 100%; opacity: 0.2; border-radius: 10px; }

.mpl-ann { display: grid; gap: 10px; }
.mpl-ann-add { display: grid; grid-template-columns: 1fr 2fr auto auto auto auto; gap: 8px; }
.mpl-ann-list { display: grid; gap: 8px; }
.mpl-ann-item { border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; background: #fff; }
.mpl-ann-main { display: grid; grid-template-columns: 14px 1fr auto auto auto; gap: 8px; align-items: center; }
.mpl-ann-color { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #e5e7eb; }
.mpl-ann-note textarea { width: 100%; min-height: 52px; padding: 6px 8px; }

.mpl-nn { display: grid; gap: 10px; }
.mpl-nn-add { display: grid; grid-template-columns: 1fr 1fr 2fr auto auto; gap: 8px; }
.mpl-nn-list { display: grid; gap: 8px; }
.mpl-nn-item { border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; background: #fff; }
.mpl-nn-main { display: grid; grid-template-columns: 12px 1fr 1fr auto; gap: 8px; align-items: center; }
.mpl-nn-color { width: 12px; height: 12px; border-radius: 2px; border: 1px solid #e5e7eb; }
.mpl-nn-note textarea { width: 100%; min-height: 52px; padding: 6px 8px; }

/* Graph */
.mpl-node-selected { stroke: #111; stroke-width: 2.2; }
.mpl-node-note-badge .mpl-note-circle { stroke: #fff; stroke-width: 1; }
.mpl-node-note-badge .mpl-note-text { font-size: 9px; fill: #fff; font-weight: 700; }
```

---

## 11) Example page ‚Äî `playground/pages/DebugExample3M.tsx`

```tsx
// playground/pages/DebugExample3M.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3M() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"], active: true }, { id: "B", neighbors: ["A"] }, { id: "C", neighbors: ["A"] } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3M ‚Äî Annotations ‚Ä¢ Markers ‚Ä¢ Node Notes</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 12) Notes & tips

* **Range annotations**: set end index in panel; they render as semi‚Äëtransparent bands on the rail.
* **Per‚Äëmonad notes**: appear as a ‚úé badge on nodes; hover to see a multiline tooltip (SVG `<title>`).
* **Shortcuts**: `‚Üê/‚Üí` step; `Ctrl/Cmd+‚Üê/‚Üí` prev/next bookmark; `G` pin ghost; `X` clear ghost; `B` quick bookmark.
* **Import**: 3L bundles load fine; annotations/monadNotes default to empty.

---

## 13) Changelog ‚Äî Stage 3M

* New: `annotations.ts`, `AnnotationsPanel.tsx`, `NodeNotesPanel.tsx`
* Updated: `sessionIO.ts`, `ImportExportPanel.tsx`, `TimeScrubber.tsx` (markers/bands), `GraphStateView.tsx`, `StateViewer.tsx`, `DebuggerPanel.tsx`
* CSS: timeline markers, bands, node badges, selection highlight

```
```
