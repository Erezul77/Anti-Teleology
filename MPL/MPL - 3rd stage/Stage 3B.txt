# MPL – Stage 3B (Multi‑Threaded Workers + Shared Buffers)

Stage **3B** adds a **CPU stepper accelerated with Web Workers** over **SharedArrayBuffer** (SAB). The grid is partitioned into row‑tiles and computed in parallel.

* **Parallel CPU**: N workers process disjoint row ranges each tick
* **Double‑buffered**: shared A/B buffers avoid copies
* **Edge/Neighborhood**: Moore/VonNeumann · Clip/Wrap (per 3A parity)
* **Auto fallback**: if `crossOriginIsolated` or SAB is unavailable, we fall back to the single‑thread CPU (3A) path
* **Configurable**: thread count, rule, topology, edges

> For SAB, your dev server must set **COOP/COEP** headers. Instructions below.

---

## Directory Tree (updated)

```
MPL-Stage-3/
├─ package.json
├─ tsconfig.json
├─ vite.config.ts               # UPDATED: add COOP/COEP headers for SAB
├─ README.md
├─ src/
│  ├─ runtime/                 # existing
│  ├─ web/
│  │  ├─ workers-main.ts      # NEW: 3B UI + scheduler (workers)
│  └─ workers/
│     └─ step-worker.ts       # NEW: tile stepper worker
└─ index-3b.html               # NEW: Stage 3B launcher
```

Add to **package.json**:

```json
{
  "scripts": {
    "dev:3b": "vite --open index-3b.html"
  }
}
```

---

## vite.config.ts (COOP/COEP headers for SAB) — add or merge

```ts
import { defineConfig } from 'vite';

export default defineConfig({
  server: {
    headers: {
      'Cross-Origin-Opener-Policy': 'same-origin',
      'Cross-Origin-Embedder-Policy': 'require-corp'
    }
  }
});
```

> With these headers, the page becomes **cross‑origin isolated** and can use `SharedArrayBuffer`.

---

## src/workers/step-worker.ts (NEW — row‑tile stepper)

```ts
// Web Worker (module). Computes next state for an assigned row range over SharedArrayBuffers.
// Cells are 0/1 stored in Uint8Array, double-buffered (A/B). One tile per worker.

export type InitMsg = {
  type: 'init';
  width: number; height: number;
  y0: number; y1: number;              // [y0, y1)
  useMoore: boolean; wrapEdges: boolean;
  birthMask: number; surviveMask: number;
  a: SharedArrayBuffer; b: SharedArrayBuffer;
};

export type StepMsg = { type: 'step'; aIsInput: boolean };

let W=0, H=0, Y0=0, Y1=0;
let useMoore=true, wrapEdges=false;
let Bmask=0, Smask=0;
let A!: Uint8Array; let B!: Uint8Array;

function idx(x:number, y:number){ return y*W + x; }
function inBounds(x:number,y:number){ return x>=0 && y>=0 && x<W && y<H; }
function wrap(v:number, m:number){ let r = v % m; return r<0? r+m : r; }

function get(src: Uint8Array, x:number, y:number){
  if (wrapEdges){ x = wrap(x,W); y = wrap(y,H); return src[idx(x,y)]; }
  return inBounds(x,y)? src[idx(x,y)] : 0;
}

function stepOnce(src: Uint8Array, dst: Uint8Array){
  if (useMoore){
    for (let y=Y0; y<Y1; y++){
      for (let x=0; x<W; x++){
        let n=0;
        // 8 neighbors
        for (let dy=-1; dy<=1; dy++){
          for (let dx=-1; dx<=1; dx++){
            if (dx===0 && dy===0) continue;
            n += get(src, x+dx, y+dy) & 1;
          }
        }
        const self = src[idx(x,y)] & 1;
        const birth = (Bmask >>> n) & 1;
        const surv  = (Smask >>> n) & 1;
        dst[idx(x,y)] = self? (surv?1:0) : (birth?1:0);
      }
    }
  } else {
    const offs = [ [1,0],[-1,0],[0,1],[0,-1] ] as const;
    for (let y=Y0; y<Y1; y++){
      for (let x=0; x<W; x++){
        let n=0; for (let i=0;i<4;i++){ const [dx,dy]=offs[i]; n += get(src,x+dx,y+dy) & 1; }
        const self = src[idx(x,y)] & 1;
        const birth = (Bmask >>> n) & 1;
        const surv  = (Smask >>> n) & 1;
        dst[idx(x,y)] = self? (surv?1:0) : (birth?1:0);
      }
    }
  }
}

self.onmessage = (e: MessageEvent<InitMsg|StepMsg>) => {
  const msg = e.data;
  if (msg.type==='init'){
    W=msg.width; H=msg.height; Y0=msg.y0; Y1=msg.y1;
    useMoore=msg.useMoore; wrapEdges=msg.wrapEdges; Bmask=msg.birthMask>>>0; Smask=msg.surviveMask>>>0;
    A = new Uint8Array(msg.a); B = new Uint8Array(msg.b);
    (self as any).postMessage({ type:'ready', y0:Y0, y1:Y1 });
  } else if (msg.type==='step'){
    const src = msg.aIsInput? A : B; const dst = msg.aIsInput? B : A;
    stepOnce(src, dst);
    (self as any).postMessage({ type:'done' });
  }
};
```

---

## src/web/workers-main.ts (NEW — pool + UI)

```ts
// Stage 3B UI: multi-thread CPU with SAB, or fallback to single-thread if not isolated.

const $ = <T extends HTMLElement>(id:string)=> document.getElementById(id) as T;
const canvas = $('grid') as HTMLCanvasElement; const ctx = canvas.getContext('2d')!;
const playBtn=$('play'), stepBtn=$('step'), seedBtn=$('seed');
const ruleInp=$('rule') as HTMLInputElement; const topoSel=$('topo') as HTMLSelectElement; const edgeSel=$('edges') as HTMLSelectElement;
const threadsInp=$('threads') as HTMLInputElement; const modeLbl=$('mode');
const speedInp=$('speed') as HTMLInputElement; const speedLbl=$('speedLabel');

let width=192, height=144, cell=4; let playing=false; let ms=Number(speedInp.value)||33;
canvas.width = width*cell; canvas.height = height*cell;

let A: SharedArrayBuffer|ArrayBuffer; let B: SharedArrayBuffer|ArrayBuffer; let aIsInput=true;
let viewA: Uint8Array; let viewB: Uint8Array;

let workers: Worker[] = []; let tiles: {y0:number;y1:number;}[] = []; let readyCount=0;
let useWorkers=false; let singleThread=false;

function setSpeed(){ speedLbl.textContent = `${ms} ms/step`; }
setSpeed();

function bsToMasks(bs: string){
  const m = bs.trim().toUpperCase().match(/^(?:B([0-8]*)\/S([0-8]*))|(?:S([0-8]*)\/B([0-8]*))$/);
  if (!m) throw new Error('Invalid B/S rule');
  const b = (m[1] ?? m[4] ?? '').split('').filter(Boolean).map(Number);
  const s = (m[2] ?? m[3] ?? '').split('').filter(Boolean).map(Number);
  let birth=0, surv=0; for (const n of b) birth |= (1<<n); for (const n of s) surv |= (1<<n);
  return { birthMask: birth>>>0, surviveMask: surv>>>0 };
}

function randomize(p=0.22){ for (let i=0;i<viewA.length;i++) viewA[i] = Math.random()<p?1:0; for (let i=0;i<viewB.length;i++) viewB[i]=0; }

function draw(buf: Uint8Array){
  ctx.fillStyle='#0a0e11'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#e8eef2';
  for (let y=0;y<height;y++) for (let x=0;x<width;x++){ if (buf[y*width+x] & 1) ctx.fillRect(x*cell,y*cell,cell,cell); }
  ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1;
  for (let x=0;x<=width;x++){ ctx.beginPath(); ctx.moveTo(x*cell+0.5,0); ctx.lineTo(x*cell+0.5,canvas.height); ctx.stroke(); }
  for (let y=0;y<=height;y++){ ctx.beginPath(); ctx.moveTo(0,y*cell+0.5); ctx.lineTo(canvas.width,y*cell+0.5); ctx.stroke(); }
}

function makeTiles(n: number){
  const rowsPer = Math.ceil(height / n);
  tiles = []; for (let i=0;i<n;i++){ const y0=i*rowsPer, y1=Math.min(height, y0+rowsPer); if (y0<y1) tiles.push({y0,y1}); }
}

async function initPool(){
  // Decide mode
  useWorkers = !!(window.SharedArrayBuffer && (self as any).crossOriginIsolated);
  singleThread = !useWorkers;
  const bytes = width*height; // 1 byte per cell
  A = useWorkers? new SharedArrayBuffer(bytes) : new ArrayBuffer(bytes);
  B = useWorkers? new SharedArrayBuffer(bytes) : new ArrayBuffer(bytes);
  viewA = new Uint8Array(A); viewB = new Uint8Array(B); randomize(0.22);
  aIsInput = true;

  if (!useWorkers){
    modeLbl.textContent = 'CPU (single‑thread fallback)';
    workers = []; tiles = []; draw(viewA);
    return;
  }

  // Build worker pool
  const n = Math.max(1, Math.min(Number(threadsInp.value)||4, navigator.hardwareConcurrency || 4));
  makeTiles(n);
  readyCount = 0; workers.forEach(w=> w.terminate()); workers = [];
  const { birthMask, surviveMask } = bsToMasks(ruleInp.value || 'B3/S23');
  const useMoore = (topoSel.value==='Moore'); const wrapEdges = (edgeSel.value==='Wrap');

  for (let i=0;i<tiles.length;i++){
    const w = new Worker(new URL('../workers/step-worker.ts', import.meta.url), { type:'module' });
    w.onmessage = (ev)=>{ const d=ev.data; if (d?.type==='ready'){ readyCount++; if (readyCount===tiles.length) { modeLbl.textContent = `Workers (${tiles.length}× rows)`; draw(viewA); } }
                            else if (d?.type==='done'){ doneCount++; if (doneCount===tiles.length) afterStep(); } };
    const t = tiles[i];
    w.postMessage({ type:'init', width, height, y0:t.y0, y1:t.y1, useMoore, wrapEdges, birthMask, surviveMask, a:A as any, b:B as any });
    workers.push(w);
  }
}

let doneCount=0;
function stepOnce(){
  if (!useWorkers){
    // single-thread step
    const src = aIsInput? viewA : viewB; const dst = aIsInput? viewB : viewA;
    const { birthMask, surviveMask } = bsToMasks(ruleInp.value || 'B3/S23');
    const useMoore = (topoSel.value==='Moore'); const wrapEdges = (edgeSel.value==='Wrap');
    const idx=(x:number,y:number)=> y*width+x; const inb=(x:number,y:number)=> x>=0&&y>=0&&x<width&&y<height; const wrap=(v:number,m:number)=>{ let r=v%m; return r<0?r+m:r; };
    const get=(x:number,y:number)=> wrapEdges? src[idx(wrap(x,width),wrap(y,height))] : (inb(x,y)? src[idx(x,y)] : 0);
    if (useMoore){ for (let y=0;y<height;y++){ for(let x=0;x<width;x++){ let n=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ if(dx||dy) n+= get(x+dx,y+dy)&1; } const self=src[idx(x,y)]&1; const birth=(birthMask>>>n)&1; const surv=(surviveMask>>>n)&1; dst[idx(x,y)] = self? (surv?1:0) : (birth?1:0); } } }
    else { const offs=[[1,0],[-1,0],[0,1],[0,-1]] as const; for (let y=0;y<height;y++){ for(let x=0;x<width;x++){ let n=0; for (let i=0;i<4;i++){ const [dx,dy]=offs[i]; n += get(x+dx,y+dy)&1; } const self=src[idx(x,y)]&1; const birth=(birthMask>>>n)&1; const surv=(surviveMask>>>n)&1; dst[idx(x,y)] = self? (surviveMask>>>n)&1 : (birthMask>>>n)&1; } } }
    afterStep();
  } else {
    doneCount = 0;
    for (const w of workers) w.postMessage({ type:'step', aIsInput });
  }
}

function afterStep(){
  // swap A/B
  aIsInput = !aIsInput;
  draw(aIsInput? viewA : viewB);
}

function loop(){ if(!playing) return; const t0=performance.now(); stepOnce(); const dt=Math.max(0, ms-(performance.now()-t0)); setTimeout(loop, dt); }

// UI
playBtn!.addEventListener('click', ()=>{ playing=!playing; playBtn!.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); });
stepBtn!.addEventListener('click', ()=>{ if(!playing) stepOnce(); });
seedBtn!.addEventListener('click', ()=>{ randomize(0.22); draw(viewA); });
threadsInp.addEventListener('change', ()=> initPool());
ruleInp.addEventListener('change', ()=> initPool()); topoSel.addEventListener('change', ()=> initPool()); edgeSel.addEventListener('change', ()=> initPool());
speedInp.addEventListener('input', ()=>{ ms=Number(speedInp.value)||33; speedLbl.textContent=`${ms} ms/step`; });

initPool();
```

---

## index-3b.html (NEW — Stage 3B launcher)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 3B – Multi‑Threaded Workers</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input, select { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
    small { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 3B (Multi‑Threaded Workers + Shared Buffers)</h1>
    <small>Parallel CPU stepper • SAB double‑buffer • Auto fallback</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row"><strong>Mode:</strong> <span id="mode">—</span></div>
      <div class="row">
        <label>Rule</label>
        <input id="rule" value="B3/S23" />
      </div>
      <div class="row">
        <label>Topology</label>
        <select id="topo"><option>Moore</option><option>VonNeumann</option></select>
        <label>Edges</label>
        <select id="edges"><option>Clip</option><option>Wrap</option></select>
      </div>
      <div class="row">
        <label>Threads</label>
        <input id="threads" type="number" value="4" min="1" max="32" />
      </div>
      <div class="row">
        <label>Speed</label>
        <input id="speed" type="range" min="16" max="200" value="33" />
        <small id="speedLabel"></small>
      </div>
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
        <button id="seed">Reseed</button>
      </div>
      <div class="row"><small>ℹ︎ For multi‑threading, this page must be cross‑origin isolated (COOP/COEP). See README.</small></div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="768" height="576"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/workers-main.ts"></script>
</body>
</html>
```

---

## README addendum (3B)

````md
### 3B – Multi‑Threaded Workers + Shared Buffers

Run:
```bash
npm i
npm run dev:3b
````

If the header shows **CPU (single‑thread fallback)**, enable SAB by serving with COOP/COEP headers (already in `vite.config.ts`).

**How it works**

* Grid is stored as two `Uint8Array`s on `SharedArrayBuffer`: **A** (read), **B** (write).
* The main thread slices rows into N tiles and posts `step` to each worker.
* Workers compute their rows into the write buffer; main swaps A/B when all report `done`.
* Edge handling and neighborhoods match Stage 3A.

**Tips**

* Start with `threads = min( #cores , 8 )`.
* Increase grid size (e.g., 256×192) to see clear scaling.
* If you need Atomics barriers for ultra‑low jitter, we can extend to an `Atomics.wait/notify` model in 3B′.

```
```

