# MPL Playground â€” Stage 3S Patch (Multiâ€‘Session Vault + Crossâ€‘Session Search)

This patch introduces a **local Vault** to save/load multiple sessions and a **crossâ€‘session search** that reuses the 3R DSL across everything. No new deps; storage uses `localStorage` with a simple index (swap to IndexedDB later if needed).

**Highlights**

* Save current session (history + notes + annotations + bookmarks + watches + BPs) to a **Vault** with title, tags, and summary stats.
* Browse Vault (filter by text/tags, sort by recency/size), rename, duplicate, export JSON, delete.
* **Crossâ€‘Session Search** over *all* saved sessions; results are grouped by session and can deepâ€‘open that session at a hit index.
* When you open a result, the session loads into the existing Debugger and marks those indices on the scrubber.

---

## 1) `engine/debugger/vault.ts` (new)

```ts
// engine/debugger/vault.ts
// Stage 3S â€” Minimal local vault (localStorage-based)

import { SessionBundle } from "./sessionIO";

export interface VaultSessionMeta {
  id: string;
  title: string;
  tags: string[];
  createdAt: number;
  updatedAt: number;
  ticks: number;         // history length
  ruleCount: number;     // total rules fired
  noteCount: number;     // monadic notes count
  annotationCount: number;
  bookmarkCount: number;
  color?: string;        // optional accent
}

export interface VaultSession {
  meta: VaultSessionMeta;
  bundle: SessionBundle;
}

const INDEX_KEY = "mpl_vault_index_v1";
const SKEY = (id: string) => `mpl_vault_s_${id}`;

function now() { return Date.now(); }
function genId() { return `vs_${now()}_${Math.random().toString(36).slice(2, 8)}`; }

function readIndex(): VaultSessionMeta[] {
  try { return JSON.parse(localStorage.getItem(INDEX_KEY) || "[]"); } catch { return []; }
}
function writeIndex(idx: VaultSessionMeta[]) { localStorage.setItem(INDEX_KEY, JSON.stringify(idx)); }

function summarize(bundle: SessionBundle, title: string, tags: string[] = []): VaultSessionMeta {
  const ticks = bundle.history?.length || 0;
  let ruleCount = 0; for (const s of bundle.history || []) ruleCount += (s.rulesFired?.length || 0);
  const noteCount = (bundle.monadNotes || []).length;
  const annotationCount = (bundle.annotations || []).length;
  const bookmarkCount = (bundle.bookmarks || []).length;
  const id = genId();
  const t = now();
  return { id, title, tags, createdAt: t, updatedAt: t, ticks, ruleCount, noteCount, annotationCount, bookmarkCount };
}

export const Vault = {
  list(): VaultSessionMeta[] { return readIndex().sort((a,b) => b.updatedAt - a.updatedAt); },
  getMeta(id: string): VaultSessionMeta | undefined { return readIndex().find(m => m.id === id); },
  load(id: string): VaultSession | null {
    const meta = this.getMeta(id); if (!meta) return null;
    try { const json = localStorage.getItem(SKEY(id)); if (!json) return null; const bundle = JSON.parse(json) as SessionBundle; return { meta, bundle }; } catch { return null; }
  },
  saveNew(bundle: SessionBundle, title: string, tags: string[] = [], color?: string): VaultSessionMeta {
    const meta = summarize(bundle, title, tags); if (color) meta.color = color;
    const idx = readIndex(); idx.push(meta); writeIndex(idx);
    localStorage.setItem(SKEY(meta.id), JSON.stringify(bundle));
    return meta;
  },
  update(id: string, patch: Partial<VaultSessionMeta>): VaultSessionMeta | null {
    const idx = readIndex(); const i = idx.findIndex(m => m.id === id); if (i < 0) return null;
    const meta = { ...idx[i], ...patch, updatedAt: now() } as VaultSessionMeta; idx[i] = meta; writeIndex(idx); return meta;
  },
  duplicate(id: string): VaultSessionMeta | null {
    const vs = this.load(id); if (!vs) return null; const copy = structuredClone(vs.bundle);
    return this.saveNew(copy, `${vs.meta.title} (copy)`, [...vs.meta.tags]);
  },
  remove(id: string): boolean {
    const idx = readIndex(); const i = idx.findIndex(m => m.id === id); if (i < 0) return false;
    idx.splice(i, 1); writeIndex(idx); localStorage.removeItem(SKEY(id)); return true;
  },
  clearAll(): void { for (const m of readIndex()) localStorage.removeItem(SKEY(m.id)); writeIndex([]); },
};

// NOTE: localStorage is ~5MB. For large sessions, swap to IndexedDB: keep the index in localStorage, blobs in IDB.
```

---

## 2) `engine/debugger/crossSearch.ts` (new)

```ts
// engine/debugger/crossSearch.ts
// Stage 3S â€” Cross-session search using 3Râ€™s engine per session

import { VaultSessionMeta } from "./vault";
import { SessionBundle } from "./sessionIO";
import { parseSessionQuery, runSessionSearch, SearchHit } from "./sessionSearch";

export interface CrossHit extends SearchHit { sessionId: string; sessionTitle: string; }
export interface CrossResult { session: VaultSessionMeta; hits: CrossHit[]; indices: number[]; }

export function runCrossSessionSearch(sessions: { meta: VaultSessionMeta; bundle: SessionBundle }[], rawQuery: string): CrossResult[] {
  const q = parseSessionQuery(rawQuery);
  const out: CrossResult[] = [];
  for (const { meta, bundle } of sessions) {
    const space = {
      history: bundle.history || [],
      bookmarks: bundle.bookmarks || [],
      annotations: bundle.annotations || [],
      notes: bundle.monadNotes || [],
      watches: bundle.watches || [],
      breakpoints: bundle.breakpoints || [],
    } as any;
    const { hits, indices } = runSessionSearch(space, q);
    if (hits.length) out.push({ session: meta, hits: hits.map(h => ({ ...h, sessionId: meta.id, sessionTitle: meta.title })), indices });
  }
  // Sort sessions by most matches, then recency
  out.sort((a, b) => b.hits.length - a.hits.length || b.session.updatedAt - a.session.updatedAt);
  return out;
}
```

---

## 3) `playground/components/VaultPanel.tsx` (new)

```tsx
// playground/components/VaultPanel.tsx
// Stage 3S â€” Save/load/manage sessions in the Vault

import React, { useMemo, useState } from "react";
import { SessionBundle } from "../../engine/debugger/sessionIO";
import { Vault, VaultSessionMeta } from "../../engine/debugger/vault";

interface VaultPanelProps {
  currentBundle: SessionBundle;                     // what to save
  onOpenSession: (meta: VaultSessionMeta) => void;  // load into debugger
}

export const VaultPanel: React.FC<VaultPanelProps> = ({ currentBundle, onOpenSession }) => {
  const [title, setTitle] = useState("");
  const [tags, setTags] = useState("");
  const [filter, setFilter] = useState("");
  const [sortBy, setSortBy] = useState<"updated" | "title" | "size">("updated");
  const [items, setItems] = useState<VaultSessionMeta[]>(Vault.list());

  const refresh = () => setItems(Vault.list());
  const save = () => { const meta = Vault.saveNew(currentBundle, title.trim() || `Session @ ${new Date().toLocaleString()}`, parseTags(tags)); setTitle(""); setTags(""); setItems(Vault.list()); };

  const view = useMemo(() => {
    const needle = filter.trim().toLowerCase();
    const arr = items.filter(m => !needle || m.title.toLowerCase().includes(needle) || m.tags.some(t => t.toLowerCase().includes(needle)));
    switch (sortBy) {
      case "title": arr.sort((a,b) => a.title.localeCompare(b.title)); break;
      case "size": arr.sort((a,b) => (b.ticks - a.ticks) || (b.ruleCount - a.ruleCount)); break;
      default: arr.sort((a,b) => b.updatedAt - a.updatedAt);
    }
    return arr;
  }, [items, filter, sortBy]);

  return (
    <div className="mpl-vault">
      <div className="mpl-vault-save">
        <input placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} />
        <input placeholder="Tags (comma separated)" value={tags} onChange={e => setTags(e.target.value)} />
        <button className="mpl-btn" onClick={save}>ðŸ’¾ Save session</button>
        <button className="mpl-btn" onClick={refresh}>â†» Refresh</button>
        <input placeholder="Filter" value={filter} onChange={e => setFilter(e.target.value)} />
        <label>Sort <select value={sortBy} onChange={e => setSortBy(e.target.value as any)}>
          <option value="updated">recent</option><option value="title">title</option><option value="size">size</option>
        </select></label>
      </div>

      <div className="mpl-vault-list">
        {view.map(m => (
          <div key={m.id} className="mpl-vault-item">
            <div className="mpl-vault-meta">
              <div className="mpl-vault-title"><span className="mpl-dot" style={{ background: m.color || "#bae6fd" }} /> {m.title}</div>
              <div className="mpl-vault-sub">{new Date(m.updatedAt).toLocaleString()} â€¢ {m.ticks} ticks â€¢ {m.ruleCount} rules</div>
              <div className="mpl-vault-tags">{m.tags.map(t => <span key={t} className="mpl-chip">{t}</span>)}</div>
            </div>
            <div className="mpl-vault-actions">
              <button className="mpl-btn" onClick={() => onOpenSession(m)}>Open</button>
              <button className="mpl-btn" onClick={() => { const c = Vault.duplicate(m.id); if (c) refresh(); }}>Duplicate</button>
              <button className="mpl-btn" onClick={() => { const vs = Vault.load(m.id); if (!vs) return; const blob = new Blob([JSON.stringify(vs.bundle, null, 2)], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `${m.title.replace(/\W+/g,'_')}.json`; document.body.appendChild(a); a.click(); setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0); }}>Export</button>
              <button className="mpl-btn mpl-danger" onClick={() => { if (confirm(`Delete '${m.title}'?`)) { Vault.remove(m.id); refresh(); } }}>Delete</button>
            </div>
          </div>
        ))}
        {view.length === 0 && <div className="mpl-empty">No saved sessions</div>}
      </div>
    </div>
  );
};

function parseTags(s: string): string[] { return s.split(",").map(x => x.trim()).filter(Boolean); }
```

---

## 4) `playground/components/CrossSearchPanel.tsx` (new)

```tsx
// playground/components/CrossSearchPanel.tsx
// Stage 3S â€” Search across all vault sessions; deep-open a hit

import React, { useMemo, useState } from "react";
import { Vault, VaultSessionMeta } from "../../engine/debugger/vault";
import { runCrossSessionSearch, CrossResult } from "../../engine/debugger/crossSearch";

interface CrossSearchPanelProps {
  onOpenSessionAt: (meta: VaultSessionMeta, index: number, markIndices?: number[]) => void;
}

export const CrossSearchPanel: React.FC<CrossSearchPanelProps> = ({ onOpenSessionAt }) => {
  const [query, setQuery] = useState("text:\"\" kind:rule,annotation,bookmark,note");
  const [results, setResults] = useState<CrossResult[]>([]);
  const [loading, setLoading] = useState(false);

  const run = () => {
    setLoading(true);
    const metas = Vault.list();
    const sessions = metas.map(m => ({ meta: m, bundle: (Vault.load(m.id)?.bundle || { history: [] }) }));
    const out = runCrossSessionSearch(sessions as any, query);
    setResults(out);
    setLoading(false);
  };

  return (
    <div className="mpl-xsearch">
      <div className="mpl-x-bar">
        <input value={query} onChange={e => setQuery(e.target.value)} placeholder='e.g., text:"activation" monad:A tick:10..40 kind:rule,note' />
        <button className="mpl-btn" onClick={run}>Search all</button>
      </div>
      {loading && <div className="mpl-dim">Searchingâ€¦</div>}

      <div className="mpl-x-results">
        {results.map(res => (
          <div key={res.session.id} className="mpl-x-group">
            <div className="mpl-x-head">
              <span className="mpl-dot" style={{ background: res.session.color || "#fde68a" }} />
              <b>{res.session.title}</b>
              <span className="mpl-dim"> â€” {res.hits.length} hit{res.hits.length>1?"s":""}</span>
              <button className="mpl-btn" onClick={() => onOpenSessionAt(res.session, res.indices[0] ?? 0, res.indices)}>Open first</button>
            </div>
            <ul>
              {res.hits.slice(0, 20).map((h, i) => (
                <li key={i}>
                  <code className={`k-${h.kind}`}>{h.kind}</code> <span>{h.title}</span>
                  {h.detail ? <small className="mpl-dim"> â€” {h.detail}</small> : null}
                  <button className="mpl-btn slim" onClick={() => onOpenSessionAt(res.session, h.index, res.indices)}>Open @ {h.index}</button>
                </li>
              ))}
              {res.hits.length > 20 && <li className="mpl-dim">(+ {res.hits.length - 20} more)</li>}
            </ul>
          </div>
        ))}
        {results.length === 0 && <div className="mpl-empty">No results yet â€” run a search</div>}
      </div>
    </div>
  );
};
```

---

## 5) `playground/components/DebuggerPanel.tsx` (wire Vault + CrossSearch)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3S â€” Wire in VaultPanel and CrossSearchPanel

import React, { useEffect, useMemo, useState } from "react";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";
import { StateViewer } from "./StateViewer";
import { TimeScrubber } from "./TimeScrubber";
import { ImportExportPanel } from "./ImportExportPanel";
import { Bookmark } from "../../engine/debugger/bookmarks";
import { BookmarksPanel } from "./BookmarksPanel";
import { SessionBundle } from "../../engine/debugger/sessionIO";
import { AnnotationsPanel } from "./AnnotationsPanel";
import { MonadicNote, SessionAnnotation } from "../../engine/debugger/annotations";
import { NodeNotesPanel } from "./NodeNotesPanel";
import { RuleLogPanel } from "./RuleLogPanel";
import { RuleStatsPanel } from "./RuleStatsPanel";
import { Breakpoint } from "../../engine/debugger/breakpoints";
import { BreakpointsPanel } from "./BreakpointsPanel";
import { WatchesPanel } from "./WatchesPanel";
import { DiffPanel } from "./DiffPanel";
import { SessionSearchPanel } from "./SessionSearchPanel";
import { Watch } from "../../engine/debugger/watch";
import { Vault, VaultSessionMeta } from "../../engine/debugger/vault";
import { VaultPanel } from "./VaultPanel";
import { CrossSearchPanel } from "./CrossSearchPanel";

interface DebuggerPanelProps {
  snapshot?: ExecutionSnapshot;
  history?: ExecutionSnapshot[];
  onFocusMonad?: (id: string) => void;
}

export const DebuggerPanel: React.FC<DebuggerPanelProps> = ({ snapshot, history, onFocusMonad }) => {
  const [timeline, setTimeline] = useState<ExecutionSnapshot[]>(() => history ?? (snapshot ? [snapshot] : []));
  useEffect(() => { if (history && history.length) setTimeline(history); }, [history?.length]);
  useEffect(() => { if (!history && snapshot) setTimeline([snapshot]); }, [snapshot?.tick]);

  const [idx, setIdx] = useState(() => Math.max(0, timeline.length - 1));
  useEffect(() => { setIdx(Math.max(0, timeline.length - 1)); }, [timeline.length]);

  const [ghostIdx, setGhostIdx] = useState<number | null>(null);
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);
  const [annotations, setAnnotations] = useState<SessionAnnotation[]>([]);
  const [monadNotes, setMonadNotes] = useState<MonadicNote[]>([]);
  const [selectedMonadId, setSelectedMonadId] = useState<string | null>(null);
  const [ruleMarks, setRuleMarks] = useState<number[]>([]);
  const [bpMarks, setBpMarks] = useState<number[]>([]);
  const [heatStrip, setHeatStrip] = useState<number[] | undefined>(undefined);
  const [watches, setWatches] = useState<Watch[]>([]);
  const [searchMarks, setSearchMarks] = useState<number[]>([]);
  const [breakpoints, setBreakpoints] = useState<Breakpoint[]>([]);

  const current = useMemo<ExecutionSnapshot | undefined>(() => timeline[Math.max(0, Math.min(idx, timeline.length - 1))], [timeline, idx]);
  const ghost = useMemo<ExecutionSnapshot | undefined>(() => ghostIdx == null ? undefined : timeline[Math.max(0, Math.min(ghostIdx, timeline.length - 1))], [timeline, ghostIdx]);

  const bundleOf = (): SessionBundle => ({ history: timeline, bookmarks, annotations, monadNotes, watches: watches as any, breakpoints } as SessionBundle);

  const loadFromMeta = (m: VaultSessionMeta, jumpTo?: number, searchIdx?: number[]) => {
    const vs = Vault.load(m.id); if (!vs) return;
    const b = vs.bundle;
    setTimeline(b.history || []);
    setBookmarks(b.bookmarks || []);
    setAnnotations(b.annotations || []);
    setMonadNotes(b.monadNotes || []);
    setWatches((b as any).watches || []);
    setBreakpoints((b as any).breakpoints || []);
    const j = Math.max(0, Math.min(jumpTo ?? (b.history?.length ? b.history.length - 1 : 0), (b.history?.length||1)-1));
    setIdx(j);
    setGhostIdx(null);
    if (searchIdx && searchIdx.length) setSearchMarks(searchIdx); else setSearchMarks([]);
  };

  const onImport = (bundle: SessionBundle) => {
    setTimeline(bundle.history || []);
    setBookmarks(bundle.bookmarks || []);
    setAnnotations(bundle.annotations || []);
    setMonadNotes(bundle.monadNotes || []);
    setWatches((bundle as any).watches || []);
    setBreakpoints((bundle as any).breakpoints || []);
    setIdx(Math.max(0, (bundle.history?.length || 1) - 1));
    setGhostIdx(null);
  };

  return (
    <div className="mpl-debugger-panel">
      {/* Session I/O */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session I/O</header>
        <ImportExportPanel history={timeline} bookmarks={bookmarks} annotations={annotations} monadNotes={monadNotes} onImport={onImport} />
      </section>

      {/* Timeline */}
      {timeline.length > 0 && (
        <section className="mpl-section">
          <header className="mpl-section-h">Timeline</header>
          <TimeScrubber timeline={timeline} index={idx} onChangeIndex={setIdx} ghostIndex={ghostIdx} onChangeGhostIndex={setGhostIdx} bookmarks={bookmarks} annotations={annotations} ruleMarks={ruleMarks} heatValues={heatStrip} bpMarks={bpMarks} searchMarks={searchMarks} />
        </section>
      )}

      {/* Vault */}
      <section className="mpl-section">
        <header className="mpl-section-h">Vault</header>
        <VaultPanel currentBundle={bundleOf()} onOpenSession={(m) => loadFromMeta(m)} />
      </section>

      {/* Cross-Session Search */}
      <section className="mpl-section">
        <header className="mpl-section-h">Cross-Session Search</header>
        <CrossSearchPanel onOpenSessionAt={(m,i,marks) => loadFromMeta(m, i, marks)} />
      </section>

      {/* Session Search (in-session marks) */}
      <section className="mpl-section">
        <header className="mpl-section-h">Session Search</header>
        <SessionSearchPanel history={timeline} bookmarks={bookmarks} annotations={annotations} notes={monadNotes} watches={watches} breakpoints={breakpoints} onGoToIndex={setIdx} onMarksChange={setSearchMarks} />
      </section>

      {/* Diffs + Watches */}
      <section className="mpl-section">
        <header className="mpl-section-h">State Diffs</header>
        <DiffPanel ghost={ghost} current={current} indexA={ghostIdx} indexB={idx} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Watches</header>
        <WatchesPanel history={timeline} indexB={idx} indexA={ghostIdx} watches={watches} onChange={setWatches} />
      </section>

      {/* Rule Stats + Rule Log */}
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Stats</header>
        <RuleStatsPanel history={timeline} onSelectRuleForHeat={() => {}} onSetHeatWindow={() => {}} onSetHeatNormalize={() => {}} onSetHeatStrip={setHeatStrip} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Rule Log</header>
        <RuleLogPanel history={timeline} onGoToIndex={setIdx} onPinGhost={setGhostIdx} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} onMarksChange={setRuleMarks} />
      </section>

      {/* Notes/Annotations/Bookmarks */}
      <section className="mpl-section">
        <header className="mpl-section-h">Node Notes</header>
        <NodeNotesPanel currentIndex={idx} currentTick={current?.tick ?? idx} selectedMonadId={selectedMonadId ?? undefined} notes={monadNotes} onChange={setMonadNotes} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Annotations</header>
        <AnnotationsPanel currentIndex={idx} currentTick={current?.tick ?? idx} maxIndex={Math.max(0, timeline.length - 1)} annotations={annotations} onChange={setAnnotations} onGoToIndex={setIdx} />
      </section>
      <section className="mpl-section">
        <header className="mpl-section-h">Bookmarks</header>
        <BookmarksPanel currentIndex={idx} currentTick={current?.tick ?? idx} bookmarks={bookmarks} onChange={setBookmarks} onGoToIndex={setIdx} />
      </section>

      {/* State */}
      <section className="mpl-section">
        <header className="mpl-section-h">State</header>
        {current ? (
          <StateViewer history={timeline} index={idx} snapshot={current} ghostSnapshot={ghost} monadNotes={monadNotes.filter(n => n.index === idx)} selectedMonadId={selectedMonadId} onSelectMonad={(id) => { setSelectedMonadId(id); onFocusMonad?.(id); }} />
        ) : (
          <div className="mpl-empty">No snapshot available</div>
        )}
      </section>
    </div>
  );
};
```

---

## 6) `playground/styles/debugger.css` (additions)

```css
/* Stage 3S â€” Vault & Cross-Session Search */
.mpl-vault-save { display: grid; grid-template-columns: 1fr 1fr auto auto 1fr auto; gap: 8px; align-items: center; margin-bottom: 8px; }
.mpl-vault-list { display: grid; gap: 8px; }
.mpl-vault-item { border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; background: #fff; display: grid; grid-template-columns: 1fr auto; gap: 8px; }
.mpl-vault-title { font-weight: 700; display: flex; align-items: center; gap: 6px; }
.mpl-vault-sub { font-size: 12px; color: #6b7280; }
.mpl-vault-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 4px; }
.mpl-vault-actions { display: flex; gap: 8px; align-items: center; }

.mpl-x-bar { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin-bottom: 8px; }
.mpl-x-results { display: grid; gap: 8px; }
.mpl-x-group { border: 1px solid #e5e7eb; border-radius: 10px; background: #fff; padding: 8px; }
.mpl-x-head { display: flex; gap: 8px; align-items: center; margin-bottom: 6px; }
.mpl-btn.slim { padding: 2px 6px; }
```

---

## 7) Example â€” `playground/pages/DebugExample3S.tsx`

```tsx
// playground/pages/DebugExample3S.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3S() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B", sourceId: "B", targetId: "C" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" }, { ruleId: "R2", at: 2, monadId: "A", sourceId: "A", targetId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3S â€” Vault + Cross-Session Search</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 8) Notes

* **Persistence:** This is intentionally simple. If you need large sessions, replace the storage layer with IndexedDB (keep the same `Vault` API and store bundles as blobs).
* **Bundle schema:** We persist exactly what Import/Export already uses (`SessionBundle`). Add fields like `watches`/`breakpoints` to your bundle type if not present yet.
* **Security:** Vault data is local to the browser profile. Thereâ€™s no network syncing in this patch.
* **Deep-open marks:** When opening a cross-session result, we pass that sessionâ€™s `indices` so the scrubber marks all matches immediately.

---

## 9) Changelog â€” Stage 3S

* New: `vault.ts` (local session storage), `crossSearch.ts` (search across sessions)
* New UI: `VaultPanel.tsx`, `CrossSearchPanel.tsx`
* Updated: `DebuggerPanel.tsx` (wire vault + cross-session search)
* CSS: vault list & cross-session layout

```
```
