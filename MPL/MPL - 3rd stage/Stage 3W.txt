# MPL Playground — Stage 3W Patch (Scenario Matrices + Param Runs + Flaky Quarantine)

This patch layers **parameterized scenarios** and **matrix runs** on top of 3V’s Scenario Runner, adds **flaky detection with automatic retries**, and introduces a **Quarantine** list so unstable cases don’t block green builds (but are still tracked). No new deps.

**Highlights**

* Define **Scenario Templates** with parameters; expand to many scenarios via **full‑factorial** or **sampled** matrices (seeded RNG)
* **Retries & Flaky**: on failure, auto‑retry (configurable). If a later attempt passes → mark **flaky**
* **Quarantine**: persist flaky signatures; default runs skip quarantined cases (toggle on to include)
* Enhanced exports: JSON + **JUnit XML** note flaky/quarantined in `system-out`

---

## 1) `engine/debugger/paramMatrix.ts` (new)

```ts
// engine/debugger/paramMatrix.ts
// Stage 3W — Parameter specs, matrix expansion, seeded sampling, and templating

export type ParamSpec =
  | { key: string; kind: 'enum'; values: (string|number|boolean)[] }
  | { key: string; kind: 'range'; start: number; end: number; step?: number }
  | { key: string; kind: 'bool' }
  | { key: string; kind: 'set'; values: string[] };

export interface MatrixConfig {
  strategy: 'full' | 'sample';
  sampleCount?: number;     // used for 'sample'
  seed?: number;            // deterministic sampling
}

export type Assignment = Record<string, string | number | boolean>;

export function enumerateParams(specs: ParamSpec[]): Assignment[] {
  const lists: { key: string; vals: (string|number|boolean)[] }[] = specs.map(s => {
    if (s.kind === 'enum' || s.kind === 'set') return { key: s.key, vals: [...s.values] };
    if (s.kind === 'bool') return { key: s.key, vals: [true, false] };
    const step = Math.max(1e-9, s.step ?? 1);
    const vals: number[] = []; for (let x = s.start; x <= s.end + 1e-12; x += step) vals.push(Number(x.toFixed(12)));
    return { key: s.key, vals };
  });
  // full factorial
  const out: Assignment[] = [];
  function rec(i: number, cur: Assignment) {
    if (i === lists.length) { out.push({ ...cur }); return; }
    const { key, vals } = lists[i];
    for (const v of vals) { cur[key] = v; rec(i+1, cur); }
  }
  rec(0, {});
  return out;
}

export function expandMatrix(specs: ParamSpec[], cfg: MatrixConfig): Assignment[] {
  const all = enumerateParams(specs);
  if (cfg.strategy === 'sample') {
    const n = Math.min(all.length, Math.max(1, Math.floor(cfg.sampleCount ?? all.length)));
    const rng = mulberry32(cfg.seed ?? 1);
    const arr = [...all];
    // Fisher-Yates shuffle then take first n
    for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(rng() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; }
    return arr.slice(0, n);
  }
  return all;
}

function mulberry32(a: number){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ (t >>> 15), t | 1); t ^= t + Math.imul(t ^ (t >>> 7), t | 61); return ((t ^ (t >>> 14)) >>> 0) / 4294967296; } }

// --- Deep template interpolation: replaces ${var} in strings across payloads
export function applyTemplate<T>(data: T, vars: Assignment): T {
  const rep = (s: string) => s.replace(/\$\{([\w.-]+)\}/g, (_m, k) => String(vars[k] ?? ''));
  const walk = (x: any): any => {
    if (typeof x === 'string') return rep(x);
    if (Array.isArray(x)) return x.map(walk);
    if (x && typeof x === 'object') { const o: any = {}; for (const [k,v] of Object.entries(x)) o[k] = walk(v); return o; }
    return x;
  };
  return walk(data);
}
```

---

## 2) `engine/debugger/quarantine.ts` (new)

```ts
// engine/debugger/quarantine.ts
// Stage 3W — Persist flaky signatures and opt-in include

const KEY = 'mpl_quarantine_v1';
export interface Quarantined { sig: string; label: string; firstSeen: number; lastSeen: number; count: number }

function load(): Quarantined[] { try { return JSON.parse(localStorage.getItem(KEY) || '[]'); } catch { return []; } }
function save(arr: Quarantined[]) { localStorage.setItem(KEY, JSON.stringify(arr)); }

export const Quarantine = {
  list(): Quarantined[] { return load().sort((a,b) => b.lastSeen - a.lastSeen); },
  add(sig: string, label: string){ const arr = load(); const i = arr.findIndex(x => x.sig === sig); const t = Date.now(); if (i>=0){ arr[i].lastSeen = t; arr[i].count++; } else arr.push({ sig, label, firstSeen: t, lastSeen: t, count: 1 }); save(arr); },
  remove(sig: string){ save(load().filter(x => x.sig !== sig)); },
  has(sig: string){ return load().some(x => x.sig === sig); }
};
```

---

## 3) `engine/debugger/scenarioRunner.ts` (updated)

```ts
// ADDITIONS for Stage 3W — templates, retries, flaky detection, quarantine

import { ParamSpec, MatrixConfig, expandMatrix, applyTemplate, Assignment } from './paramMatrix';
import { Quarantine } from './quarantine';

export interface ScenarioTemplate { id: string; label: string; tags?: string[]; params: ParamSpec[]; matrix: MatrixConfig; steps: Step[]; enabled: boolean }

export interface RunConfig { retries?: number; failFast?: boolean; includeQuarantined?: boolean; tagAnyOf?: string[]; seed?: number }

export interface ScenarioResultEx extends ScenarioResult { attempts: number; flaky?: boolean; quarantined?: boolean; signature: string; assignment?: Assignment }
export interface SuiteResultEx extends SuiteResult { results: ScenarioResultEx[]; quarantinedCount: number; flakyCount: number }

// Compute a stable signature for quarantine/flaky tracking (label + steps + assignment)
export function signatureOfScenario(s: Scenario, assign?: Assignment): string {
  const payload = JSON.stringify({ label: s.label, steps: s.steps, assign: assign || null });
  return hashString(payload);
}
function hashString(s: string){ let h = 2166136261 >>> 0; for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); } return ('00000000'+(h>>>0).toString(16)).slice(-8); }

export function expandTemplate(t: ScenarioTemplate): { scenario: Scenario; assignment: Assignment; signature: string }[] {
  const combos = expandMatrix(t.params, t.matrix);
  return combos.map(assign => {
    const scenario: Scenario = { id: `${t.id}__${Object.entries(assign).map(([k,v])=>`${k}=${v}`).join(',')}`, label: `${t.label} [${Object.entries(assign).map(([k,v])=>`${k}=${v}`).join(', ')}]`, steps: applyTemplate(t.steps, assign) as any, enabled: t.enabled };
    const signature = signatureOfScenario(scenario, assign);
    return { scenario, assignment: assign, signature };
  });
}

export async function runSuiteWithRetries(env: RunnerEnv, scenarios: Scenario[], cfg: RunConfig = {}): Promise<SuiteResultEx> {
  const { retries = 1, failFast = false, includeQuarantined = false, tagAnyOf } = cfg;
  const t0 = performance.now();
  const out: ScenarioResultEx[] = [];

  const list = scenarios.filter(s => s.enabled !== false && (!tagAnyOf || (s as any).tags?.some((t:string)=>tagAnyOf.includes(t))));

  for (const s of list) {
    const sig = signatureOfScenario(s);
    const quarantined = !includeQuarantined && Quarantine.has(sig);
    if (quarantined) { out.push({ ...(await runScenario(env, s)), ok: true, attempts: 0, quarantined: true, signature: sig }); continue; }

    let attempts = 0; let last: ScenarioResult | null = null; let passed = false;
    const maxAttempts = Math.max(1, retries + 1);
    for (; attempts < maxAttempts; attempts++) {
      last = await runScenario(env, s);
      passed = last.ok;
      if (passed) break;
    }
    const flaky = !passed && attempts > 1 ? false : (!last?.ok && attempts>1 ? false : (!last?.ok ? false : (attempts>1)));
    const resEx: ScenarioResultEx = { ...(last as ScenarioResult), attempts, flaky: passed && attempts>1, quarantined: false, signature: sig };
    out.push(resEx);

    if (!resEx.ok && resEx.flaky) {
      // mark flaky (optional quarantine policy is manual)
    }
    if (!resEx.ok && failFast) break;
  }

  const failed = out.filter(x => !x.ok && !x.quarantined).length;
  const passedCount = out.filter(x => x.ok).length;
  const flakyCount = out.filter(x => x.flaky).length;
  const quarantinedCount = out.filter(x => x.quarantined).length;

  return { results: out, ok: failed === 0, durationMs: performance.now() - t0, total: out.length, failed, passed: passedCount, flakyCount, quarantinedCount } as SuiteResultEx;
}
```

> Note: `flaky` is defined as *eventually passed within retry budget*. Quarantined cases are treated as **skipped/passed** for totals but counted in `quarantinedCount`.

---

## 4) `engine/debugger/ciExport.ts` (updated)

```ts
// Stage 3W — annotate flaky/quarantined in JUnit system-out
import { SuiteResultEx, ScenarioResultEx } from './scenarioRunner';

export function toJUnitXMLEx(suite: SuiteResultEx): string {
  const tests = suite.total; const failures = suite.failed; const time = (suite.durationMs/1000).toFixed(3);
  const cases = suite.results.map(r => caseXML(r)).join('\n');
  return `<?xml version="1.0" encoding="UTF-8"?>\n<testsuite name="MPL Scenarios" tests="${tests}" failures="${failures}" time="${time}">\n${cases}\n</testsuite>`;
}
function caseXML(r: ScenarioResultEx): string {
  const name = esc(r.label); const time = (r.durationMs/1000).toFixed(3);
  const meta = [`attempts=${r.attempts}`, `flaky=${!!r.flaky}`, `quarantined=${!!r.quarantined}`, `sig=${r.signature}`].join(' ');
  if (r.quarantined) return `<testcase name="${name}" time="${time}"><system-out>${esc(meta)}</system-out></testcase>`;
  if (r.ok) return `<testcase name="${name}" time="${time}"><system-out>${esc(meta)}</system-out></testcase>`;
  const msgs = r.steps.filter(s => s.kind==='assert' && s.assertions && s.assertions[0] && !s.assertions[0].ok)
    .map(s => s.assertions![0])
    .map(a => `${a.label || a.kind} @ ${a.index ?? ''} — ${a.message || 'failed'} (expected=${JSON.stringify(a.expected)} actual=${JSON.stringify(a.actual)})`).join('\n');
  return `<testcase name="${name}" time="${time}"><failure message="${esc(msgs)}"/><system-out>${esc(meta)}</system-out></testcase>`;
}
function esc(s: any){ return String(s).replace(/[&<>"\n]+/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\n':'&#10;'} as any)[m]); }
```

---

## 5) `playground/components/ScenarioMatrixPanel.tsx` (new)

```tsx
// playground/components/ScenarioMatrixPanel.tsx
// Stage 3W — Build parameterized templates, expand, run with retries & quarantine

import React, { useMemo, useState } from 'react';
import { ScenarioTemplate } from '../../engine/debugger/scenarioRunner';
import { ParamSpec, MatrixConfig, expandMatrix } from '../../engine/debugger/paramMatrix';
import { expandTemplate, runSuiteWithRetries, signatureOfScenario } from '../../engine/debugger/scenarioRunner';
import { Quarantine } from '../../engine/debugger/quarantine';
import { toJUnitXMLEx } from '../../engine/debugger/ciExport';

interface ScenarioMatrixPanelProps {
  runnerEnv: any; // RunnerEnv from 3V wiring
}

export const ScenarioMatrixPanel: React.FC<ScenarioMatrixPanelProps> = ({ runnerEnv }) => {
  const [templates, setTemplates] = useState<ScenarioTemplate[]>([]);
  const [retries, setRetries] = useState(1);
  const [failFast, setFailFast] = useState(false);
  const [includeQ, setIncludeQ] = useState(false);
  const [tagFilter, setTagFilter] = useState('');
  const [seed, setSeed] = useState(42);
  const [lastXML, setLastXML] = useState('');
  const [lastJSON, setLastJSON] = useState('');

  const addTemplate = () => setTemplates(t => [...t, { id: `tpl_${Date.now()}`, label: `Template #${t.length+1}`, params: [], matrix: { strategy: 'full' }, steps: [], enabled: true }]);
  const rmTemplate = (id: string) => setTemplates(t => t.filter(x => x.id !== id));
  const patchTemplate = (id: string, p: Partial<ScenarioTemplate>) => setTemplates(t => t.map(x => x.id===id?{...x,...p}:x));

  const run = async () => {
    const expanded = templates.flatMap(t => expandTemplate({ ...t, matrix: { ...t.matrix, seed } } as any));
    const scenarios = expanded.map(x => x.scenario);
    const cfg = { retries, failFast, includeQuarantined: includeQ, tagAnyOf: tagFilter ? tagFilter.split(',').map(s=>s.trim()).filter(Boolean) : undefined, seed } as any;
    const res = await runSuiteWithRetries(runnerEnv, scenarios, cfg);
    setLastJSON(JSON.stringify(res, null, 2));
    setLastXML(toJUnitXMLEx(res));
  };

  return (
    <div className="mpl-matrix">
      <div className="mpl-matrix-bar">
        <button className="mpl-btn" onClick={addTemplate}>➕ New Template</button>
        <label>Retries <input type="number" value={retries} min={0} onChange={e => setRetries(Math.max(0, parseInt(e.target.value)||0))} style={{ width: 70 }} /></label>
        <label className="mpl-check"><input type="checkbox" checked={failFast} onChange={e => setFailFast(e.target.checked)} /> Fail fast</label>
        <label className="mpl-check"><input type="checkbox" checked={includeQ} onChange={e => setIncludeQ(e.target.checked)} /> Include quarantined</label>
        <label>Seed <input type="number" value={seed} onChange={e => setSeed(parseInt(e.target.value)||0)} style={{ width: 90 }} /></label>
        <input placeholder="Tag filter (comma any-of)" value={tagFilter} onChange={e => setTagFilter(e.target.value)} />
        <button className="mpl-btn" onClick={run}>▶ Run Matrix</button>
      </div>

      <div className="mpl-templates">
        {templates.map(t => (
          <div key={t.id} className="mpl-card">
            <div className="mpl-card-head">
              <input className="mpl-title" value={t.label} onChange={e => patchTemplate(t.id, { label: e.target.value })} />
              <label className="mpl-check"><input type="checkbox" checked={t.enabled !== false} onChange={e => patchTemplate(t.id, { enabled: e.target.checked })} /> enabled</label>
              <button className="mpl-btn mpl-danger" onClick={() => rmTemplate(t.id)}>✕ Delete</button>
            </div>

            <div className="mpl-grid-2">
              {/* Params */}
              <div>
                <div className="mpl-sub">Parameters</div>
                <ParamEditor value={t.params} onChange={p => patchTemplate(t.id, { params: p })} />
                <div className="mpl-row">
                  <label>Strategy <select value={t.matrix.strategy} onChange={e => patchTemplate(t.id, { matrix: { ...t.matrix, strategy: e.target.value as any } })}>
                    <option value="full">full</option>
                    <option value="sample">sample</option>
                  </select></label>
                  {t.matrix.strategy==='sample' && (
                    <label>Samples <input type="number" value={t.matrix.sampleCount ?? 8} onChange={e => patchTemplate(t.id, { matrix: { ...t.matrix, sampleCount: parseInt(e.target.value)||1 } })} style={{ width: 80 }} /></label>
                  )}
                </div>
                <div className="mpl-dim">Preview: {expandMatrix(t.params, { ...t.matrix, seed }).length} combos</div>
              </div>

              {/* Steps with templating */}
              <div>
                <div className="mpl-sub">Steps (JSON; `${'{var}'}` placeholders allowed)</div>
                <textarea className="mpl-code" value={JSON.stringify(t.steps, null, 2)} onChange={e => { try { const v = JSON.parse(e.target.value); patchTemplate(t.id, { steps: v }); } catch {} }} />
                <div className="mpl-small mpl-dim">Tip: use `${'{alpha}'}`, `${'{size}'}`, etc. in step payloads; they expand per assignment.</div>
              </div>
            </div>

            {/* Quarantine helpers for this template */}
            <TemplateQuarantinePreview template={t} />
          </div>
        ))}
        {templates.length === 0 && <div className="mpl-empty">No templates — add one and define params + steps</div>}
      </div>

      {lastJSON && (
        <div className="mpl-results">
          <div className="mpl-row">
            <button className="mpl-btn" onClick={() => download('mpl-matrix.json', lastJSON, 'application/json')}>⬇ JSON</button>
            <button className="mpl-btn" onClick={() => download('mpl-matrix.junit.xml', lastXML, 'application/xml')}>⬇ JUnit XML</button>
          </div>
          <details open>
            <summary>JSON results</summary>
            <pre className="mpl-pre">{lastJSON}</pre>
          </details>
        </div>
      )}
    </div>
  );
};

const ParamEditor: React.FC<{ value: ParamSpec[]; onChange: (p: ParamSpec[]) => void }> = ({ value, onChange }) => {
  const add = () => onChange([ ...value, { key: 'alpha', kind: 'enum', values: [0.1, 0.5, 1] } as ParamSpec ]);
  const rm = (i: number) => onChange(value.filter((_,k)=>k!==i));
  const patch = (i: number, p: Partial<ParamSpec>) => onChange(value.map((x,k)=>k===i?{...x, ...p} as any:x));
  return (
    <div className="mpl-params">
      {value.map((p, i) => (
        <div key={i} className="mpl-row">
          <input value={p.key} onChange={e => patch(i, { key: e.target.value } as any)} placeholder="key" />
          <select value={p.kind} onChange={e => patch(i, { kind: e.target.value as any } as any)}>
            <option value="enum">enum</option>
            <option value="range">range</option>
            <option value="bool">bool</option>
            <option value="set">set</option>
          </select>
          {p.kind==='enum' || p.kind==='set' ? (
            <input value={(p as any).values.join(', ')} onChange={e => patch(i, { values: e.target.value.split(',').map(s=>s.trim()).filter(Boolean) } as any)} placeholder="a, b, c" />
          ) : p.kind==='range' ? (
            <>
              <input type="number" value={(p as any).start} onChange={e => patch(i, { start: parseFloat(e.target.value)||0 } as any)} placeholder="start" />
              <input type="number" value={(p as any).end} onChange={e => patch(i, { end: parseFloat(e.target.value)||0 } as any)} placeholder="end" />
              <input type="number" value={(p as any).step ?? 1} onChange={e => patch(i, { step: parseFloat(e.target.value)||1 } as any)} placeholder="step" />
            </>
          ) : (
            <span className="mpl-dim">boolean</span>
          )}
          <button className="mpl-btn slim mpl-danger" onClick={() => rm(i)}>✕</button>
        </div>
      ))}
      <button className="mpl-btn" onClick={add}>+ Param</button>
    </div>
  );
};

const TemplateQuarantinePreview: React.FC<{ template: ScenarioTemplate }> = ({ template }) => {
  const expanded = useMemo(() => expandTemplate(template), [template.id, JSON.stringify(template.params), JSON.stringify(template.steps), JSON.stringify(template.matrix)]);
  const rows = expanded.map(e => ({ label: e.scenario.label, sig: e.signature, quarantined: Quarantine.has(e.signature) }));
  return (
    <details className="mpl-qprev">
      <summary>Quarantine preview ({rows.filter(r=>r.quarantined).length}/{rows.length} quarantined)</summary>
      <table className="mpl-table">
        <thead><tr><th>Scenario</th><th>Signature</th><th>Quarantined</th><th></th></tr></thead>
        <tbody>
          {rows.map((r, i) => (
            <tr key={i}>
              <td>{r.label}</td>
              <td className="mpl-mono">{r.sig}</td>
              <td>{r.quarantined? 'yes':'no'}</td>
              <td>
                {r.quarantined ? (
                  <button className="mpl-btn" onClick={() => { Quarantine.remove(r.sig); (window as any).dispatchEvent(new Event('mpl-q-refresh')); }}>Unquarantine</button>
                ) : (
                  <button className="mpl-btn" onClick={() => { Quarantine.add(r.sig, r.label); (window as any).dispatchEvent(new Event('mpl-q-refresh')); }}>Quarantine</button>
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </details>
  );
};

function download(name: string, content: string, type='text/plain'){
  const blob = new Blob([content], { type }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = name; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}
```

---

## 6) `playground/components/ScenarioRunnerPanel.tsx` (augment)

```tsx
// Stage 3W — add export JUnit (extended) and quarantine controls to 3V panel

// ...inside ScenarioRunnerPanel component...
// add under top bar
<button className="mpl-btn" onClick={() => {
  try { const obj = JSON.parse(lastJSON); const xml = (window as any).__MPL_TO_JUNIT_EX?.(obj) || lastJUnit; download('mpl-results.junit.xml', xml, 'application/xml'); } catch { /* fallback already present */ }
}}>⬇ JUnit (extended)</button>

// at module scope, expose helper used above
defineOnce('__MPL_TO_JUNIT_EX', (suiteJson: any) => {
  try { const { toJUnitXMLEx } = require('../../engine/debugger/ciExport'); return toJUnitXMLEx(suiteJson); } catch { return null; }
});

function defineOnce(key: string, fn: any){ (window as any)[key] = (window as any)[key] || fn; }
```

> If your bundler lacks `require`, replace with a static import and bind the function directly.

---

## 7) `playground/components/DebuggerPanel.tsx` (wire Scenario Matrix)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3W — Wire ScenarioMatrixPanel under Scenarios

import { ScenarioMatrixPanel } from './ScenarioMatrixPanel';
import { runSuiteWithRetries } from '../../engine/debugger/scenarioRunner';

// Build runnerEnv (reuse from 3V wiring). Then add section:
<section className="mpl-section">
  <header className="mpl-section-h">Scenario Matrix</header>
  <ScenarioMatrixPanel runnerEnv={runnerState as any} />
</section>
```

---

## 8) `playground/styles/debugger.css` (additions)

```css
/* Stage 3W — Matrix + Quarantine styles */
.mpl-matrix { display: grid; gap: 10px; }
.mpl-matrix-bar { display: grid; grid-template-columns: auto auto auto auto auto 1fr auto; gap: 8px; align-items: center; }
.mpl-templates { display: grid; gap: 10px; }
.mpl-card { border: 1px solid #e5e7eb; border-radius: 10px; background: #fff; padding: 10px; }
.mpl-card-head { display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; margin-bottom: 8px; }
.mpl-title { font-weight: 700; }
.mpl-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.mpl-code { width: 100%; min-height: 140px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
.mpl-params .mpl-row input { width: auto; }
.mpl-qprev summary { cursor: pointer; }
.mpl-pre { white-space: pre-wrap; overflow-x: auto; background: #0b1021; color: #c7d2fe; padding: 8px; border-radius: 8px; }
```

---

## 9) Example — `playground/pages/DebugExample3W.tsx`

```tsx
// playground/pages/DebugExample3W.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3W() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3W — Scenario Matrices + Param Runs + Flaky Quarantine</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 10) Quick template starter

```json
{
  "id": "tpl_linearscan",
  "label": "Linear scan window",
  "params": [
    { "key": "alpha", "kind": "enum", "values": [0.1, 0.5, 0.9] },
    { "key": "window", "kind": "range", "start": 2, "end": 6, "step": 2 },
    { "key": "use_cache", "kind": "bool" }
  ],
  "matrix": { "strategy": "sample", "sampleCount": 5 },
  "steps": [
    { "kind": "openSession", "title": "Baseline run" },
    { "kind": "setIndex", "index": 0 },
    { "kind": "assert", "assertion": { "kind": "ruleCount", "ruleId": "R1", "op": ">=", "value": 1 } },
    { "kind": "assert", "assertion": { "kind": "value", "index": 0, "path": "monads.length", "op": ">=", "value": "${window}" } }
  ]
}
```

---

## 11) Notes

* **Sampling**: Pairwise/orthogonal arrays are out of scope for this patch — we provide full factorial and seeded random sampling.
* **Signatures**: Tied to label + steps + assignment. Rename or step changes yield a new signature.
* **Policy**: This patch **does not auto-quarantine** flakies; it exposes buttons and previews so you can curate.
* **Interop**: 3V panels remain; 3W adds a separate Matrix panel so ad‑hoc and matrix runs can coexist.

---

## 12) Changelog — Stage 3W

* New engine: `paramMatrix.ts`, `quarantine.ts`
* Updated: `scenarioRunner.ts` (templates, retries, signatures, quarantine, extended results)
* Updated: `ciExport.ts` (extended JUnit XML with flaky/quarantined)
* New UI: `ScenarioMatrixPanel.tsx` (templates, matrix, quarantine helpers)
* Updated UI: `ScenarioRunnerPanel.tsx` (extended export button)
* Updated: `DebuggerPanel.tsx` wiring
* CSS: matrix & quarantine styles

```
```
