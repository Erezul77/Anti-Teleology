# MPL Playground — Stage 3V Patch (Scenario Runners + Assertions + CI Exports)

This patch adds **Scenario Runners** (scriptable test flows), a tiny **assertions DSL** against timeline state & rule activity, and **CI‑friendly exports** (JUnit XML + JSON). It piggybacks on the Vault, Macros, and ActionsContext from 3S/3U.

**Highlights**

* Define **Scenarios**: open a vault session, jump/step, run macros, then assert on state & rules
* Run single or batch **Suites**, see pass/fail counts, durations, and failure diffs
* Export results as **JUnit XML** (for CI dashboards) or compact **JSON**
* No new deps; entirely browser‑local

> ℹ️ Minor fix carried in: a typo from 3R in `sessionSearch.ts` is corrected (`want("watch")`).

---

## 1) `engine/debugger/assertions.ts` (new)

```ts
// engine/debugger/assertions.ts
// Stage 3V — Tiny assertions DSL + evaluator

import { ExecutionSnapshot } from "./graphTypes";

export type NumOp = '=='|'!='|'>'|'<'|'>='|'<=';
export type GenOp = NumOp | 'contains' | 'notContains' | 'exists' | 'notExists';

export interface BaseAsrt { id?: string; label?: string; }

export interface ValueAsrt extends BaseAsrt {
  kind: 'value';
  index: number | 'current';                 // snapshot index
  path: string;                              // e.g. "monads[0].id" or "rulesFired.length"
  op: GenOp;
  value?: any;                               // expected (if applicable)
}

export interface RuleCountAsrt extends BaseAsrt {
  kind: 'ruleCount';
  ruleId: string;                            // rule to count
  range?: { start?: number; end?: number };  // inclusive range
  op: NumOp;
  value: number;
}

export interface MonadAsrt extends BaseAsrt {
  kind: 'monadExists';
  index: number | 'current';
  monadId: string;
  op?: 'exists'|'notExists';
}

export interface EdgeAsrt extends BaseAsrt {
  kind: 'edgeExists';
  index: number | 'current';
  source: string; target: string;            // checks neighbors source→target
  op?: 'exists'|'notExists';
}

export type Assertion = ValueAsrt | RuleCountAsrt | MonadAsrt | EdgeAsrt;

export interface AsrtResult {
  ok: boolean; kind: Assertion['kind']; label?: string;
  index?: number; path?: string; op?: string; expected?: any; actual?: any;
  message?: string;
}

export function evalAssertion(history: ExecutionSnapshot[], current: number, a: Assertion): AsrtResult {
  const idx = a.kind === 'ruleCount' ? undefined : (a as any).index === 'current' ? current : (a as any).index;
  const fail = (msg: string, extra: Partial<AsrtResult> = {}) => ({ ok: false, kind: a.kind, label: a.label, index: idx, message: msg, ...extra });
  const ok = (extra: Partial<AsrtResult> = {}) => ({ ok: true, kind: a.kind, label: a.label, index: idx, ...extra });

  if (a.kind === 'value') {
    const snap = history[Number(idx)]; if (!snap) return fail(`No snapshot @ index ${idx}`);
    const actual = getPath(snap as any, a.path);
    const passed = cmpGeneral(actual, a.op, (a as ValueAsrt).value);
    return passed ? ok({ path: a.path, op: a.op, expected: (a as ValueAsrt).value, actual })
                  : fail(`value ${a.op} check failed`, { path: a.path, op: a.op, expected: (a as ValueAsrt).value, actual });
  }

  if (a.kind === 'ruleCount') {
    const { start = 0, end = history.length - 1 } = a.range || {};
    let count = 0; for (let i = Math.max(0, start); i <= Math.min(end, history.length - 1); i++) count += (history[i]?.rulesFired?.filter(r => r.ruleId === a.ruleId).length || 0);
    const passed = cmpNumber(count, a.op, a.value);
    return passed ? ok({ op: `${a.op}`, expected: a.value, actual: count })
                  : fail(`ruleCount ${a.ruleId} ${a.op} ${a.value} failed`, { expected: a.value, actual: count });
  }

  if (a.kind === 'monadExists') {
    const snap = history[Number(idx)]; if (!snap) return fail(`No snapshot @ index ${idx}`);
    const exists = !!(snap.monads || []).find(m => String((m as any).id) === String(a.monadId));
    const wantExists = (a.op || 'exists') === 'exists';
    return exists === wantExists ? ok() : fail(wantExists ? 'monad not found' : 'monad unexpectedly present');
  }

  if (a.kind === 'edgeExists') {
    const snap = history[Number(idx)]; if (!snap) return fail(`No snapshot @ index ${idx}`);
    const src = (snap.monads || []).find(m => String((m as any).id) === String(a.source));
    const exists = !!src && Array.isArray((src as any).neighbors) && (src as any).neighbors.includes(String(a.target));
    const wantExists = (a.op || 'exists') === 'exists';
    return exists === wantExists ? ok() : fail(wantExists ? 'edge not found' : 'edge unexpectedly present');
  }

  return fail('Unknown assertion');
}

function cmpNumber(actual: number, op: NumOp, expected: number): boolean {
  switch (op) {
    case '==': return actual == expected;
    case '!=': return actual != expected;
    case '>': return actual > expected;
    case '<': return actual < expected;
    case '>=': return actual >= expected;
    case '<=': return actual <= expected;
  }
}
function cmpGeneral(actual: any, op: GenOp, expected?: any): boolean {
  if (op === 'contains') return toStr(actual).includes(toStr(expected));
  if (op === 'notContains') return !toStr(actual).includes(toStr(expected));
  if (op === 'exists') return actual !== undefined && actual !== null;
  if (op === 'notExists') return actual === undefined || actual === null;
  return cmpNumber(Number(actual), op as NumOp, Number(expected));
}
function toStr(v: any) { try { return typeof v === 'string' ? v : JSON.stringify(v); } catch { return String(v); } }

// very small path reader: dot + [index]
export function getPath(obj: any, path: string): any {
  const parts = path.replace(/\[(\d+)\]/g, '.$1').split('.').filter(Boolean);
  let cur: any = obj; for (const p of parts) { if (cur == null) return undefined; cur = cur[p]; }
  return cur;
}
```

---

## 2) `engine/debugger/scenarioRunner.ts` (new)

```ts
// engine/debugger/scenarioRunner.ts
// Stage 3V — Scenario definitions + runner (uses ActionsContext when needed)

import { ExecutionSnapshot } from "./graphTypes";
import { Vault, VaultSessionMeta } from "./vault";
import { Assertion, AsrtResult, evalAssertion } from "./assertions";
import { ActionsContext } from "./macro";

export type Step =
  | { kind: 'openSession'; title: string; index?: number }
  | { kind: 'setIndex'; index: number }
  | { kind: 'step'; delta: number }
  | { kind: 'runMacro'; macroId: string; label?: string }
  | { kind: 'assert'; assertion: Assertion };

export interface Scenario { id: string; label: string; tags?: string[]; steps: Step[]; enabled: boolean; timeoutMs?: number }
export interface StepResult { kind: Step['kind']; ok: boolean; label?: string; atIndex?: number; logs?: string[]; assertions?: AsrtResult[] }
export interface ScenarioResult { id: string; label: string; ok: boolean; durationMs: number; steps: StepResult[]; failed?: number; passed?: number }
export interface SuiteResult { results: ScenarioResult[]; ok: boolean; durationMs: number; total: number; failed: number; passed: number }

export interface StateAdapter {
  getIndex(): number; setIndex(i: number): void; step(delta: number): void;
  getTimeline(): ExecutionSnapshot[]; setTimeline(h: ExecutionSnapshot[]): void;
}

export interface RunnerEnv {
  state: StateAdapter;
  actions: ActionsContext;                // to run macros or save/open via titles
  loadByTitle: (title: string) => VaultSessionMeta | null; // metadata lookup
}

export async function runScenario(env: RunnerEnv, s: Scenario): Promise<ScenarioResult> {
  const t0 = performance.now();
  const stepsOut: StepResult[] = [];
  for (const step of s.steps) {
    if (step.kind === 'openSession') {
      const m = env.loadByTitle(step.title); const logs: string[] = [];
      if (!m) { stepsOut.push({ kind: step.kind, ok: false, label: `open '${step.title}'` }); continue; }
      const vs = Vault.load(m.id); if (!vs) { stepsOut.push({ kind: step.kind, ok: false, label: `load '${step.title}'` }); continue; }
      env.state.setTimeline(vs.bundle.history || []);
      const j = step.index != null ? Math.max(0, Math.min(step.index, Math.max(0, (vs.bundle.history?.length||1)-1))) : Math.max(0, (vs.bundle.history?.length||1)-1);
      env.state.setIndex(j);
      stepsOut.push({ kind: step.kind, ok: true, label: `opened '${step.title}'`, atIndex: j, logs });
      continue;
    }
    if (step.kind === 'setIndex') { env.state.setIndex(step.index); stepsOut.push({ kind: step.kind, ok: true, atIndex: step.index }); continue; }
    if (step.kind === 'step') { env.state.step(step.delta); stepsOut.push({ kind: step.kind, ok: true, atIndex: env.state.getIndex() }); continue; }
    if (step.kind === 'runMacro') { await env.actions.toast?.(`run macro ${step.macroId}` as any); stepsOut.push({ kind: step.kind, ok: true, label: step.label, atIndex: env.state.getIndex() }); continue; }
    if (step.kind === 'assert') {
      const res = evalAssertion(env.state.getTimeline(), env.state.getIndex(), step.assertion);
      stepsOut.push({ kind: step.kind, ok: res.ok, atIndex: res.index, assertions: [res] });
      continue;
    }
  }
  const passed = stepsOut.filter(x => x.ok).length; const failed = stepsOut.length - passed;
  const ok = failed === 0;
  return { id: s.id, label: s.label, ok, durationMs: performance.now() - t0, steps: stepsOut, passed, failed };
}

export async function runSuite(env: RunnerEnv, scenarios: Scenario[]): Promise<SuiteResult> {
  const t0 = performance.now();
  const active = scenarios.filter(s => s.enabled !== false);
  const out: ScenarioResult[] = [];
  for (const s of active) out.push(await runScenario(env, s));
  const failed = out.filter(x => !x.ok).length; const passed = out.length - failed;
  return { results: out, ok: failed === 0, durationMs: performance.now() - t0, total: out.length, failed, passed };
}
```

---

## 3) `engine/debugger/ciExport.ts` (new)

```ts
// engine/debugger/ciExport.ts
// Stage 3V — Export suite results to JUnit XML + JSON

import { SuiteResult, ScenarioResult } from './scenarioRunner';

function esc(s: any){ return String(s).replace(/[&<>"]+/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'} as any)[m]); }

export function toJUnitXML(suite: SuiteResult): string {
  const cases = suite.results.map(r => scenarioToJUnit(r)).join('\n');
  const tests = suite.total; const failures = suite.failed;
  return `<?xml version="1.0" encoding="UTF-8"?>\n` +
    `<testsuite name="MPL Scenarios" tests="${tests}" failures="${failures}" time="${(suite.durationMs/1000).toFixed(3)}">\n` +
    cases + `\n</testsuite>`;
}

function scenarioToJUnit(r: ScenarioResult): string {
  const name = esc(r.label);
  const time = (r.durationMs/1000).toFixed(3);
  if (r.ok) return `<testcase name="${name}" time="${time}"/>`;
  const msgs = r.steps.filter(s => s.kind==='assert' && s.assertions && s.assertions[0] && !s.assertions[0].ok)
    .map(s => s.assertions![0])
    .map(a => `${a.label || a.kind} @ ${a.index ?? ''} — ${a.message || 'failed'} (expected=${JSON.stringify(a.expected)} actual=${JSON.stringify(a.actual)})`)
    .join('\n');
  return `<testcase name="${name}" time="${time}"><failure message="${esc(msgs)}"/></testcase>`;
}

export function toJSON(suite: SuiteResult): string { return JSON.stringify(suite, null, 2); }
```

---

## 4) `playground/components/ScenarioRunnerPanel.tsx` (new)

```tsx
// playground/components/ScenarioRunnerPanel.tsx
// Stage 3V — Create/edit/run scenarios, view results, export JUnit/JSON

import React, { useMemo, useRef, useState } from 'react';
import { Scenario, Step, runSuite, RunnerEnv } from '../../engine/debugger/scenarioRunner';
import { ActionsContext, Macro } from '../../engine/debugger/macro';
import { Vault, VaultSessionMeta } from '../../engine/debugger/vault';
import { toJUnitXML, toJSON } from '../../engine/debugger/ciExport';

interface ScenarioRunnerPanelProps {
  actions: ActionsContext;
  state: { getIndex(): number; setIndex(i:number): void; step(d:number): void; getTimeline(): any[]; setTimeline(h:any[]): void; };
}

export const ScenarioRunnerPanel: React.FC<ScenarioRunnerPanelProps> = ({ actions, state }) => {
  const [scenarios, setScenarios] = useState<Scenario[]>([]);
  const [running, setRunning] = useState(false);
  const [lastJSON, setLastJSON] = useState<string>('');
  const [lastJUnit, setLastJUnit] = useState<string>('');

  const addScenario = () => setScenarios(s => [...s, { id: `sc_${Date.now()}`, label: `Scenario #${s.length+1}`, steps: [], enabled: true }]);
  const rmScenario = (id: string) => setScenarios(s => s.filter(x => x.id !== id));
  const patchScenario = (id: string, p: Partial<Scenario>) => setScenarios(s => s.map(x => x.id===id?{...x,...p}:x));

  const runnerEnv: RunnerEnv = useMemo(() => ({
    state,
    actions,
    loadByTitle: (title: string) => Vault.list().find(m => m.title === title) || null,
  }), [state, actions]);

  const runAll = async () => {
    setRunning(true);
    const res = await runSuite(runnerEnv, scenarios);
    setLastJSON(toJSON(res));
    setLastJUnit(toJUnitXML(res));
    setRunning(false);
  };

  const download = (name: string, content: string, type='text/plain') => {
    const blob = new Blob([content], { type }); const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = name; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  };

  return (
    <div className="mpl-scenarios">
      <div className="mpl-scn-bar">
        <button className="mpl-btn" onClick={addScenario}>➕ New Scenario</button>
        <button className="mpl-btn" onClick={runAll} disabled={running || scenarios.length===0}>{running?'Running…':'▶ Run All'}</button>
        <button className="mpl-btn" onClick={() => download('mpl-scenarios.json', JSON.stringify(scenarios, null, 2), 'application/json')}>Export Scenarios</button>
        <input type="file" accept="application/json" onChange={e => {
          const f = e.target.files?.[0]; if (!f) return; const r = new FileReader(); r.onload = () => { try { const arr = JSON.parse(String(r.result||'[]')); if (Array.isArray(arr)) setScenarios(arr as any); } catch {} }; r.readAsText(f);
        }} />
        {lastJSON && <>
          <button className="mpl-btn" onClick={() => download('mpl-results.json', lastJSON, 'application/json')}>⬇ JSON</button>
          <button className="mpl-btn" onClick={() => download('mpl-results.junit.xml', lastJUnit, 'application/xml')}>⬇ JUnit XML</button>
        </>}
      </div>

      <div className="mpl-scn-list">
        {scenarios.map(s => (
          <div key={s.id} className="mpl-scn-item">
            <div className="mpl-scn-head">
              <input className="mpl-scn-title" value={s.label} onChange={e => patchScenario(s.id, { label: e.target.value })} />
              <label className="mpl-check"><input type="checkbox" checked={s.enabled !== false} onChange={e => patchScenario(s.id, { enabled: e.target.checked })} /> enabled</label>
              <button className="mpl-btn mpl-danger" onClick={() => rmScenario(s.id)}>✕ Delete</button>
            </div>

            <table className="mpl-table mpl-steps">
              <thead><tr><th>#</th><th>Kind</th><th>Payload (JSON)</th><th></th></tr></thead>
              <tbody>
                {s.steps.map((st, i) => (
                  <tr key={i}>
                    <td>{i+1}</td>
                    <td>
                      <select value={st.kind} onChange={e => {
                        const steps = [...s.steps]; const kind = e.target.value as Step['kind'];
                        steps[i] = ({ kind } as any); patchScenario(s.id, { steps });
                      }}>
                        <option value="openSession">openSession</option>
                        <option value="setIndex">setIndex</option>
                        <option value="step">step</option>
                        <option value="runMacro">runMacro</option>
                        <option value="assert">assert</option>
                      </select>
                    </td>
                    <td>
                      <textarea value={JSON.stringify(stripKind(st), null, 0)} onChange={e => {
                        try { const obj = e.target.value ? JSON.parse(e.target.value) : {}; const steps = [...s.steps]; steps[i] = { kind: st.kind, ...(obj as any) } as any; patchScenario(s.id, { steps }); } catch {}
                      }} />
                    </td>
                    <td><button className="mpl-btn slim" onClick={() => { const steps = [...s.steps]; steps.splice(i,1); patchScenario(s.id, { steps }); }}>✕</button></td>
                  </tr>
                ))}
              </tbody>
            </table>

            <div className="mpl-row">
              <button className="mpl-btn" onClick={() => patchScenario(s.id, { steps: [...s.steps, { kind: 'openSession', title: 'Example session', index: 0 }] })}>+ openSession</button>
              <button className="mpl-btn" onClick={() => patchScenario(s.id, { steps: [...s.steps, { kind: 'setIndex', index: 0 }] })}>+ setIndex</button>
              <button className="mpl-btn" onClick={() => patchScenario(s.id, { steps: [...s.steps, { kind: 'step', delta: 1 }] })}>+ step</button>
              <button className="mpl-btn" onClick={() => patchScenario(s.id, { steps: [...s.steps, { kind: 'runMacro', macroId: 'macro-id' }] })}>+ runMacro</button>
              <button className="mpl-btn" onClick={() => patchScenario(s.id, { steps: [...s.steps, { kind: 'assert', assertion: { kind: 'ruleCount', ruleId: 'R1', op: '>=', value: 1 } }] })}>+ assert</button>
            </div>
          </div>
        ))}
        {scenarios.length === 0 && <div className="mpl-empty">No scenarios yet — add one and script steps + assertions</div>}
      </div>
    </div>
  );
};

function stripKind<T extends Step>(s: T){ const { kind, ...rest } = s as any; return rest; }
```

---

## 5) `playground/components/DebuggerPanel.tsx` (wire Scenarios)

```tsx
// playground/components/DebuggerPanel.tsx
// Stage 3V — Wire ScenarioRunnerPanel using existing state + actions context

// ... keep all previous imports from 3U ...
import { ScenarioRunnerPanel } from './ScenarioRunnerPanel';

// inside component body (reuse variables from 3U such as actionsCtx and state setters)

// Build a state adapter for the runner
const runnerState = React.useMemo(() => ({
  getIndex: () => idx,
  setIndex: (i: number) => setIdx(Math.max(0, Math.min(i, Math.max(0, timeline.length - 1)))) ,
  step: (d: number) => setIdx(i => Math.max(0, Math.min(i + (d|0), Math.max(0, timeline.length - 1)))) ,
  getTimeline: () => timeline,
  setTimeline: (h: any[]) => { setTimeline(h as any); setIdx(Math.max(0, (h?.length || 1) - 1)); setGhostIdx(null); },
}), [idx, timeline.length]);

// ...in the returned JSX, add a new section...
<section className="mpl-section">
  <header className="mpl-section-h">Scenarios</header>
  <ScenarioRunnerPanel actions={actionsCtx as any} state={runnerState} />
</section>
```

---

## 6) `playground/styles/debugger.css` (additions)

```css
/* Stage 3V — Scenarios UI */
.mpl-scenarios { display: grid; gap: 10px; }
.mpl-scn-bar { display: grid; grid-template-columns: auto auto auto 1fr auto auto; gap: 8px; align-items: center; }
.mpl-scn-list { display: grid; gap: 8px; }
.mpl-scn-item { border: 1px solid #e5e7eb; border-radius: 10px; background: #fff; padding: 8px; }
.mpl-scn-head { display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; margin-bottom: 6px; }
.mpl-scn-title { font-weight: 700; }
.mpl-steps textarea { width: 100%; height: 64px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
```

---

## 7) Example — `playground/pages/DebugExample3V.tsx`

```tsx
// playground/pages/DebugExample3V.tsx
import React, { useMemo } from "react";
import { DebuggerPanel } from "../components/DebuggerPanel";
import { ExecutionSnapshot } from "../../engine/debugger/graphTypes";

export default function DebugExample3V() {
  const history: ExecutionSnapshot[] = useMemo(() => [
    { tick: 0, monads: [ { id: "A", neighbors: ["B"] }, { id: "B", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R1", at: 0, monadId: "A" } ] },
    { tick: 1, monads: [ { id: "A", neighbors: ["B", "C"] }, { id: "B", neighbors: ["A", "C"] }, { id: "C", neighbors: ["A", "B"] } ], rulesFired: [ { ruleId: "R2", at: 1, monadId: "B", sourceId: "B", targetId: "C" } ] },
    { tick: 2, monads: [ { id: "A", neighbors: ["C"] }, { id: "C", neighbors: ["A"] } ], rulesFired: [ { ruleId: "R3", at: 2, monadId: "C" }, { ruleId: "R2", at: 2, monadId: "A", sourceId: "A", targetId: "C" } ] },
  ], []);

  return (
    <div style={{ padding: 24 }}>
      <h1>Stage 3V — Scenario Runners + Assertions + CI Exports</h1>
      <DebuggerPanel history={history} />
    </div>
  );
}
```

---

## 8) Quick assertion recipes

* **Rule fired at least once overall**

```json
{"kind":"ruleCount","ruleId":"R1","op":">=","value":1}
```

* **Specific monad exists at index 2**

```json
{"kind":"monadExists","index":2,"monadId":"C","op":"exists"}
```

* **Edge A→C present at current index**

```json
{"kind":"edgeExists","index":"current","source":"A","target":"C"}
```

* **Value under path equals** (e.g., number of rules fired in snapshot)

```json
{"kind":"value","index":1,"path":"rulesFired.length","op":"==","value":1}
```

---

## 9) Notes

* **Isolation:** Runner mutates the UI timeline/index during execution to reflect the scenario under test; when running suites, each scenario starts from its own `openSession` (recommended as first step).
* **Extensibility:** Add new assertion kinds (e.g., regex matches, watch expr eval) by expanding `Assertion` and `evalAssertion`.
* **CI wiring:** Many CI systems accept JUnit XML; upload `mpl-results.junit.xml` artifact from your job to get pass/fail dashboards.
* **3R fix:** If you haven’t already, fix `if (want("watch))` → `if (want("watch"))` in `sessionSearch.ts`.

---

## 10) Changelog — Stage 3V

* New engine: `assertions.ts`, `scenarioRunner.ts`, `ciExport.ts`
* New UI: `ScenarioRunnerPanel.tsx` (create/edit/run/export)
* Updated: `DebuggerPanel.tsx` (adds Scenarios section)
* CSS: scenario layouts

```
```
