# MPL – Stage 3F (Record/Replay Traces + Offline Benchmarks)

Stage **3F** adds **deterministic traces** and **offline benchmarking**.

* **Trace format (.mpltrace)**: NDJSON with `init`, optional `note`, repeated `frame` events. Frames carry **RLE-compressed** full-grid snapshots.
* **Recorder (web)**: capture from **GPU (3A)** or **CPU/Workers (3B)** at a set interval and **download** as `.mpltrace`.
* **Replay (web)**: load a trace and play it back using the **3C tiled renderer**.
* **Bench (node/CLI)**: offline CPU benchmarks across sizes/rules with CSV output.

---

## Directory Tree (delta)

```
MPL-Stage-3/
├─ package.json
├─ README.md
├─ src/
│  ├─ gpu/
│  │  ├─ stepper.ts
│  ├─ render/
│  │  ├─ tiled-renderer.ts
│  ├─ trace/
│  │  ├─ schema.ts         # NEW: event types + helpers
│  │  ├─ rle.ts            # NEW: row-wise RLE + base64
│  │  ├─ ndjson.ts         # NEW: writer/reader for browser & node
│  │  ├─ record.ts         # NEW: recorder core (plugs engines)
│  │  └─ replay.ts         # NEW: replay core
│  ├─ web/
│  │  ├─ record-main.ts    # NEW: UI to record traces
│  │  └─ replay-main.ts    # NEW: UI to replay traces
│  └─ bench/
│     └─ cpu-runner.ts     # NEW: node CPU bench (CSV)
├─ index-3f-record.html     # NEW: Stage 3F recorder
└─ index-3f-replay.html     # NEW: Stage 3F replay
```

Add to **package.json**:

```json
{
  "scripts": {
    "dev:3f:rec": "vite --open index-3f-record.html",
    "dev:3f:replay": "vite --open index-3f-replay.html",
    "bench:cpu": "tsx src/bench/cpu-runner.ts --out bench.csv"
  },
  "devDependencies": {
    "tsx": "^4.19.0"
  }
}
```

---

## src/trace/schema.ts (NEW)

```ts
export type TraceInit = {
  type: 'init';
  schema: 'mpl-trace@1';
  width: number; height: number; rule: string;
  topology: 'Moore' | 'VonNeumann'; edges: 'Wrap' | 'Clip';
  seed: number; engine: 'GPU' | 'CPU' | 'Workers';
  tile?: { w: number; h: number };
  notes?: string;
};

export type TraceFrame = {
  type: 'frame';
  step: number; // starting at 0
  pop: number;  // alive count
  bbox?: { x0:number;y0:number;x1:number;y1:number };
  // full-grid snapshot, row-major RLE compressed then base64
  rle_b64: string;
};

export type TraceNote = { type: 'note'; step: number; text: string };
export type TraceEvent = TraceInit | TraceFrame | TraceNote;
```

---

## src/trace/rle.ts (NEW — compact row-wise RLE)

```ts
// Encode a Uint8Array grid (0/1) of size W×H into RLE bytes: [count, value] repeating per row
export function rleEncode(grid: Uint8Array, W:number, H:number): Uint8Array {
  const out: number[] = [];
  for (let y=0; y<H; y++){
    let i=y*W, end=i+W; let v=grid[i]&1, n=1; i++;
    for (; i<end; i++){ const b=grid[i]&1; if (b===v && n<255) n++; else { out.push(n, v); v=b; n=1; } }
    out.push(n, v);
  }
  return Uint8Array.from(out);
}

export function rleDecode(bytes: Uint8Array, W:number, H:number): Uint8Array {
  const out = new Uint8Array(W*H); let i=0, p=0;
  for (let y=0; y<H; y++){
    let written=0; while (written < W){ const n=bytes[p++], v=bytes[p++]; out.fill(v&1, y*W+written, y*W+written+n); written+=n; }
  }
  return out;
}

export function b64(x: Uint8Array){ return btoa(String.fromCharCode(...x)); }
export function unb64(s: string){ const bin = atob(s); const out = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i); return out; }
```

---

## src/trace/ndjson.ts (NEW — writer/reader)

```ts
export class NDJSONWriter {
  private lines: string[] = [];
  write(obj: any){ this.lines.push(JSON.stringify(obj)); }
  blob(){ return new Blob([this.lines.join('\n')], { type: 'application/x-ndjson' }); }
}

export async function* ndjsonStream(file: File): AsyncGenerator<any> {
  const text = await file.text();
  for (const line of text.split(/\r?\n/)) if (line.trim()) yield JSON.parse(line);
}
```

---

## src/trace/record.ts (NEW — recorder core)

```ts
import { rleEncode, b64 } from './rle.js';
import type { TraceInit, TraceFrame } from './schema.js';

export type SnapshotSource = {
  width: number; height: number;
  // Read entire grid as Uint8Array (0/1). GPU path can aggregate from tiles.
  readFull(): Promise<Uint8Array> | Uint8Array;
  // Optional: compute population and bbox cheaply if available
  stats?(buf: Uint8Array): { pop:number; bbox?:{x0:number;y0:number;x1:number;y1:number} };
};

export class Recorder {
  private step = 0; private nextCapture = 0;
  constructor(private src: SnapshotSource, private init: TraceInit, private interval=10){ }

  async captureIfNeeded(writer: { write(o:any): void }){
    if (this.step === 0){ writer.write(this.init); }
    if (this.step >= this.nextCapture){
      const buf = await this.src.readFull();
      const { pop, bbox } = this.src.stats? this.src.stats(buf) : { pop: buf.reduce((a,b)=>a+(b&1),0) } as any;
      const rle = rleEncode(buf, this.src.width, this.src.height);
      const frame: TraceFrame = { type:'frame', step: this.step, pop, bbox, rle_b64: b64(rle) };
      writer.write(frame); this.nextCapture += this.interval;
    }
    this.step++;
  }
}
```

---

## src/trace/replay.ts (NEW — replay core)

```ts
import type { TraceEvent, TraceInit, TraceFrame } from './schema.js';
import { unb64, rleDecode } from './rle.js';

export class Replay {
  init!: TraceInit; frames: TraceFrame[] = []; idx=0;
  load(evts: TraceEvent[]){
    const init = evts.find(e=> e.type==='init') as TraceInit; if (!init) throw new Error('missing init'); this.init = init;
    this.frames = evts.filter(e=> e.type==='frame') as TraceFrame[]; this.idx = 0;
  }
  hasNext(){ return this.idx < this.frames.length; }
  step(){ if (!this.hasNext()) return null; const f=this.frames[this.idx++]; const bytes=unb64(f.rle_b64); const grid=rleDecode(bytes, this.init.width, this.init.height); return { f, grid }; }
}
```

---

## src/web/record-main.ts (NEW — Record UI)

```ts
import { WebGpuStepper, bsToMasks } from '../gpu/stepper.js';
import { Recorder } from '../trace/record.js';
import { NDJSONWriter } from '../trace/ndjson.js';

const $=<T extends HTMLElement>(id:string)=> document.getElementById(id) as T;
const engineSel=$('engine') as HTMLSelectElement; const ruleInp=$('rule') as HTMLInputElement; const gridSel=$('grid') as HTMLSelectElement;
const everyInp=$('every') as HTMLInputElement; const notesInp=$('notes') as HTMLInputElement; const startBtn=$('start'); const stopBtn=$('stop');
const status=$('status');

let playing=false; let gpu: WebGpuStepper|null=null; let width=512, height=384; let writer: NDJSONWriter|null=null; let rec: Recorder|null=null;

function parseGrid(v:string){ const [w,h]=v.split('x').map(Number); width=w; height=h; }

async function makeGPU(){ const { birthMask, surviveMask } = bsToMasks(ruleInp.value||'B3/S23'); const s=new WebGpuStepper({ width, height, birthMask, surviveMask, useMoore:true, wrapEdges:true, seed:()=> Math.random()<0.2?1:0 }); await s.init(); return s; }

async function start(){
  parseGrid(gridSel.value);
  writer = new NDJSONWriter();
  const init = { type:'init', schema:'mpl-trace@1', width, height, rule: ruleInp.value||'B3/S23', topology:'Moore', edges:'Wrap', seed: 0, engine: engineSel.value as any, notes: notesInp.value } as const;
  gpu = await makeGPU();
  const src = { width, height, async readFull(){ return await gpu!.readTile(0,0,width,height); } };
  rec = new Recorder(src, init, Math.max(1, Number(everyInp.value)||10));
  playing = true; loop(); status!.textContent='recording…';
}

function stop(){
  playing=false; status!.textContent='stopped';
  if (writer){ const blob=writer.blob(); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`trace-${Date.now()}.mpltrace`; a.click(); URL.revokeObjectURL(a.href); }
}

async function tick(){ gpu!.stepOnce(); await rec!.captureIfNeeded(writer!); }
function loop(){ if(!playing) return; tick().then(()=> requestAnimationFrame(loop)); }

startBtn!.addEventListener('click', ()=> start());
stopBtn!.addEventListener('click', ()=> stop());
```

---

## src/web/replay-main.ts (NEW — Replay UI)

```ts
import { Replay } from '../trace/replay.js';
import { TiledRenderer } from '../render/tiled-renderer.js';

const $=<T extends HTMLElement>(id:string)=> document.getElementById(id) as T;
const fileInp=$('file') as HTMLInputElement; const playBtn=$('play'); const stepBtn=$('step'); const info=$('info');
const canvas = document.getElementById('grid') as HTMLCanvasElement;
let renderer: TiledRenderer; let replay: Replay|null=null; let playing=false; let view={x:0,y:0,zoom:4};

function cellsSourceFrom(buf: Uint8Array, W:number, H:number){
  return { gridW:W, gridH:H, version: ()=> 1, readRect: (x0:number,y0:number,x1:number,y1:number)=>{ const w=x1-x0, h=y1-y0; const out=new Uint8Array(w*h); for(let y=0;y<h;y++){ out.set(buf.slice((y0+y)*W+x0, (y0+y)*W+x0+w), y*w); } return out; } };
}

async function loadFile(file: File){
  const text = await file.text(); const evts = text.split(/\r?\n/).filter(Boolean).map(JSON.parse);
  replay = new Replay(); replay.load(evts as any);
  info!.textContent = `${replay.init.width}×${replay.init.height}  rule=${replay.init.rule}`;
  renderer = new TiledRenderer(canvas, cellsSourceFrom(new Uint8Array(replay.init.width*replay.init.height), replay.init.width, replay.init.height), 64, 64);
}

async function step(){ if (!replay?.hasNext()) return; const { f, grid } = replay.step()!; (renderer as any).setSource(cellsSourceFrom(grid, replay.init.width, replay.init.height)); await renderer.draw(view, 128); info!.textContent = `step ${f.step} • pop ${f.pop}`; }

function loop(){ if(!playing) return; step().then(()=> requestAnimationFrame(loop)); }

fileInp.addEventListener('change', ()=>{ const f=fileInp.files?.[0]; if(f) loadFile(f); });
playBtn.addEventListener('click', ()=>{ playing=!playing; playBtn!.textContent = playing? '⏸ Pause':'▶︎ Play'; if(playing) loop(); });
stepBtn.addEventListener('click', ()=>{ if(!playing) step(); });
```

---

## src/bench/cpu-runner.ts (NEW — Node CPU benchmark)

```ts
#!/usr/bin/env tsx
import fs from 'node:fs';

type Case = { size:[number,number]; rule:string; steps:number };

function bsMasks(rule:string){ const m=rule.toUpperCase().match(/^(?:B([0-8]*)\/S([0-8]*))|(?:S([0-8]*)\/B([0-8]*))$/); if(!m) throw new Error('rule'); const b=(m[1]??m[4]??'').split('').map(Number); const s=(m[2]??m[3]??'').split('').map(Number); let B=0,S=0; for(const n of b) B|=(1<<n); for(const n of s) S|=(1<<n); return {B,S}; }

function stepLife(A:Uint8Array, W:number, H:number, B:number, S:number){ const get=(x:number,y:number)=> A[((y+H)%H)*W + ((x+W)%W)]&1; const out=new Uint8Array(A.length); for(let y=0;y<H;y++) for(let x=0;x<W;x++){ let n=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ if(dx||dy) n+= get(x+dx,y+dy); } const self=get(x,y); out[y*W+x] = self? ((S>>>n)&1) : ((B>>>n)&1); } return out; }

function benchOne(c:Case){ const [W,H]=c.size; const N=W*H; const A=new Uint8Array(N); for(let i=0;i<N;i++) A[i]=(Math.random()<0.2)?1:0; const {B,S}=bsMasks(c.rule); const t0=performance.now(); let buf=A; for(let i=0;i<c.steps;i++){ buf = stepLife(buf,W,H,B,S); } const dt=performance.now()-t0; return { ms: dt, nsPerCellStep: (dt*1e6)/(N*c.steps) } }

const args = process.argv.slice(2); const outPath = args.includes('--out')? args[args.indexOf('--out')+1] : 'bench.csv';
const cases: Case[] = [ { size:[256,192], rule:'B3/S23', steps:400 }, { size:[512,384], rule:'B3/S23', steps:200 }, { size:[1024,768], rule:'B3/S23', steps:100 } ];
let csv = 'size,rule,steps,ms,ns_per_cell_step\n';
for (const c of cases){ const r=benchOne(c); csv += `${c.size[0]}x${c.size[1]},${c.rule},${c.steps},${r.ms.toFixed(2)},${r.nsPerCellStep.toFixed(1)}\n`; }
fs.writeFileSync(outPath, csv, 'utf8'); console.log('wrote', outPath); 
```

---

## index-3f-record.html (NEW — Recorder UI)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 3F – Record Trace</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input, select { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 3F (Record Trace)</h1>
    <small>Full-grid RLE snapshots → .mpltrace</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <label>Engine</label>
        <select id="engine"><option>GPU</option><option>CPU</option></select>
        <label>Rule</label>
        <input id="rule" value="B3/S23" />
      </div>
      <div class="row">
        <label>Grid</label>
        <select id="grid"><option>512x384</option><option>768x512</option><option>1024x768</option></select>
      </div>
      <div class="row">
        <label>Capture every</label>
        <input id="every" type="number" value="10" min="1" />
      </div>
      <div class="row">
        <label>Notes</label>
        <input id="notes" placeholder="experiment notes" />
      </div>
      <div class="row">
        <button id="start">Start Recording</button>
        <button id="stop">Stop & Download</button>
      </div>
      <div class="row">Status: <span id="status">idle</span></div>
    </aside>
    <section class="panel">
      <p>This page records snapshots while the sim runs (headless).</p>
    </section>
  </main>
  <script type="module" src="/src/web/record-main.ts"></script>
</body>
</html>
```

---

## index-3f-replay.html (NEW — Replay UI)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPL 3F – Replay Trace</title>
  <style>
    :root { --bg:#0f1214; --fg:#e8eef2; --muted:#8aa1b1; --accent:#56b6c2; }
    body { margin:0; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; border-bottom:1px solid #1b2227; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0 12px 0 0; color:var(--accent); }
    main { display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px; }
    .panel { background:#101418; border:1px solid #1b2227; border-radius:12px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; flex-wrap: wrap; }
    button, input { background:#151a1f; color:var(--fg); border:1px solid #242d34; border-radius:8px; padding:6px 10px; }
    canvas { background:#0a0e11; border:1px solid #1b2227; border-radius:8px; image-rendering: pixelated; width:100%; height:auto; }
  </style>
</head>
<body>
  <header>
    <h1>MPL – Stage 3F (Replay Trace)</h1>
    <small>NDJSON → tiled renderer</small>
  </header>
  <main>
    <aside class="panel">
      <div class="row">
        <input id="file" type="file" accept=".mpltrace,application/x-ndjson,text/plain" />
      </div>
      <div class="row">
        <button id="play">▶︎ Play</button>
        <button id="step">Step</button>
      </div>
      <div class="row"><span id="info">—</span></div>
    </aside>
    <section class="panel">
      <canvas id="grid" width="960" height="640"></canvas>
    </section>
  </main>
  <script type="module" src="/src/web/replay-main.ts"></script>
</body>
</html>
```

---

## README addendum (3F)

````md
### 3F – Record/Replay Traces + Offline Benchmarks

**Record a trace (web):**
```bash
npm run dev:3f:rec
# open the page, set rule/size, Start, then Stop & Download → trace-*.mpltrace
````

**Replay a trace (web):**

```bash
npm run dev:3f:replay
# load your .mpltrace and play/step
```

**Offline CPU bench (Node):**

```bash
npm run bench:cpu
# produces bench.csv with ms and ns_per_cell_step
```

**Format**: `.mpltrace` is **NDJSON**:

* First line: `init` (schema, size, rule, engine, notes)
* Next lines: `frame` with `step`, `pop`, `bbox`, `rle_b64` (RLE of 0/1 grid)

> Deterministic replay is achieved by storing full frames. For input-driven sims, extend with `note`/input events.

```
```
